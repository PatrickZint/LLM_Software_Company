b'PK\x03\x04\x14\x00\x00\x00\x00\x00\x05T\x1b[M\xb5\t\x17\x95\n\x00\x00\x95\n\x00\x00\x11\x00\x00\x00config_manager.pyimport json\nimport jsonschema\nfrom jsonschema import validate\nimport logging\n\n# Define the JSON schema for configuration validation\nCONFIG_SCHEMA = {\n    "type": "object",\n    "properties": {\n        "version": {"type": "string"},\n        "global_parameters": {\n            "type": "object",\n            "properties": {\n                "gravitational_constant": {"type": "number"},\n                "time_step": {"type": "number"},\n                "integrator": {"type": "string", "enum": ["euler", "verlet", "rk4"]}\n            },\n            "required": ["gravitational_constant", "time_step", "integrator"]\n        },\n        "bodies": {\n            "type": "array",\n            "items": {\n                "type": "object",\n                "properties": {\n                    "id": {"type": "string"},\n                    "mass": {"type": "number", "exclusiveMinimum": 0},\n                    "position": {\n                        "type": "array",\n                        "items": {"type": "number"},\n                        "minItems": 2,\n                        "maxItems": 2\n                    },\n                    "velocity": {\n                        "type": "array",\n                        "items": {"type": "number"},\n                        "minItems": 2,\n                        "maxItems": 2\n                    }\n                },\n                "required": ["id", "mass", "position", "velocity"]\n            }\n        }\n    },\n    "required": ["version", "global_parameters", "bodies"]\n}\n\nclass ConfigManager:\n    @staticmethod\n    def load_configuration(file_path):\n        """\n        Loads and validates the simulation configuration from a JSON file.\n        """\n        try:\n            with open(file_path, \'r\') as f:\n                config = json.load(f)\n            # Validate the configuration against the schema\n            validate(instance=config, schema=CONFIG_SCHEMA)\n            logging.info(f"Configuration loaded and validated from {file_path}")\n            return config\n        except jsonschema.exceptions.ValidationError as ve:\n            logging.error(f"Configuration validation error: {ve.message}")\n            raise\n        except Exception as e:\n            logging.error(f"Error loading configuration: {str(e)}")\n            raise\n\n    @staticmethod\n    def save_configuration(config, file_path):\n        """\n        Saves a simulation configuration to a JSON file.\n        """\n        try:\n            with open(file_path, \'w\') as f:\n                json.dump(config, f, indent=4)\n            logging.info(f"Configuration saved to {file_path}")\n        except Exception as e:\n            logging.error(f"Error saving configuration: {str(e)}")\n            raise\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x05T\x1b[|\xd7\xa0\x12\x0c\x04\x00\x00\x0c\x04\x00\x00\x11\x00\x00\x00celestial_body.pyimport numpy as np\n\nclass CelestialBody:\n    def __init__(self, identifier, mass, position, velocity):\n        if mass <= 0:\n            raise ValueError(f"Mass must be positive for body {identifier}")\n        if not (isinstance(position, list) or isinstance(position, tuple)) or len(position) != 2:\n            raise ValueError(f"Position must be a 2D coordinate for body {identifier}")\n        if not (isinstance(velocity, list) or isinstance(velocity, tuple)) or len(velocity) != 2:\n            raise ValueError(f"Velocity must be a 2D vector for body {identifier}")\n\n        self.id = identifier\n        self.mass = mass\n        self.position = np.array(position, dtype=float)\n        self.velocity = np.array(velocity, dtype=float)\n        # For Verlet integration, we store previous position (initialize as current position)\n        self.previous_position = np.array(position, dtype=float)\n\n    def __str__(self):\n        return f"CelestialBody(id={self.id}, mass={self.mass}, position={self.position}, velocity={self.velocity})"\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x05T\x1b[\x93|\xaa\xf5\x16\x13\x00\x00\x16\x13\x00\x00\x0e\x00\x00\x00integrators.pyimport numpy as np\nfrom copy import deepcopy\nfrom celestial_body import CelestialBody\n\nclass BaseIntegrator:\n    def update(self, bodies, dt, G):\n        """\n        Update the state of all celestial bodies over time step dt.\n        This is an abstract method that should be implemented by concrete integrators.\n        """\n        raise NotImplementedError("update() must be implemented by subclasses")\n\nclass EulerIntegrator(BaseIntegrator):\n    def update(self, bodies, dt, G):\n        # Compute accelerations for each body\n        accelerations = {body.id: np.zeros(2) for body in bodies}\n        for i, body in enumerate(bodies):\n            for j, other in enumerate(bodies):\n                if i == j:\n                    continue\n                # Compute vector from body to other\n                r_vec = other.position - body.position\n                r = np.linalg.norm(r_vec)\n                if r > 0:\n                    accel = G * other.mass / (r ** 3) * r_vec\n                    accelerations[body.id] += accel\n\n        # Update velocities and positions using Euler method\n        for body in bodies:\n            body.velocity += accelerations[body.id] * dt\n            body.position += body.velocity * dt\n\nclass VerletIntegrator(BaseIntegrator):\n    def update(self, bodies, dt, G):\n        # For Verlet, we need to compute new positions using current acceleration\n        # and previous positions. We\'ll compute acceleration similar to Euler.\n        new_positions = {}\n        accelerations = {body.id: np.zeros(2) for body in bodies}\n\n        for i, body in enumerate(bodies):\n            for j, other in enumerate(bodies):\n                if i == j:\n                    continue\n                r_vec = other.position - body.position\n                r = np.linalg.norm(r_vec)\n                if r > 0:\n                    accel = G * other.mass / (r ** 3) * r_vec\n                    accelerations[body.id] += accel\n\n        for body in bodies:\n            # Verlet formula: x(t+dt) = 2*x(t) - x(t-dt) + a*dt^2\n            new_pos = 2 * body.position - body.previous_position + accelerations[body.id] * (dt ** 2)\n            # estimate new velocity\n            new_vel = (new_pos - body.previous_position) / (2 * dt)\n            body.previous_position = deepcopy(body.position)\n            body.position = new_pos\n            body.velocity = new_vel\n\nclass RK4Integrator(BaseIntegrator):\n    def update(self, bodies, dt, G):\n        # RK4 integration: for the sake of simplicity, we perform a simple RK4 step for each body.\n        # Note: In a coupled system like this, a full RK4 requires computing intermediate states for all bodies simultaneously.\n        # Here, we provide a simplified version for demonstration.\n        new_states = {}\n        for body in bodies:\n            k1_v = self._acceleration(body, bodies, G)\n            k1_x = body.velocity\n\n            # First intermediate step (not fully coupled):\n            temp_vel = body.velocity + 0.5 * k1_v * dt\n            temp_pos = body.position + 0.5 * k1_x * dt\n            k2_v = self._acceleration_temp(body, bodies, G, temp_pos)\n            k2_x = temp_vel\n\n            # Second intermediate step\n            temp_vel = body.velocity + 0.5 * k2_v * dt\n            temp_pos = body.position + 0.5 * k2_x * dt\n            k3_v = self._acceleration_temp(body, bodies, G, temp_pos)\n            k3_x = temp_vel\n\n            # Third intermediate step\n            temp_vel = body.velocity + k3_v * dt\n            temp_pos = body.position + k3_x * dt\n            k4_v = self._acceleration_temp(body, bodies, G, temp_pos)\n            k4_x = temp_vel\n\n            new_vel = body.velocity + (dt / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n            new_pos = body.position + (dt / 6.0) * (k1_x + 2*k2_x + 2*k3_x + k4_x)\n            new_states[body.id] = (new_pos, new_vel)\n\n        for body in bodies:\n            new_pos, new_vel = new_states[body.id]\n            body.position = new_pos\n            body.velocity = new_vel\n\n    def _acceleration(self, body, bodies, G):\n        accel = 0.0 * body.position\n        for other in bodies:\n            if other.id == body.id:\n                continue\n            r_vec = other.position - body.position\n            r = np.linalg.norm(r_vec)\n            if r > 0:\n                accel += G * other.mass / (r ** 3) * r_vec\n        return accel\n\n    def _acceleration_temp(self, current_body, bodies, G, temp_pos):\n        # helper for RK4 when using temporary positions\n        accel = 0.0 * temp_pos\n        for other in bodies:\n            if other.id == current_body.id:\n                continue\n            # Use the current positions for other bodies (could be improved)\n            r_vec = other.position - temp_pos\n            r = np.linalg.norm(r_vec)\n            if r > 0:\n                accel += G * other.mass / (r ** 3) * r_vec\n        return accel\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x05T\x1b[^\xcd\xf8&\xc4\x06\x00\x00\xc4\x06\x00\x00\x14\x00\x00\x00simulation_engine.pyimport time\nimport threading\nimport logging\n\nclass SimulationEngine:\n    def __init__(self, bodies, gravitational_constant, time_step, integrator):\n        self.bodies = bodies\n        self.G = gravitational_constant\n        self.dt = time_step\n        self.integrator = integrator\n        self.running = False\n        self.paused = False\n        self._lock = threading.Lock()\n\n    def start_simulation(self, update_callback=None):\n        """\n        Start the simulation loop in a separate thread.\n        If update_callback is provided, it will be called after each simulation step\n        with the current state of bodies.\n        """\n        self.running = True\n        simulation_thread = threading.Thread(target=self._run, args=(update_callback,))\n        simulation_thread.daemon = True\n        simulation_thread.start()\n\n    def _run(self, update_callback):\n        while self.running:\n            with self._lock:\n                if not self.paused:\n                    # Update simulation state using the integrator\n                    self.integrator.update(self.bodies, self.dt, self.G)\n                    if update_callback:\n                        update_callback(self.bodies)\n            time.sleep(self.dt)\n\n    def pause(self):\n        with self._lock:\n            self.paused = True\n            logging.info("Simulation paused.")\n\n    def resume(self):\n        with self._lock:\n            self.paused = False\n            logging.info("Simulation resumed.")\n\n    def set_time_step(self, time_step):\n        with self._lock:\n            self.dt = time_step\n            logging.info(f"Time step updated to {time_step}")\n\n    def stop(self):\n        self.running = False\n        logging.info("Simulation stopped.")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x05T\x1b[^\xc0\x84\x04\x1c\x05\x00\x00\x1c\x05\x00\x00\x05\x00\x00\x00ui.pyimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport numpy as np\nimport logging\n\nclass SimulationUI:\n    def __init__(self, simulation_engine):\n        self.engine = simulation_engine\n        self.fig, self.ax = plt.subplots()\n        self.scat = self.ax.scatter([], [])\n        self.ax.set_title(\'2D N-Body Simulation\')\n        self.ax.set_xlabel(\'X Position\')\n        self.ax.set_ylabel(\'Y Position\')\n\n    def init_plot(self):\n        self.scat.set_offsets([])\n        return self.scat,\n\n    def update_display(self, bodies):\n        positions = [body.position for body in bodies]\n        # Set plot limits based on positions or define static limits\n        positions_array = []\n        for pos in positions:\n            positions_array.append([pos[0], pos[1]])\n        self.scat.set_offsets(positions_array)\n        return self.scat,\n\n    def run(self):\n        # Use matplotlib animation to update the plot in realtime\n        ani = animation.FuncAnimation(self.fig,\n                                      self.update_display, \n                                      fargs=(self.engine.bodies,),\n                                      init_func=self.init_plot,\n                                      interval=50,\n                                      blit=True)\n        plt.show()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x05T\x1b[C\xe5\xe6\x8fJ\x01\x00\x00J\x01\x00\x00\t\x00\x00\x00logger.pyimport logging\n\n# Configure the logging format and level\nlogging.basicConfig(level=logging.INFO,\n                    format=\'%(asctime)s - %(levelname)s - %(message)s\')\n\n\ndef log_info(message):\n    logging.info(message)\n\n\ndef log_warning(message):\n    logging.warning(message)\n\n\ndef log_error(message):\n    logging.error(message)\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x05T\x1b[\xa0\x9a3\xb09\x08\x00\x009\x08\x00\x00\x07\x00\x00\x00main.pyimport sys\nimport argparse\nimport logging\nfrom config_manager import ConfigManager\nfrom celestial_body import CelestialBody\nfrom integrators import EulerIntegrator, VerletIntegrator, RK4Integrator\nfrom simulation_engine import SimulationEngine\nfrom ui import SimulationUI\nimport threading\n\n\ndef parse_arguments():\n    parser = argparse.ArgumentParser(description=\'2D N-Body Simulation\')\n    parser.add_argument(\'--config\', type=str, default=\'config.json\', help=\'Path to the configuration JSON file\')\n    return parser.parse_args()\n\n\ndef create_bodies(bodies_config):\n    bodies = []\n    for body_conf in bodies_config:\n        body = CelestialBody(\n            identifier=body_conf[\'id\'],\n            mass=body_conf[\'mass\'],\n            position=body_conf[\'position\'],\n            velocity=body_conf[\'velocity\']\n        )\n        bodies.append(body)\n    return bodies\n\n\ndef select_integrator(integrator_name):\n    if integrator_name.lower() == \'euler\':\n        return EulerIntegrator()\n    elif integrator_name.lower() == \'verlet\':\n        return VerletIntegrator()\n    elif integrator_name.lower() == \'rk4\':\n        return RK4Integrator()\n    else:\n        raise ValueError(f"Unknown integrator: {integrator_name}")\n\n\ndef main():\n    args = parse_arguments()\n    try:\n        config = ConfigManager.load_configuration(args.config)\n    except Exception as e:\n        logging.error(f"Failed to load configuration: {str(e)}")\n        sys.exit(1)\n\n    global_params = config[\'global_parameters\']\n    G = global_params[\'gravitational_constant\']\n    dt = global_params[\'time_step\']\n    integrator_name = global_params[\'integrator\']\n\n    bodies = create_bodies(config[\'bodies\'])\n\n    integrator = select_integrator(integrator_name)\n    engine = SimulationEngine(bodies, G, dt, integrator)\n\n    # Start the simulation in a separate thread\n    engine.start_simulation()\n\n    # Start the UI (this will block until the plot window is closed)\n    ui = SimulationUI(engine)\n    try:\n        ui.run()\n    except KeyboardInterrupt:\n        pass\n    finally:\n        engine.stop()\n\nif __name__ == \'__main__\':\n    main()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x05T\x1b[\xef|3D\x19\x07\x00\x00\x19\x07\x00\x00\x18\x00\x00\x00tests/test_simulation.pyimport numpy as np\nimport pytest\nfrom celestial_body import CelestialBody\nfrom integrators import EulerIntegrator, VerletIntegrator, RK4Integrator\n\n# Test CelestialBody validation\n\ndef test_celestial_body_positive_mass():\n    with pytest.raises(ValueError):\n        CelestialBody(\'body1\', 0, [0, 0], [0, 0])\n    with pytest.raises(ValueError):\n        CelestialBody(\'body2\', -5, [0, 0], [0, 0])\n\n\ndef test_celestial_body_position_length():\n    with pytest.raises(ValueError):\n        CelestialBody(\'body3\', 5, [0], [0, 0])\n    with pytest.raises(ValueError):\n        CelestialBody(\'body4\', 5, [0, 0, 0], [0, 0])\n\n\ndef test_euler_integrator_updates():\n    # Create two bodies and test that positions/velocities are updated\n    body1 = CelestialBody(\'1\', 10, [0, 0], [0, 0])\n    body2 = CelestialBody(\'2\', 20, [1, 0], [0, 0])\n    bodies = [body1, body2]\n    integrator = EulerIntegrator()\n    dt = 0.1\n    G = 1.0\n    pos1_old = body1.position.copy()\n    integrator.update(bodies, dt, G)\n    # Check that at least one of the positions has changed\n    assert not np.array_equal(pos1_old, body1.position)\n\n\ndef test_verlet_integrator_updates():\n    body1 = CelestialBody(\'1\', 10, [0, 0], [0, 0])\n    body2 = CelestialBody(\'2\', 20, [1, 0], [0, 0])\n    bodies = [body1, body2]\n    integrator = VerletIntegrator()\n    dt = 0.1\n    G = 1.0\n    pos1_old = body1.position.copy()\n    integrator.update(bodies, dt, G)\n    assert not np.array_equal(pos1_old, body1.position)\n\n\ndef test_rk4_integrator_updates():\n    body1 = CelestialBody(\'1\', 10, [0, 0], [0, 0])\n    body2 = CelestialBody(\'2\', 20, [1, 0], [0, 0])\n    bodies = [body1, body2]\n    integrator = RK4Integrator()\n    dt = 0.1\n    G = 1.0\n    pos1_old = body1.position.copy()\n    integrator.update(bodies, dt, G)\n    assert not np.array_equal(pos1_old, body1.position)\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x05T\x1b[\x0c\x15\xf6\x1b#\x00\x00\x00#\x00\x00\x00\x10\x00\x00\x00requirements.txtnumpy\nmatplotlib\njsonschema\npytest\nPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x05T\x1b[M\xb5\t\x17\x95\n\x00\x00\x95\n\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00config_manager.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x05T\x1b[|\xd7\xa0\x12\x0c\x04\x00\x00\x0c\x04\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xc4\n\x00\x00celestial_body.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x05T\x1b[\x93|\xaa\xf5\x16\x13\x00\x00\x16\x13\x00\x00\x0e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xff\x0e\x00\x00integrators.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x05T\x1b[^\xcd\xf8&\xc4\x06\x00\x00\xc4\x06\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01A"\x00\x00simulation_engine.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x05T\x1b[^\xc0\x84\x04\x1c\x05\x00\x00\x1c\x05\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x017)\x00\x00ui.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x05T\x1b[C\xe5\xe6\x8fJ\x01\x00\x00J\x01\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01v.\x00\x00logger.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x05T\x1b[\xa0\x9a3\xb09\x08\x00\x009\x08\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xe7/\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x05T\x1b[\xef|3D\x19\x07\x00\x00\x19\x07\x00\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01E8\x00\x00tests/test_simulation.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x05T\x1b[\x0c\x15\xf6\x1b#\x00\x00\x00#\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x94?\x00\x00requirements.txtPK\x05\x06\x00\x00\x00\x00\t\x00\t\x00\x1f\x02\x00\x00\xe5?\x00\x00\x00\x00'