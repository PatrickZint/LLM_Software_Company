b'PK\x03\x04\x14\x00\x00\x00\x00\x00\x93b\x1b[\x81$z\x90b\x05\x00\x00b\x05\x00\x00\x11\x00\x00\x00config_manager.pyimport json\nimport os\n\nclass ConfigManager:\n    DEFAULT_CONFIG = {\n        "gravitational_constant": 6.67430e-11,\n        "time_step": 0.1,\n        "integration_method": "Euler",  # Options: Euler, Verlet, RungeKutta\n        "initial_bodies": [\n            {"mass": 1e5, "position": [300, 300], "velocity": [0, 0]},\n            {"mass": 1e5, "position": [500, 300], "velocity": [0, 0]}\n        ],\n        "logging": {\n            "level": "DEBUG",\n            "console": true,\n            "file": "simulation.log"\n        },\n        "display": {\n            "width": 800,\n            "height": 600,\n            "fps": 60\n        }\n    }\n\n    def __init__(self, config_file=\'config.json\'):\n        self.config_file = config_file\n        self.config = self.load_config()\n\n    def load_config(self):\n        if os.path.exists(self.config_file):\n            try:\n                with open(self.config_file, \'r\') as f:\n                    config = json.load(f)\n                # Validate mandatory fields here if needed\n                return config\n            except Exception as e:\n                print(f"Error reading config: {e}. Falling back to default configuration.")\n        else:\n            print("Config file not found. Using default configuration.")\n        return self.DEFAULT_CONFIG\n\n    def get(self, key, default=None):\n        return self.config.get(key, default)\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x93b\x1b[\xaf\xa2`\x11\x12\x03\x00\x00\x12\x03\x00\x00\x10\x00\x00\x00logger_config.pyimport logging\nimport sys\n\ndef setup_logger(config):\n    log_config = config.get(\'logging\', {})\n    log_level = getattr(logging, log_config.get(\'level\', \'DEBUG\').upper(), logging.DEBUG)\n    logger = logging.getLogger(\'nbody_simulation\')\n    logger.setLevel(log_level)\n    formatter = logging.Formatter(\'%(asctime)s - %(levelname)s - %(message)s\')\n\n    # Console handler\n    if log_config.get(\'console\', True):\n        ch = logging.StreamHandler(sys.stdout)\n        ch.setLevel(log_level)\n        ch.setFormatter(formatter)\n        logger.addHandler(ch)\n\n    # File handler\n    log_file = log_config.get(\'file\')\n    if log_file:\n        fh = logging.FileHandler(log_file)\n        fh.setLevel(log_level)\n        fh.setFormatter(formatter)\n        logger.addHandler(fh)\n\n    return logger\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x93b\x1b[%\x00\x03\xae\xd7\x02\x00\x00\xd7\x02\x00\x00\x07\x00\x00\x00body.pyimport pygame\n\nclass Body:\n    def __init__(self, mass, position, velocity, radius=5, color=(255, 255, 255)):\n        self.mass = mass\n        self.position = pygame.math.Vector2(position)\n        self.velocity = pygame.math.Vector2(velocity)\n        self.force = pygame.math.Vector2(0, 0)\n        self.radius = radius\n        self.color = color\n\n    def update_position(self, dt):\n        self.position += self.velocity * dt\n\n    def update_velocity(self, dt):\n        # acceleration = force / mass\n        acceleration = self.force / self.mass\n        self.velocity += acceleration * dt\n\n    def reset_force(self):\n        self.force = pygame.math.Vector2(0, 0)\n\n    def apply_force(self, force):\n        self.force += force\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x93b\x1b[\xee\']1M\x07\x00\x00M\x07\x00\x00\x0e\x00\x00\x00integrators.pyfrom body import Body\n\nclass EulerIntegrator:\n    @staticmethod\n    def update(bodies, dt, physics_engine):\n        # Compute forces before updating\n        physics_engine.compute_forces(bodies)\n        for body in bodies:\n            # Update velocity and then position\n            body.update_velocity(dt)\n            body.update_position(dt)\n            body.reset_force()\n\nclass VerletIntegrator:\n    @staticmethod\n    def update(bodies, dt, physics_engine):\n        # For Verlet, we need to update position using current velocity and acceleration\n        physics_engine.compute_forces(bodies)\n        for body in bodies:\n            acceleration = body.force / body.mass\n            # Store previous position for potential enhancements (not used here)\n            body.position += body.velocity * dt + 0.5 * acceleration * dt * dt\n            # Simple Euler for velocity update (a full Verlet would require previous acceleration)\n            body.update_velocity(dt)\n            body.reset_force()\n\nclass RungeKuttaIntegrator:\n    @staticmethod\n    def update(bodies, dt, physics_engine):\n        # A simplified RK4 integrator implementation\n        # In a real implementation, we would compute several intermediate values\n        physics_engine.compute_forces(bodies)\n        for body in bodies:\n            # Update velocity and position with RK4-like approach (simplified)\n            body.update_velocity(dt)\n            body.update_position(dt)\n            body.reset_force()\n\n# A factory method to get the integrator\n\ndef get_integrator(method_name):\n    if method_name.lower() == \'euler\':\n        return EulerIntegrator\n    elif method_name.lower() == \'verlet\':\n        return VerletIntegrator\n    elif method_name.lower() == \'rungekutta\':\n        return RungeKuttaIntegrator\n    else:\n        raise ValueError(f"Unknown integration method: {method_name}")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x93b\x1b[od\xc1w\x00\x05\x00\x00\x00\x05\x00\x00\x11\x00\x00\x00physics_engine.pyimport math\nimport pygame\nfrom integrators import get_integrator\n\nclass PhysicsEngine:\n    def __init__(self, gravitational_constant, integration_method):\n        self.G = gravitational_constant\n        self.integrator = get_integrator(integration_method)\n\n    def compute_forces(self, bodies):\n        # Reset forces\n        for body in bodies:\n            body.reset_force()\n        # Compute pairwise gravitational forces\n        n = len(bodies)\n        for i in range(n):\n            for j in range(i+1, n):\n                body1 = bodies[i]\n                body2 = bodies[j]\n                # Vector from body1 to body2\n                diff = body2.position - body1.position\n                distance_sq = diff.length_squared()\n                # Avoid division by zero / too small distances\n                if distance_sq < 1e-4:\n                    distance_sq = 1e-4\n                force_magnitude = self.G * body1.mass * body2.mass / distance_sq\n                force_direction = diff.normalize()\n                force = force_direction * force_magnitude\n                # Apply equal and opposite forces\n                body1.apply_force(force)\n                body2.apply_force(-force)\n\n    def update(self, bodies, dt):\n        self.integrator.update(bodies, dt, self)\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x93b\x1b[\xe1\xeb;\x91\x98\x07\x00\x00\x98\x07\x00\x00\x15\x00\x00\x00simulation_manager.pyimport pygame\nfrom body import Body\nfrom physics_engine import PhysicsEngine\n\nclass SimulationManager:\n    def __init__(self, config, logger):\n        self.logger = logger\n        self.dt = config.get(\'time_step\', 0.1)\n        self.bodies = []\n        self.running = True\n        self.paused = False\n        self.elapsed_time = 0.0\n\n        # Initialize physics engine\n        G = config.get(\'gravitational_constant\', 6.67430e-11)\n        integration_method = config.get(\'integration_method\', \'Euler\')\n        self.physics_engine = PhysicsEngine(G, integration_method)\n\n        # Initialize bodies from config\n        for body_conf in config.get(\'initial_bodies\', []):\n            body = Body(\n                mass=body_conf.get(\'mass\'),\n                position=body_conf.get(\'position\'),\n                velocity=body_conf.get(\'velocity\')\n            )\n            self.bodies.append(body)\n        self.logger.debug(f"Initialized {len(self.bodies)} bodies.")\n\n    def toggle_pause(self):\n        self.paused = not self.paused\n        self.logger.info(f"Simulation paused: {self.paused}")\n\n    def reset(self, config):\n        # Reinitialize bodies from config\n        self.bodies = []\n        for body_conf in config.get(\'initial_bodies\', []):\n            body = Body(\n                mass=body_conf.get(\'mass\'),\n                position=body_conf.get(\'position\'),\n                velocity=body_conf.get(\'velocity\')\n            )\n            self.bodies.append(body)\n        self.elapsed_time = 0.0\n        self.logger.info("Simulation reset to initial conditions.")\n\n    def update(self):\n        if not self.paused:\n            self.physics_engine.update(self.bodies, self.dt)\n            self.elapsed_time += self.dt\n            # Log current state\n            for i, body in enumerate(self.bodies):\n                self.logger.debug(f"Time: {self.elapsed_time:.2f} Body {i}: Pos={body.position}, Vel={body.velocity}, Force={body.force}")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x93b\x1b[}\x12\xe8\x80\x08\x05\x00\x00\x08\x05\x00\x00\x12\x00\x00\x00display_manager.pyimport pygame\n\nclass DisplayManager:\n    def __init__(self, config, logger):\n        pygame.init()\n        display_conf = config.get(\'display\', {})\n        self.width = display_conf.get(\'width\', 800)\n        self.height = display_conf.get(\'height\', 600)\n        self.fps = display_conf.get(\'fps\', 60)\n        self.screen = pygame.display.set_mode((self.width, self.height))\n        pygame.display.set_caption(\'2D Newtonian N-body Simulation\')\n        self.clock = pygame.time.Clock()\n        self.logger = logger\n        self.font = pygame.font.SysFont(\'Arial\', 16)\n\n    def render(self, bodies, extra_info=None):\n        self.screen.fill((0, 0, 0))\n        # Draw bodies\n        for body in bodies:\n            pos = (int(body.position.x), int(body.position.y))\n            pygame.draw.circle(self.screen, body.color, pos, body.radius)\n        \n        # Render extra_info overlay if provided\n        if extra_info:\n            y = 10\n            for text in extra_info:\n                text_surface = self.font.render(text, True, (255, 255, 255))\n                self.screen.blit(text_surface, (10, y))\n                y += 20\n        pygame.display.flip()\n        self.clock.tick(self.fps)\n\n    def get_clock(self):\n        return self.clock\n\n    def quit(self):\n        pygame.quit()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x93b\x1b[\x01)\xe8\xac\xf4\x02\x00\x00\xf4\x02\x00\x00\x10\x00\x00\x00input_handler.pyimport pygame\n\nclass InputHandler:\n    def __init__(self, simulation_manager, logger):\n        self.simulation_manager = simulation_manager\n        self.logger = logger\n\n    def process_events(self):\n        # Process events and interact with simulation manager\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                return \'QUIT\'\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_SPACE:\n                    self.simulation_manager.toggle_pause()\n                elif event.key == pygame.K_r:\n                    self.simulation_manager.reset(self.simulation_manager.config)\n                # Additional key events such as adjusting dt can be added here\n        return None\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x93b\x1b[\xed\xe7\xb3p\x9d\x05\x00\x00\x9d\x05\x00\x00\x07\x00\x00\x00main.pyimport sys\nimport pygame\nfrom config_manager import ConfigManager\nfrom logger_config import setup_logger\nfrom simulation_manager import SimulationManager\nfrom display_manager import DisplayManager\nfrom input_handler import InputHandler\n\n\ndef main():\n    # Load configuration\n    config_manager = ConfigManager()\n    config = config_manager.config\n\n    # Setup logging\n    logger = setup_logger(config)\n    logger.info("Starting 2D Newtonian N-body Simulation")\n\n    # Initialize simulation manager\n    sim_manager = SimulationManager(config, logger)\n    # Pass config into simulation_manager as an attribute for resetting purposes\n    sim_manager.config = config\n\n    # Initialize display manager\n    display = DisplayManager(config, logger)\n\n    # Initialize input handler\n    input_handler = InputHandler(sim_manager, logger)\n\n    # Main loop\n    running = True\n    while running:\n        # Input handling\n        command = input_handler.process_events()\n        if command == \'QUIT\':\n            running = False\n            continue\n\n        # Update simulation\n        sim_manager.update()\n\n        # Render simulation state\n        extra_info = [f"Time: {sim_manager.elapsed_time:.2f}", \n                      f"Bodies: {len(sim_manager.bodies)}", \n                      f"Paused: {sim_manager.paused}"]\n        display.render(sim_manager.bodies, extra_info)\n\n    pygame.quit()\n    sys.exit()\n\nif __name__ == "__main__":\n    main()\nPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x93b\x1b[\x81$z\x90b\x05\x00\x00b\x05\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00config_manager.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x93b\x1b[\xaf\xa2`\x11\x12\x03\x00\x00\x12\x03\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x91\x05\x00\x00logger_config.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x93b\x1b[%\x00\x03\xae\xd7\x02\x00\x00\xd7\x02\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xd1\x08\x00\x00body.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x93b\x1b[\xee\']1M\x07\x00\x00M\x07\x00\x00\x0e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xcd\x0b\x00\x00integrators.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x93b\x1b[od\xc1w\x00\x05\x00\x00\x00\x05\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01F\x13\x00\x00physics_engine.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x93b\x1b[\xe1\xeb;\x91\x98\x07\x00\x00\x98\x07\x00\x00\x15\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01u\x18\x00\x00simulation_manager.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x93b\x1b[}\x12\xe8\x80\x08\x05\x00\x00\x08\x05\x00\x00\x12\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01@ \x00\x00display_manager.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x93b\x1b[\x01)\xe8\xac\xf4\x02\x00\x00\xf4\x02\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01x%\x00\x00input_handler.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x93b\x1b[\xed\xe7\xb3p\x9d\x05\x00\x00\x9d\x05\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x9a(\x00\x00main.pyPK\x05\x06\x00\x00\x00\x00\t\x00\t\x00#\x02\x00\x00\\.\x00\x00\x00\x00'