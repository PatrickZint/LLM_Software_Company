b'PK\x03\x04\x14\x00\x00\x00\x00\x00K`\x1b[[\x01#\x0f\x05\x0e\x00\x00\x05\x0e\x00\x00\x07\x00\x00\x00main.pyimport sys\nimport time\nimport argparse\nimport numpy as np\n\nfrom config import parse_args, load_config, validate_parameters\nfrom physics import CelestialBody, update_positions\nfrom data_logger import DataLogger\nfrom visualization import Visualizer\n\n\ndef initialize_bodies(config):\n    # For simplicity, assume config contains a list of bodies\n    bodies = []\n    for body_conf in config.get(\'bodies\', []):\n        body = CelestialBody(\n            mass=body_conf[\'mass\'],\n            position=np.array(body_conf[\'position\'], dtype=float),\n            velocity=np.array(body_conf[\'velocity\'], dtype=float)\n        )\n        bodies.append(body)\n    return bodies\n\n\ndef main():\n    # Parse command-line arguments\n    args = parse_args()\n\n    # Load configuration from file if provided\n    if args.config:\n        config = load_config(args.config)\n    else:\n        # Use command-line parameters to build a basic configuration\n        config = {\n            "dt": args.dt,\n            "simulation_time": args.simulation_time,\n            "G": args.G,\n            "integration_method": args.integration_method,\n            "logging_frequency": args.logging_frequency,\n            "visualization": args.visualization,\n            "bodies": [\n                {\n                    "mass": 5.972e24,\n                    "position": [0, 0],\n                    "velocity": [0, 0]\n                },\n                {\n                    "mass": 7.348e22,\n                    "position": [384400000, 0],\n                    "velocity": [0, 1022]\n                }\n            ]\n        }\n\n    # Validate configuration parameters\n    try:\n        validate_parameters(config)\n    except ValueError as ve:\n        sys.exit(f"Configuration error: {ve}")\n\n    dt = config.get(\'dt\', 1)\n    simulation_time = config.get(\'simulation_time\', 1000)\n    G = config.get(\'G\', 6.67430e-11)\n    logging_frequency = config.get(\'logging_frequency\', 1)\n    enable_viz = config.get(\'visualization\', False)\n    integration_method = config.get(\'integration_method\', \'euler\')\n\n    # Initialize simulation components\n    bodies = initialize_bodies(config)\n    logger = DataLogger(logging_frequency=logging_frequency, output_file=\'simulation_log.csv\')\n    visualizer = None\n    if enable_viz:\n        visualizer = Visualizer()\n        visualizer.init_visualization(bodies)\n\n    current_time = 0.0\n    step = 0\n\n    print(\'Starting simulation...\')\n    try:\n        while current_time < simulation_time:\n            # Update physics (Euler\'s method by default)\n            update_positions(bodies, dt, G, method=integration_method)\n\n            # Log state every logging_frequency steps\n            if step % logging_frequency == 0:\n                state = []\n                for body in bodies:\n                    state.append({\n                        \'mass\': body.mass,\n                        \'position\': body.position.tolist(),\n                        \'velocity\': body.velocity.tolist()\n                    })\n                logger.log_simulation_state(current_time, state)\n\n            # Update visualization if enabled\n            if enable_viz and visualizer is not None:\n                visualizer.update_plot(bodies)\n\n            current_time += dt\n            step += 1\n            time.sleep(0.01)  # small sleep to simulate real-time progression\n\n    except KeyboardInterrupt:\n        print(\'\\nSimulation interrupted by user.\')\n    finally:\n        if enable_viz and visualizer is not None:\n            visualizer.render_final_plot()\n        print(\'Simulation finished.\')\n\n\nif __name__ == \'__main__\':\n    main()\nPK\x03\x04\x14\x00\x00\x00\x00\x00K`\x1b[\x83\xc5\x0fc\xaf\x08\x00\x00\xaf\x08\x00\x00\n\x00\x00\x00physics.pyimport numpy as np\n\n# Minimum distance to avoid singularity\nMIN_DISTANCE = 1e-2\n\nclass CelestialBody:\n    def __init__(self, mass, position, velocity):\n        self.mass = mass\n        self.position = position  # Expected to be a numpy array with 2 elements\n        self.velocity = velocity  # Expected to be a numpy array with 2 elements\n\n    def __repr__(self):\n        return f"CelestialBody(mass={self.mass}, pos={self.position}, vel={self.velocity})"\n\n\ndef calculate_gravitational_force(body1, body2, G):\n    # Vector from body1 to body2\n    r_vec = body2.position - body1.position\n    r_mag = np.linalg.norm(r_vec)\n    # Safeguard against division by zero\n    if r_mag < MIN_DISTANCE:\n        r_mag = MIN_DISTANCE\n    # Unit vector in the direction of the force\n    r_hat = r_vec / r_mag\n    # Newton\'s law of gravitation\n    force_mag = G * body1.mass * body2.mass / (r_mag ** 2)\n    force = force_mag * r_hat\n    return force\n\n\ndef update_positions(bodies, dt, G, method=\'euler\'):\n    # For now, only Euler integration is implemented\n    if method.lower() != \'euler\':\n        raise NotImplementedError(f"Integration method \'{method}\' is not implemented yet.")\n\n    # Compute forces for each pair (assuming two-body simulation for simplicity).\n    # For a general n-body simulation, one would compute net forces\n    n = len(bodies)\n    forces = [np.zeros(2) for _ in range(n)]\n\n    # Calculate mutual gravitational forces\n    for i in range(n):\n        for j in range(i + 1, n):\n            force = calculate_gravitational_force(bodies[i], bodies[j], G)\n            forces[i] += force\n            forces[j] -= force  # Newton\'s third law\n\n    # Update velocities and positions using Euler\'s method\n    for i, body in enumerate(bodies):\n        # a = F/m\n        acceleration = forces[i] / body.mass\n        # Update velocity\n        body.velocity += acceleration * dt\n        # Update position\n        body.position += body.velocity * dt\n\n\ndef set_integration_method(method):\n    # Future extension: change the integration method used\n    # For now, only Euler is supported\n    if method.lower() != \'euler\':\n        raise NotImplementedError(f"Integration method \'{method}\' is not available yet.")\n    return method\nPK\x03\x04\x14\x00\x00\x00\x00\x00K`\x1b[\xb7\x95\xc0\xa6\x8e\x08\x00\x00\x8e\x08\x00\x00\t\x00\x00\x00config.pyimport argparse\nimport json\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser(description=\'2D Orbital Simulator\')\n    parser.add_argument(\'--config\', type=str, help=\'Path to configuration file (JSON)\')\n    parser.add_argument(\'--dt\', type=float, default=1.0, help=\'Time step for simulation\')\n    parser.add_argument(\'--simulation_time\', type=float, default=1000, help=\'Total simulation time\')\n    parser.add_argument(\'--G\', type=float, default=6.67430e-11, help=\'Gravitational constant\')\n    parser.add_argument(\'--integration_method\', type=str, default=\'euler\', help=\'Integration method to use\')\n    parser.add_argument(\'--logging_frequency\', type=int, default=1, help=\'Frequency (in steps) for logging data\')\n    parser.add_argument(\'--visualization\', action=\'store_true\', help=\'Enable visualization\')\n    return parser.parse_args()\n\n\ndef load_config(filepath):\n    with open(filepath, \'r\') as f:\n        try:\n            config = json.load(f)\n        except json.JSONDecodeError as e:\n            raise ValueError(f"Invalid JSON configuration: {e}")\n    return config\n\n\ndef validate_parameters(params):\n    # Check that time step and simulation time are positive\n    dt = params.get(\'dt\', 1)\n    simulation_time = params.get(\'simulation_time\', 1000)\n    if dt <= 0 or simulation_time <= 0:\n        raise ValueError(\'Time step and simulation time must be positive.\')\n\n    # Validate gravitational constant\n    G = params.get(\'G\', 6.67430e-11)\n    if G <= 0:\n        raise ValueError(\'Gravitational constant must be positive.\')\n\n    # Validate bodies\n    bodies = params.get(\'bodies\', [])\n    if len(bodies) < 2:\n        raise ValueError(\'At least two bodies are required for the simulation.\')\n\n    positions = []\n    for body in bodies:\n        pos = body.get(\'position\', None)\n        if pos is None or len(pos) != 2:\n            raise ValueError(\'Each body must have a valid 2D position.\')\n        positions.append(tuple(pos))\n\n    # Check for overlapping positions (simple check)\n    if len(positions) != len(set(positions)):\n        raise ValueError(\'Two or more bodies have overlapping initial positions.\')\n\n    # Additional validations can be added as needed\n    return True\nPK\x03\x04\x14\x00\x00\x00\x00\x00K`\x1b[\xec\x9e1_\x80\x06\x00\x00\x80\x06\x00\x00\x0e\x00\x00\x00data_logger.pyimport csv\nimport logging\n\n\nclass DataLogger:\n    def __init__(self, logging_frequency=1, output_file=\'simulation_log.csv\'):\n        self.logging_frequency = logging_frequency\n        self.output_file = output_file\n        self.setup_logger()\n        # Open CSV file for writing\n        self.csv_file = open(self.output_file, \'w\', newline=\'\')\n        self.csv_writer = csv.writer(self.csv_file)\n        # Write header row\n        self.csv_writer.writerow([\'time\', \'body_index\', \'mass\', \'position_x\', \'position_y\', \'velocity_x\', \'velocity_y\'])\n\n    def setup_logger(self):\n        self.logger = logging.getLogger(\'OrbitalSimulator\')\n        self.logger.setLevel(logging.DEBUG)\n        ch = logging.StreamHandler()\n        ch.setLevel(logging.DEBUG)\n        formatter = logging.Formatter(\'%(asctime)s - %(levelname)s - %(message)s\')\n        ch.setFormatter(formatter)\n        self.logger.addHandler(ch)\n\n    def log_simulation_state(self, timestamp, state):\n        # Log to console\n        self.logger.info(f"Time: {timestamp:.2f} seconds")\n        for idx, body in enumerate(state):\n            pos = body[\'position\']\n            vel = body[\'velocity\']\n            self.logger.info(f"Body {idx}: Mass={body[\'mass\']}, Position=({pos[0]:.2f}, {pos[1]:.2f}), Velocity=({vel[0]:.2f}, {vel[1]:.2f})")\n            # Write to CSV\n            self.csv_writer.writerow([\n                timestamp,\n                idx,\n                body[\'mass\'],\n                pos[0],\n                pos[1],\n                vel[0],\n                vel[1]\n            ])\n\n    def __del__(self):\n        try:\n            self.csv_file.close()\n        except Exception:\n            pass\nPK\x03\x04\x14\x00\x00\x00\x00\x00K`\x1b[\x94\xfcf\xf2;\x05\x00\x00;\x05\x00\x00\x10\x00\x00\x00visualization.pyimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\n\n\nclass Visualizer:\n    def __init__(self):\n        self.fig, self.ax = plt.subplots()\n        self.scat = None\n        self.bodies_positions = []\n        self.ani = None\n        self.initialized = False\n\n    def init_visualization(self, bodies):\n        # Extract initial positions\n        self.bodies_positions = [body.position for body in bodies]\n        x = [pos[0] for pos in self.bodies_positions]\n        y = [pos[1] for pos in self.bodies_positions]\n\n        self.scat = self.ax.scatter(x, y, c=\'blue\')\n        self.ax.set_title(\'2D Orbital Simulator\')\n        self.ax.set_xlabel(\'X Position\')\n        self.ax.set_ylabel(\'Y Position\')\n        self.initialized = True\n        plt.ion()\n        plt.show()\n\n    def update_plot(self, bodies):\n        if not self.initialized:\n            return\n        # Update positions\n        self.bodies_positions = [body.position for body in bodies]\n        x = [pos[0] for pos in self.bodies_positions]\n        y = [pos[1] for pos in self.bodies_positions]\n        self.scat.set_offsets(list(zip(x, y)))\n        self.ax.relim()\n        self.ax.autoscale_view()\n        plt.pause(0.001)\n\n    def render_final_plot(self):\n        # Turn off interactive mode and display the final plot\n        plt.ioff()\n        plt.show()\nPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00K`\x1b[[\x01#\x0f\x05\x0e\x00\x00\x05\x0e\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00K`\x1b[\x83\xc5\x0fc\xaf\x08\x00\x00\xaf\x08\x00\x00\n\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01*\x0e\x00\x00physics.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00K`\x1b[\xb7\x95\xc0\xa6\x8e\x08\x00\x00\x8e\x08\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x01\x17\x00\x00config.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00K`\x1b[\xec\x9e1_\x80\x06\x00\x00\x80\x06\x00\x00\x0e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xb6\x1f\x00\x00data_logger.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00K`\x1b[\x94\xfcf\xf2;\x05\x00\x00;\x05\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01b&\x00\x00visualization.pyPK\x05\x06\x00\x00\x00\x00\x05\x00\x05\x00\x1e\x01\x00\x00\xcb+\x00\x00\x00\x00'