b'PK\x03\x04\x14\x00\x00\x00\x00\x00\xf4R\x1b[ha \xa8\x90\x0f\x00\x00\x90\x0f\x00\x00\x14\x00\x00\x00simulation_engine.pyimport numpy as np\nimport warnings\n\n# Gravitational constant\nG_DEFAULT = 6.67430e-11\n\nclass PhysicsCalculator:\n    @staticmethod\n    def compute_gravitational_force(pos1, pos2, m1, m2, G=G_DEFAULT):\n        # Compute vector from pos1 to pos2\n        r_vector = pos2 - pos1\n        distance = np.linalg.norm(r_vector) + 1e-12  # add small value to avoid div by zero\n        force_magnitude = G * m1 * m2 / (distance ** 2)\n        force_vector = force_magnitude * (r_vector / distance)\n        return force_vector\n\nclass EulerIntegrator:\n    def integrate(self, pos, vel, acc, dt):\n        # Update velocity and position using simple Euler integration\n        new_vel = vel + acc * dt\n        new_pos = pos + new_vel * dt\n        return new_pos, new_vel\n\nclass SimulationEngine:\n    def __init__(self, body1, body2, dt, duration, integrator=None, G=G_DEFAULT, instability_threshold=1e12):\n        """\n        body1 and body2 are dictionaries with keys: \'pos\' (numpy array of shape (2,)),\n        \'vel\' (numpy array of shape (2,)) and \'mass\' (float).\n        dt: time step size\n        duration: total simulation time\n        integrator: an integrator object with an integrate method (default: EulerIntegrator)\n        G: gravitational constant\n        instability_threshold: threshold for warning on diverging simulation values\n        """\n        self.body1 = body1\n        self.body2 = body2\n        self.dt = dt\n        self.duration = duration\n        self.integrator = integrator if integrator is not None else EulerIntegrator()\n        self.G = G\n        self.instability_threshold = instability_threshold\n        self.calculator = PhysicsCalculator()\n        self.time_steps = int(duration / dt)\n\n    def run(self):\n        """\n        Runs the simulation and returns a list of state dictionaries for each time step.\n        Each state dictionary contains time, positions, velocities and the force computed.\n        """\n        simulation_data = []\n        pos1 = np.array(self.body1[\'pos\'], dtype=float)\n        pos2 = np.array(self.body2[\'pos\'], dtype=float)\n        vel1 = np.array(self.body1[\'vel\'], dtype=float)\n        vel2 = np.array(self.body2[\'vel\'], dtype=float)\n        m1 = self.body1[\'mass\']\n        m2 = self.body2[\'mass\']\n\n        for step in range(self.time_steps):\n            t = step * self.dt\n            # Calculate force on body1 due to body2\n            force_on_1 = self.calculator.compute_gravitational_force(pos1, pos2, m1, m2, self.G)\n            # Newton\'s Third Law: force on body2 is -force_on_1\n            force_on_2 = -force_on_1\n\n            # Compute accelerations\n            acc1 = force_on_1 / m1\n            acc2 = force_on_2 / m2\n\n            # Update state using Euler integrator\n            new_pos1, new_vel1 = self.integrator.integrate(pos1, vel1, acc1, self.dt)\n            new_pos2, new_vel2 = self.integrator.integrate(pos2, vel2, acc2, self.dt)\n\n            # Collect state data\n            state = {\n                \'time\': t,\n                \'body1\': {\n                    \'pos\': pos1.tolist(),\n                    \'vel\': vel1.tolist(),\n                    \'acc\': acc1.tolist(),\n                    \'force\': force_on_1.tolist()\n                },\n                \'body2\': {\n                    \'pos\': pos2.tolist(),\n                    \'vel\': vel2.tolist(),\n                    \'acc\': acc2.tolist(),\n                    \'force\': force_on_2.tolist()\n                }\n            }\n            simulation_data.append(state)\n\n            # Update positions and velocities for next iteration\n            pos1, vel1 = new_pos1, new_vel1\n            pos2, vel2 = new_pos2, new_vel2\n\n            # Check for instability (e.g., diverging velocities or positions)\n            if np.any(np.abs(pos1) > self.instability_threshold) or np.any(np.abs(pos2) > self.instability_threshold):\n                warnings.warn(f"Simulation unstable at time {t:.3f}s: positions exceed threshold.")\n                break\n\n        return simulation_data\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xf4R\x1b[\'r\xf8\xbf`\x08\x00\x00`\x08\x00\x00\n\x00\x00\x00data_io.pyimport json\nimport csv\nimport argparse\nimport logging\n\n\ndef setup_logger(verbosity=logging.INFO):\n    logger = logging.getLogger(\'OrbitalSimulator\')\n    logger.setLevel(verbosity)\n    if not logger.handlers:\n        ch = logging.StreamHandler()\n        formatter = logging.Formatter(\'%(asctime)s - %(name)s - %(levelname)s - %(message)s\')\n        ch.setFormatter(formatter)\n        logger.addHandler(ch)\n    return logger\n\n\ndef parse_config_file(config_path):\n    """\n    Parse a JSON configuration file and return a dictionary of parameters.\n    """\n    with open(config_path, \'r\') as f:\n        config = json.load(f)\n    return config\n\n\ndef export_data_csv(filename, simulation_data):\n    """\n    Export simulation data to a CSV file. This example writes time and positions of both bodies.\n    """\n    with open(filename, \'w\', newline=\'\') as csvfile:\n        fieldnames = [\'time\', \'body1_x\', \'body1_y\', \'body2_x\', \'body2_y\']\n        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n        writer.writeheader()\n        for state in simulation_data:\n            row = {\n                \'time\': state[\'time\'],\n                \'body1_x\': state[\'body1\'][\'pos\'][0],\n                \'body1_y\': state[\'body1\'][\'pos\'][1],\n                \'body2_x\': state[\'body2\'][\'pos\'][0],\n                \'body2_y\': state[\'body2\'][\'pos\'][1]\n            }\n            writer.writerow(row)\n\n\ndef export_data_json(filename, simulation_data):\n    """\n    Export simulation data to a JSON file.\n    """\n    with open(filename, \'w\') as f:\n        json.dump(simulation_data, f, indent=4)\n\n\ndef get_command_line_args():\n    parser = argparse.ArgumentParser(description=\'2D Orbital Simulator\')\n    parser.add_argument(\'-c\', \'--config\', help=\'Path to configuration JSON file\', required=True)\n    parser.add_argument(\'--export_csv\', help=\'Path to export CSV file\', default=None)\n    parser.add_argument(\'--export_json\', help=\'Path to export JSON file\', default=None)\n    parser.add_argument(\'--verbose\', help=\'Verbose output\', action=\'store_true\')\n    parser.add_argument(\'--visualize\', help=\'Enable visualization\', action=\'store_true\')\n    return parser.parse_args()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xf4R\x1b[;\x7fo|\xa5\t\x00\x00\xa5\t\x00\x00\x10\x00\x00\x00visualization.pyimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\nclass PlotManager:\n    def __init__(self, simulation_data):\n        self.simulation_data = simulation_data\n        self.body1_positions = [state[\'body1\'][\'pos\'] for state in simulation_data]\n        self.body2_positions = [state[\'body2\'][\'pos\'] for state in simulation_data]\n        self.fig, self.ax = plt.subplots()\n        self.body1_line, = self.ax.plot([], [], \'bo-\', label=\'Body 1\')\n        self.body2_line, = self.ax.plot([], [], \'ro-\', label=\'Body 2\')\n\n    def init_plot(self):\n        self.ax.set_xlabel(\'X Position\')\n        self.ax.set_ylabel(\'Y Position\')\n        self.ax.set_title(\'2D Orbital Simulator Trajectories\')\n        self.ax.legend()\n        self.ax.grid(True)\n        return self.body1_line, self.body2_line\n\n    def update(self, frame):\n        # Update the plot for the given frame\n        b1_pos = self.body1_positions[:frame+1]\n        b2_pos = self.body2_positions[:frame+1]\n\n        b1_x = [pos[0] for pos in b1_pos]\n        b1_y = [pos[1] for pos in b1_pos]\n        b2_x = [pos[0] for pos in b2_pos]\n        b2_y = [pos[1] for pos in b2_pos]\n\n        self.body1_line.set_data(b1_x, b1_y)\n        self.body2_line.set_data(b2_x, b2_y)\n\n        # Optionally, adjust plot limits dynamically\n        all_x = b1_x + b2_x\n        all_y = b1_y + b2_y\n        if all_x and all_y:\n            self.ax.set_xlim(min(all_x)-1, max(all_x)+1)\n            self.ax.set_ylim(min(all_y)-1, max(all_y)+1)\n\n        return self.body1_line, self.body2_line\n\n    def show_static(self):\n        # Create a static plot of the full trajectories\n        b1_x = [pos[0] for pos in self.body1_positions]\n        b1_y = [pos[1] for pos in self.body1_positions]\n        b2_x = [pos[0] for pos in self.body2_positions]\n        b2_y = [pos[1] for pos in self.body2_positions]\n\n        plt.figure()\n        plt.plot(b1_x, b1_y, \'bo-\', label=\'Body 1\')\n        plt.plot(b2_x, b2_y, \'ro-\', label=\'Body 2\')\n        plt.xlabel(\'X Position\')\n        plt.ylabel(\'Y Position\')\n        plt.title(\'2D Orbital Simulator Trajectories\')\n        plt.legend()\n        plt.grid(True)\n        plt.show()\n\n    def animate(self, interval=50):\n        # Animate the simulation using matplotlib\'s FuncAnimation\n        anim = FuncAnimation(self.fig, self.update, init_func=self.init_plot,\n                             frames=len(self.simulation_data), interval=interval, blit=True, repeat=False)\n        plt.show()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xf4R\x1b[\x81\xf7B$\x11\x08\x00\x00\x11\x08\x00\x00\x07\x00\x00\x00main.pyimport numpy as np\nfrom simulation_engine import SimulationEngine\nfrom data_io import get_command_line_args, parse_config_file, setup_logger, export_data_csv, export_data_json\nfrom visualization import PlotManager\n\n\ndef main():\n    # Parse command-line arguments\n    args = get_command_line_args()\n    verbosity = 10 if args.verbose else 20  # 10=DEBUG, 20=INFO\n    logger = setup_logger(verbosity)\n    \n    logger.info(\'Loading configuration...\')\n    config = parse_config_file(args.config)\n\n    # Extract simulation parameters from config\n    dt = config.get(\'time_step\', 1.0)\n    duration = config.get(\'duration\', 100.0)\n\n    # Define bodies using configuration; defaults provided if missing\n    body1 = config.get(\'body1\', {\n        \'pos\': [0.0, 0.0],\n        \'vel\': [0.0, 0.0],\n        \'mass\': 5.972e24  # Earth mass in kg as an example\n    })\n    body2 = config.get(\'body2\', {\n        \'pos\': [1.0e7, 0.0],\n        \'vel\': [0.0, 1000.0],\n        \'mass\': 7.348e22  # Moon mass in kg as an example\n    })\n\n    # Optionally set gravitational constant if provided\n    G = config.get(\'G\', 6.67430e-11)\n\n    logger.info(\'Initializing simulation engine...\')\n    simulator = SimulationEngine(body1, body2, dt, duration, G=G)\n\n    logger.info(\'Running simulation...\')\n    simulation_data = simulator.run()\n    logger.info(f\'Simulation completed with {len(simulation_data)} time steps.\')\n\n    if args.export_csv:\n        logger.info(f\'Exporting simulation data to CSV: {args.export_csv}\')\n        export_data_csv(args.export_csv, simulation_data)\n    if args.export_json:\n        logger.info(f\'Exporting simulation data to JSON: {args.export_json}\')\n        export_data_json(args.export_json, simulation_data)\n\n    if args.visualize:\n        logger.info(\'Launching visualization...\')\n        plot_manager = PlotManager(simulation_data)\n        # For demonstration, you can switch between static and animated display\n        # Uncomment one of the following lines:\n        # plot_manager.show_static()\n        plot_manager.animate()\n\nif __name__ == \'__main__\':\n    main()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xf4R\x1b[\xe2,\xd1\x11\x17\x01\x00\x00\x17\x01\x00\x00\x13\x00\x00\x00config_example.json{\n    "time_step": 10.0,\n    "duration": 1000.0,\n    "G": 6.67430e-11,\n    "body1": {\n        "pos": [0.0, 0.0],\n        "vel": [0.0, 0.0],\n        "mass": 5.972e24\n    },\n    "body2": {\n        "pos": [1.0e7, 0.0],\n        "vel": [0.0, 1500.0],\n        "mass": 7.348e22\n    }\n}\nPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xf4R\x1b[ha \xa8\x90\x0f\x00\x00\x90\x0f\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00simulation_engine.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xf4R\x1b[\'r\xf8\xbf`\x08\x00\x00`\x08\x00\x00\n\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xc2\x0f\x00\x00data_io.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xf4R\x1b[;\x7fo|\xa5\t\x00\x00\xa5\t\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01J\x18\x00\x00visualization.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xf4R\x1b[\x81\xf7B$\x11\x08\x00\x00\x11\x08\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x1d"\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xf4R\x1b[\xe2,\xd1\x11\x17\x01\x00\x00\x17\x01\x00\x00\x13\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01S*\x00\x00config_example.jsonPK\x05\x06\x00\x00\x00\x00\x05\x00\x05\x00.\x01\x00\x00\x9b+\x00\x00\x00\x00'