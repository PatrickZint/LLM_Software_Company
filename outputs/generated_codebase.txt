b'PK\x03\x04\x14\x00\x00\x00\x00\x002U\x1b[\x8axQ\x02\xa8\x05\x00\x00\xa8\x05\x00\x00\x07\x00\x00\x00main.pyimport time\nfrom simulation_engine import SimulationController\nfrom visualization import VPythonRenderer\nfrom exporter import DataExporter\nfrom security import load_secure_config\n\n\ndef main():\n    # Load secure configuration from environment variables or a .env file\n    config = load_secure_config()\n\n    # Initialize the simulation controller with physics, collision, and event management\n    simulation = SimulationController(config)\n\n    # Initialize the VPython renderer for interactive 3D visualization\n    renderer = VPythonRenderer(simulation, config)\n\n    # Initialize the data exporter for logging and data export (CSV and HDF5)\n    exporter = DataExporter(config)\n\n    print(\'Starting simulation...\')\n    try:\n        while simulation.running:\n            # Update the simulation state by one tick\n            simulation.update()\n            \n            # Refresh the VPython scene\n            renderer.update()\n            \n            # Log the simulation state periodically\n            exporter.log(simulation)\n            \n            # Pause according to time step for real-time simulation\n            time.sleep(config[\'time_step\'])\n    except KeyboardInterrupt:\n        print(\'Simulation terminated by user.\')\n        simulation.running = False\n    finally:\n        # On shutdown, export logged data\n        exporter.export(simulation)\n        print(\'Data export complete. Shutting down.\')\n\n\nif __name__ == \'__main__\':\n    main()PK\x03\x04\x14\x00\x00\x00\x00\x002U\x1b[\\\x0e\xa0\'\x01\x07\x00\x00\x01\x07\x00\x00\x14\x00\x00\x00simulation_engine.pyimport numpy as np\nfrom physics import Body, integrate_rk4, integrate_verlet\nfrom collision import CollisionManager\n\n\nclass SimulationController:\n    def __init__(self, config):\n        self.config = config\n        self.time_step = config.get(\'time_step\', 0.01)\n        self.total_time = config.get(\'total_time\', 10)\n        self.method = config.get(\'integration_method\', \'RK4\')\n        self.bodies = self.initialize_bodies(config)\n        self.collision_manager = CollisionManager(config)\n        self.current_time = 0\n        self.running = True\n\n    def initialize_bodies(self, config):\n        # In a full implementation, bodies could be configured via a UI or config file.\n        # Here, we create two sample celestial bodies with preset properties.\n        bodies = []\n        body1 = Body(\n            mass=5.0,\n            radius=1.0,\n            position=np.array([0.0, 0.0, 0.0]),\n            velocity=np.array([0.0, 0.0, 0.0])\n        )\n        body2 = Body(\n            mass=1.0,\n            radius=0.5,\n            position=np.array([5.0, 0.0, 0.0]),\n            velocity=np.array([0.0, 1.0, 0.0])\n        )\n        bodies.append(body1)\n        bodies.append(body2)\n        return bodies\n\n    def update(self):\n        # Update simulation state by one tick\n        if self.current_time >= self.total_time:\n            self.running = False\n            return\n\n        # Select the numerical integration method based on configuration\n        if self.method.upper() == \'RK4\':\n            integrate_rk4(self.bodies, self.time_step)\n        else:\n            integrate_verlet(self.bodies, self.time_step)\n\n        # Check for collisions and resolve using the collision manager\n        self.collision_manager.check_and_resolve(self.bodies)\n\n        self.current_time += self.time_step\nPK\x03\x04\x14\x00\x00\x00\x00\x002U\x1b[Z\xec$p\xdf\x0b\x00\x00\xdf\x0b\x00\x00\n\x00\x00\x00physics.pyimport numpy as np\n\n# Gravitational constant (in SI units, if using realistic scaling)\nG = 6.67430e-11\n\n\nclass Body:\n    def __init__(self, mass, radius, position, velocity):\n        self.mass = mass\n        self.radius = radius\n        self.position = position.astype(float)\n        self.velocity = velocity.astype(float)\n\n\ndef compute_acceleration(bodies, index):\n    """Compute net gravitational acceleration on a body at index from all other bodies."""\n    body = bodies[index]\n    acceleration = np.zeros(3)\n    for j, other in enumerate(bodies):\n        if index != j:\n            r_vec = other.position - body.position\n            # Add a small epsilon to avoid division by zero\n            distance = np.linalg.norm(r_vec) + 1e-10\n            # Newtonian gravitation\n            a = G * other.mass / (distance**3) * r_vec\n            acceleration += a\n    return acceleration\n\n\ndef integrate_rk4(bodies, dt):\n    """Integrate bodies\' motion using the fourth-order Runge-Kutta method."""\n    num_bodies = len(bodies)\n    positions = [body.position.copy() for body in bodies]\n    velocities = [body.velocity.copy() for body in bodies]\n\n    # k1\n    k1_v = [compute_acceleration(bodies, i) * dt for i in range(num_bodies)]\n    k1_x = [vel * dt for vel in velocities]\n\n    # k2\n    for i, body in enumerate(bodies):\n        body.position = positions[i] + 0.5 * k1_x[i]\n        body.velocity = velocities[i] + 0.5 * k1_v[i]\n    k2_v = [compute_acceleration(bodies, i) * dt for i in range(num_bodies)]\n    k2_x = [body.velocity * dt for body in bodies]\n\n    # k3\n    for i, body in enumerate(bodies):\n        body.position = positions[i] + 0.5 * k2_x[i]\n        body.velocity = velocities[i] + 0.5 * k2_v[i]\n    k3_v = [compute_acceleration(bodies, i) * dt for i in range(num_bodies)]\n    k3_x = [body.velocity * dt for body in bodies]\n\n    # k4\n    for i, body in enumerate(bodies):\n        body.position = positions[i] + k3_x[i]\n        body.velocity = velocities[i] + k3_v[i]\n    k4_v = [compute_acceleration(bodies, i) * dt for i in range(num_bodies)]\n    k4_x = [body.velocity * dt for body in bodies]\n\n    # Combine increments\n    for i, body in enumerate(bodies):\n        body.position = positions[i] + (k1_x[i] + 2*k2_x[i] + 2*k3_x[i] + k4_x[i]) / 6\n        body.velocity = velocities[i] + (k1_v[i] + 2*k2_v[i] + 2*k3_v[i] + k4_v[i]) / 6\n\n\ndef integrate_verlet(bodies, dt):\n    """Integrate bodies\' motion using the Verlet integration method."""\n    num_bodies = len(bodies)\n    # Compute current accelerations for all bodies\n    accelerations = [compute_acceleration(bodies, i) for i in range(num_bodies)]\n\n    # Update positions\n    for i, body in enumerate(bodies):\n        body.position += body.velocity * dt + 0.5 * accelerations[i] * dt * dt\n\n    # Compute new accelerations after position update\n    new_accelerations = [compute_acceleration(bodies, i) for i in range(num_bodies)]\n\n    # Update velocities\n    for i, body in enumerate(bodies):\n        body.velocity += 0.5 * (accelerations[i] + new_accelerations[i]) * dt\nPK\x03\x04\x14\x00\x00\x00\x00\x002U\x1b[\x8f.`W\x13\n\x00\x00\x13\n\x00\x00\x0c\x00\x00\x00collision.pyimport numpy as np\n\n\nclass CollisionManager:\n    def __init__(self, config):\n        # Collision resolution mode: \'merge\' or \'bounce\'\n        self.mode = config.get(\'collision_mode\', \'merge\')\n\n    def check_and_resolve(self, bodies):\n        """Detect and process collisions among bodies. Uses simple pairwise checks; in production, spatial partitioning should be applied."""\n        to_remove = []\n        to_add = []\n        num_bodies = len(bodies)\n\n        for i in range(num_bodies):\n            for j in range(i + 1, num_bodies):\n                body1 = bodies[i]\n                body2 = bodies[j]\n                distance = np.linalg.norm(body1.position - body2.position)\n                if distance < (body1.radius + body2.radius):\n                    if self.mode.lower() == \'merge\':\n                        merged_body = self.merge_bodies(body1, body2)\n                        to_remove.extend([i, j])\n                        to_add.append(merged_body)\n                    elif self.mode.lower() == \'bounce\':\n                        self.bounce_bodies(body1, body2)\n\n        # Remove collided bodies and add merged ones\n        if to_remove:\n            # Remove duplicate indices by converting to a set\n            for index in sorted(set(to_remove), reverse=True):\n                del bodies[index]\n            bodies.extend(to_add)\n\n    def merge_bodies(self, body1, body2):\n        """Merge two bodies conserving total mass and momentum."""\n        new_mass = body1.mass + body2.mass\n        new_radius = max(body1.radius, body2.radius)  # Simplistic approach\n        new_position = (body1.position * body1.mass + body2.position * body2.mass) / new_mass\n        new_velocity = (body1.velocity * body1.mass + body2.velocity * body2.mass) / new_mass\n        # Import Body locally to avoid circular dependency issues\n        from physics import Body\n        return Body(new_mass, new_radius, new_position, new_velocity)\n\n    def bounce_bodies(self, body1, body2):\n        """Process elastic collision between two bodies using a simple impulse-based model."""\n        normal = body2.position - body1.position\n        norm = np.linalg.norm(normal) + 1e-10\n        normal = normal / norm\n        relative_velocity = body1.velocity - body2.velocity\n        # Coefficient of restitution (1.0 for perfectly elastic collisions)\n        restitution = 1.0\n        impulse = -(1 + restitution) * np.dot(relative_velocity, normal) / (1/body1.mass + 1/body2.mass)\n        body1.velocity += (impulse * normal) / body1.mass\n        body2.velocity -= (impulse * normal) / body2.mass\nPK\x03\x04\x14\x00\x00\x00\x00\x002U\x1b[\xd9\xbf\xab\x0bK\x05\x00\x00K\x05\x00\x00\x10\x00\x00\x00visualization.pyfrom vpython import sphere, vector, rate, scene, color\n\n\nclass VPythonRenderer:\n    def __init__(self, simulation_controller, config):\n        self.simulation = simulation_controller\n        self.bodies_visual = []\n        self.init_scene()\n        self.create_body_visuals()\n\n    def init_scene(self):\n        scene.title = "3D Gravitational Simulation"\n        scene.width = 800\n        scene.height = 600\n        scene.background = color.black\n\n    def create_body_visuals(self):\n        """Create visual representations for each simulation body."""\n        self.bodies_visual = []\n        for body in self.simulation.bodies:\n            s = sphere(pos=vector(*body.position), radius=body.radius, make_trail=True)\n            self.bodies_visual.append(s)\n\n    def update(self):\n        rate(100)  # Control the refresh rate for smooth animation\n        # Update positions of visual objects to match simulation bodies\n        for i, body in enumerate(self.simulation.bodies):\n            try:\n                self.bodies_visual[i].pos = vector(*body.position)\n            except IndexError:\n                # If new bodies are added during simulation, create their visuals\n                from vpython import sphere\n                s = sphere(pos=vector(*body.position), radius=body.radius, make_trail=True)\n                self.bodies_visual.append(s)\nPK\x03\x04\x14\x00\x00\x00\x00\x002U\x1b[p\x91\x03\xa0\x89\t\x00\x00\x89\t\x00\x00\x0b\x00\x00\x00exporter.pyimport csv\nimport h5py\nimport time\n\n\nclass DataExporter:\n    def __init__(self, config):\n        self.config = config\n        self.log_interval = config.get(\'log_interval\', 0.1)\n        self.last_log_time = time.time()\n        # Data will be stored as a list of snapshots\n        # Each snapshot contains the simulation time and body states\n        self.data = []\n\n    def log(self, simulation):\n        current_time = time.time()\n        if current_time - self.last_log_time >= self.log_interval:\n            snapshot = {\n                \'time\': simulation.current_time,\n                # For each body, store position and velocity as lists\n                \'bodies\': [\n                    (body.position.tolist(), body.velocity.tolist()) for body in simulation.bodies\n                ]\n            }\n            self.data.append(snapshot)\n            self.last_log_time = current_time\n\n    def export(self, simulation):\n        # Export logged data to CSV\n        csv_filename = self.config.get(\'export_csv\', \'simulation.csv\')\n        with open(csv_filename, \'w\', newline=\'\') as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerow([\'time\', \'body_index\', \'position\', \'velocity\'])\n            for snapshot in self.data:\n                t = snapshot[\'time\']\n                for idx, (pos, vel) in enumerate(snapshot[\'bodies\']):\n                    writer.writerow([t, idx, pos, vel])\n\n        # Export logged data to HDF5\n        hdf5_filename = self.config.get(\'export_hdf5\', \'simulation.h5\')\n        with h5py.File(hdf5_filename, \'w\') as h5file:\n            grp = h5file.create_group(\'simulation\')\n            times = [snapshot[\'time\'] for snapshot in self.data]\n            grp.create_dataset(\'time\', data=times)\n\n            if self.data and self.data[0][\'bodies\']:\n                num_snapshots = len(self.data)\n                num_bodies = len(self.data[0][\'bodies\'])\n\n                # Create datasets for positions and velocities\n                pos_data = []\n                vel_data = []\n                for snapshot in self.data:\n                    pos_snapshot = [pos for pos, _ in snapshot[\'bodies\']]\n                    vel_snapshot = [vel for _, vel in snapshot[\'bodies\']]\n                    pos_data.append(pos_snapshot)\n                    vel_data.append(vel_snapshot)\n\n                grp.create_dataset(\'positions\', data=pos_data)\n                grp.create_dataset(\'velocities\', data=vel_data)\nPK\x03\x04\x14\x00\x00\x00\x00\x002U\x1b[z, 1\xc8\x02\x00\x00\xc8\x02\x00\x00\x0b\x00\x00\x00security.pyimport os\nfrom dotenv import load_dotenv\n\n\ndef load_secure_config():\n    """Load configuration settings securely using environment variables."""\n    # Load environment variables from a .env file if present\n    load_dotenv()\n    config = {\n        \'time_step\': float(os.getenv(\'TIME_STEP\', \'0.01\')),\n        \'total_time\': float(os.getenv(\'TOTAL_TIME\', \'10\')),\n        \'integration_method\': os.getenv(\'INTEGRATION_METHOD\', \'RK4\'),\n        \'collision_mode\': os.getenv(\'COLLISION_MODE\', \'merge\'),\n        \'log_interval\': float(os.getenv(\'LOG_INTERVAL\', \'0.1\')),\n        \'export_csv\': os.getenv(\'EXPORT_CSV\', \'simulation.csv\'),\n        \'export_hdf5\': os.getenv(\'EXPORT_HDF5\', \'simulation.h5\')\n    }\n    return config\nPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x002U\x1b[\x8axQ\x02\xa8\x05\x00\x00\xa8\x05\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x002U\x1b[\\\x0e\xa0\'\x01\x07\x00\x00\x01\x07\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xcd\x05\x00\x00simulation_engine.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x002U\x1b[Z\xec$p\xdf\x0b\x00\x00\xdf\x0b\x00\x00\n\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\r\x00\x00physics.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x002U\x1b[\x8f.`W\x13\n\x00\x00\x13\n\x00\x00\x0c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x07\x19\x00\x00collision.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x002U\x1b[\xd9\xbf\xab\x0bK\x05\x00\x00K\x05\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01D#\x00\x00visualization.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x002U\x1b[p\x91\x03\xa0\x89\t\x00\x00\x89\t\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xbd(\x00\x00exporter.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x002U\x1b[z, 1\xc8\x02\x00\x00\xc8\x02\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01o2\x00\x00security.pyPK\x05\x06\x00\x00\x00\x00\x07\x00\x07\x00\x99\x01\x00\x00`5\x00\x00\x00\x00'