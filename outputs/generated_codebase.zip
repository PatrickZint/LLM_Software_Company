Certainly! Below is a comprehensive Python-based simple calculator application structured according to the provided system architecture and specifications. The application is modular, ensuring separation of concerns, maintainability, and scalability. Additionally, it includes a database model using SQLite (via SQLAlchemy) to store calculation history for future enhancements.

## **Project Structure**

For clarity and maintainability, the project is organized into the following modules:

1. **`main.py`**: Entry point that initializes and runs the application.
2. **`ui.py`**: Handles the User Interface using Tkinter.
3. **`input_handler.py`**: Manages user inputs from GUI buttons and keyboard.
4. **`logic.py`**: Manages the current arithmetic expression and delegates evaluation.
5. **`calculation_engine.py`**: Parses and safely evaluates arithmetic expressions.
6. **`error_handler.py`**: Handles and displays errors gracefully.
7. **`models.py`**: Defines the database models for storing calculation history.
8. **`database.py`**: Manages database connections and operations.

For simplicity, the entire codebase is presented below as separate sections. In an actual development environment, each module should reside in its own `.py` file within the project directory.

---

### **1. `models.py`**

Defines the database model for storing calculation history using SQLAlchemy.

```python
# models.py

from sqlalchemy import Column, Integer, String, Float, DateTime
from sqlalchemy.ext.declarative import declarative_base
import datetime

Base = declarative_base()

class Calculation(Base):
    __tablename__ = 'calculations'
    
    id = Column(Integer, primary_key=True)
    expression = Column(String, nullable=False)
    result = Column(Float, nullable=False)
    timestamp = Column(DateTime, default=datetime.datetime.utcnow)

    def __repr__(self):
        return f"<Calculation(id={self.id}, expression='{self.expression}', result={self.result}, timestamp={self.timestamp})>"
```

---

### **2. `database.py`**

Manages database connections and operations.

```python
# database.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Base

class Database:
    def __init__(self, db_url='sqlite:///calculations.db'):
        self.engine = create_engine(db_url, echo=False)
        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)
    
    def add_calculation(self, expression, result):
        session = self.Session()
        calc = Calculation(expression=expression, result=result)
        session.add(calc)
        session.commit()
        session.close()
    
    def get_history(self, limit=10):
        session = self.Session()
        history = session.query(Calculation).order_by(Calculation.timestamp.desc()).limit(limit).all()
        session.close()
        return history
```

---

### **3. `calculation_engine.py`**

Safely parses and evaluates arithmetic expressions using Python's `ast` module.

```python
# calculation_engine.py

import ast
import operator

class CalculationEngine:
    # Supported operators
    operators = {
        ast.Add: operator.add,
        ast.Sub: operator.sub,
        ast.Mult: operator.mul,
        ast.Div: operator.truediv,
        ast.USub: operator.neg,
        ast.Pow: operator.pow,
        ast.Mod: operator.mod,
    }
    
    def evaluate(self, expression):
        """
        Evaluate an arithmetic expression safely.
        """
        try:
            node = ast.parse(expression, mode='eval').body
            result = self._eval(node)
            return result
        except ZeroDivisionError:
            raise ValueError("Error: Division by zero.")
        except Exception:
            raise ValueError("Error: Invalid expression.")
    
    def _eval(self, node):
        if isinstance(node, ast.Num):  # <number>
            return node.n
        elif isinstance(node, ast.BinOp):  # <left> <operator> <right>
            op_type = type(node.op)
            if op_type in self.operators:
                left = self._eval(node.left)
                right = self._eval(node.right)
                return self.operators[op_type](left, right)
            else:
                raise ValueError(f"Unsupported operator: {op_type}")
        elif isinstance(node, ast.UnaryOp):  # <operator> <operand> e.g., -1
            op_type = type(node.op)
            if op_type in self.operators:
                operand = self._eval(node.operand)
                return self.operators[op_type](operand)
            else:
                raise ValueError(f"Unsupported operator: {op_type}")
        else:
            raise ValueError(f"Unsupported expression: {node}")
```

---

### **4. `error_handler.py`**

Handles and displays errors gracefully.

```python
# error_handler.py

class ErrorHandler:
    @staticmethod
    def handle_error(message, display_callback):
        """
        Handle errors by invoking the display callback with the error message.
        """
        display_callback(message)
```

---

### **5. `logic.py`**

Manages the current arithmetic expression and delegates evaluation to the Calculation Engine.

```python
# logic.py

class LogicModule:
    def __init__(self, calculation_engine, error_handler, db):
        self.expression = ""
        self.calculation_engine = calculation_engine
        self.error_handler = error_handler
        self.db = db
    
    def append_expression(self, value):
        self.expression += str(value)
    
    def clear_expression(self):
        self.expression = ""
    
    def backspace(self):
        self.expression = self.expression[:-1]
    
    def evaluate_expression(self):
        try:
            result = self.calculation_engine.evaluate(self.expression)
            # Store in database
            self.db.add_calculation(self.expression, result)
            self.expression = str(result)
            return result
        except ValueError as ve:
            self.error_handler.handle_error(str(ve), self.display_error)
            return None
    
    def get_expression(self):
        return self.expression
    
    def display_error(self, message):
        # Placeholder for error display callback
        pass
```

---

### **6. `input_handler.py`**

Manages user inputs from GUI buttons and keyboard.

```python
# input_handler.py

import tkinter as tk

class InputHandler:
    def __init__(self, logic_module):
        self.logic = logic_module
    
    def handle_button_press(self, char):
        if char == 'C':
            self.logic.clear_expression()
        elif char == '⌫':
            self.logic.backspace()
        elif char == '=':
            self.logic.evaluate_expression()
        else:
            self.logic.append_expression(char)
    
    def handle_key_press(self, event):
        key = event.char
        if key in '0123456789.+-*/':
            self.logic.append_expression(key)
        elif key == '\r':
            self.logic.evaluate_expression()
        elif key == '\x08':  # Backspace key
            self.logic.backspace()
        elif key.lower() == 'c':
            self.logic.clear_expression()
```

---

### **7. `ui.py`**

Handles the User Interface using Tkinter.

```python
# ui.py

import tkinter as tk
from tkinter import messagebox
from calculation_engine import CalculationEngine
from error_handler import ErrorHandler
from logic import LogicModule
from input_handler import InputHandler
from database import Database

class CalculatorUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Simple Calculator")
        self.root.resizable(False, False)
        
        # Initialize modules
        self.db = Database()
        self.calculation_engine = CalculationEngine()
        self.error_handler = ErrorHandler()
        self.logic = LogicModule(self.calculation_engine, self.error_handler, self.db)
        self.input_handler = InputHandler(self.logic)
        self.logic.display_error = self.display_error
        
        self.create_widgets()
        self.bind_keys()
    
    def create_widgets(self):
        # Display Area
        self.display = tk.Entry(self.root, font=("Arial", 24), borderwidth=2, relief="groove", justify='right')
        self.display.grid(row=0, column=0, columnspan=4, padx=10, pady=10, sticky="we")
        
        # Button definitions
        buttons = [
            ('C', 1, 0), ('⌫', 1, 1), ('%', 1, 2), ('/', 1, 3),
            ('7', 2, 0), ('8', 2, 1), ('9', 2, 2), ('*', 2, 3),
            ('4', 3, 0), ('5', 3, 1), ('6', 3, 2), ('-', 3, 3),
            ('1', 4, 0), ('2', 4, 1), ('3', 4, 2), ('+', 4, 3),
            ('0', 5, 0), ('.', 5, 1), ('=', 5, 2, 2),
        ]
        
        for btn in buttons:
            if len(btn) == 4:
                text, row, column, colspan = btn
                action = lambda x=text: self.on_button_press(x)
                tk.Button(self.root, text=text, width=5, height=2, font=("Arial", 18),
                          command=action).grid(row=row, column=column, columnspan=colspan, padx=5, pady=5, sticky="nsew")
            else:
                text, row, column = btn
                action = lambda x=text: self.on_button_press(x)
                tk.Button(self.root, text=text, width=5, height=2, font=("Arial", 18),
                          command=action).grid(row=row, column=column, padx=5, pady=5)
        
        # Configure grid weights
        for i in range(6):
            self.root.grid_rowconfigure(i, weight=1)
        for j in range(4):
            self.root.grid_columnconfigure(j, weight=1)
    
    def on_button_press(self, char):
        self.input_handler.handle_button_press(char)
        self.update_display()
    
    def bind_keys(self):
        self.root.bind("<Key>", self.on_key_press)
    
    def on_key_press(self, event):
        self.input_handler.handle_key_press(event)
        self.update_display()
    
    def update_display(self):
        self.display.delete(0, tk.END)
        self.display.insert(tk.END, self.logic.get_expression())
    
    def display_error(self, message):
        messagebox.showerror("Error", message)
        self.logic.clear_expression()
        self.update_display()
```

---

### **8. `main.py`**

Entry point that initializes and runs the application.

```python
# main.py

import tkinter as tk
from ui import CalculatorUI

def main():
    root = tk.Tk()
    app = CalculatorUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
```

---

## **Complete Codebase in a Single File**

For ease of testing and execution, you can combine all the modules into a single `main.py` file as shown below. This approach is suitable for small projects or quick testing. However, for larger projects or production environments, it's recommended to separate modules into individual files as detailed above.

```python
# main.py

import tkinter as tk
from tkinter import messagebox
import ast
import operator
from sqlalchemy import Column, Integer, String, Float, DateTime, create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import datetime

# ------------------ Database Models ------------------

Base = declarative_base()

class Calculation(Base):
    __tablename__ = 'calculations'
    
    id = Column(Integer, primary_key=True)
    expression = Column(String, nullable=False)
    result = Column(Float, nullable=False)
    timestamp = Column(DateTime, default=datetime.datetime.utcnow)

    def __repr__(self):
        return f"<Calculation(id={self.id}, expression='{self.expression}', result={self.result}, timestamp={self.timestamp})>"

# ------------------ Database Handler ------------------

class Database:
    def __init__(self, db_url='sqlite:///calculations.db'):
        self.engine = create_engine(db_url, echo=False)
        Base.metadata.create_all(self.engine)
        self.Session = sessionmaker(bind=self.engine)
    
    def add_calculation(self, expression, result):
        session = self.Session()
        calc = Calculation(expression=expression, result=result)
        session.add(calc)
        session.commit()
        session.close()
    
    def get_history(self, limit=10):
        session = self.Session()
        history = session.query(Calculation).order_by(Calculation.timestamp.desc()).limit(limit).all()
        session.close()
        return history

# ------------------ Calculation Engine ------------------

class CalculationEngine:
    # Supported operators
    operators = {
        ast.Add: operator.add,
        ast.Sub: operator.sub,
        ast.Mult: operator.mul,
        ast.Div: operator.truediv,
        ast.USub: operator.neg,
        ast.Pow: operator.pow,
        ast.Mod: operator.mod,
    }
    
    def evaluate(self, expression):
        """
        Evaluate an arithmetic expression safely.
        """
        try:
            node = ast.parse(expression, mode='eval').body
            result = self._eval(node)
            return result
        except ZeroDivisionError:
            raise ValueError("Error: Division by zero.")
        except Exception:
            raise ValueError("Error: Invalid expression.")
    
    def _eval(self, node):
        if isinstance(node, ast.Num):  # <number>
            return node.n
        elif isinstance(node, ast.BinOp):  # <left> <operator> <right>
            op_type = type(node.op)
            if op_type in self.operators:
                left = self._eval(node.left)
                right = self._eval(node.right)
                return self.operators[op_type](left, right)
            else:
                raise ValueError(f"Unsupported operator: {op_type}")
        elif isinstance(node, ast.UnaryOp):  # <operator> <operand> e.g., -1
            op_type = type(node.op)
            if op_type in self.operators:
                operand = self._eval(node.operand)
                return self.operators[op_type](operand)
            else:
                raise ValueError(f"Unsupported operator: {op_type}")
        else:
            raise ValueError(f"Unsupported expression: {node}")

# ------------------ Error Handler ------------------

class ErrorHandler:
    @staticmethod
    def handle_error(message, display_callback):
        """
        Handle errors by invoking the display callback with the error message.
        """
        display_callback(message)

# ------------------ Logic Module ------------------

class LogicModule:
    def __init__(self, calculation_engine, error_handler, db):
        self.expression = ""
        self.calculation_engine = calculation_engine
        self.error_handler = error_handler
        self.db = db
    
    def append_expression(self, value):
        self.expression += str(value)
    
    def clear_expression(self):
        self.expression = ""
    
    def backspace(self):
        self.expression = self.expression[:-1]
    
    def evaluate_expression(self):
        try:
            result = self.calculation_engine.evaluate(self.expression)
            # Store in database
            self.db.add_calculation(self.expression, result)
            self.expression = str(result)
            return result
        except ValueError as ve:
            self.error_handler.handle_error(str(ve), self.display_error)
            return None
    
    def get_expression(self):
        return self.expression
    
    def display_error(self, message):
        # Placeholder for error display callback
        pass

# ------------------ Input Handler ------------------

class InputHandler:
    def __init__(self, logic_module):
        self.logic = logic_module
    
    def handle_button_press(self, char):
        if char == 'C':
            self.logic.clear_expression()
        elif char == '⌫':
            self.logic.backspace()
        elif char == '=':
            self.logic.evaluate_expression()
        else:
            self.logic.append_expression(char)
    
    def handle_key_press(self, event):
        key = event.char
        if key in '0123456789.+-*/%':
            self.logic.append_expression(key)
        elif key == '\r':
            self.logic.evaluate_expression()
        elif key == '\x08':  # Backspace key
            self.logic.backspace()
        elif key.lower() == 'c':
            self.logic.clear_expression()

# ------------------ UI Module ------------------

class CalculatorUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Simple Calculator")
        self.root.resizable(False, False)
        
        # Initialize modules
        self.db = Database()
        self.calculation_engine = CalculationEngine()
        self.error_handler = ErrorHandler()
        self.logic = LogicModule(self.calculation_engine, self.error_handler, self.db)
        self.input_handler = InputHandler(self.logic)
        self.logic.display_error = self.display_error
        
        self.create_widgets()
        self.bind_keys()
    
    def create_widgets(self):
        # Display Area
        self.display = tk.Entry(self.root, font=("Arial", 24), borderwidth=2, relief="groove", justify='right')
        self.display.grid(row=0, column=0, columnspan=4, padx=10, pady=10, sticky="we")
        
        # Button definitions
        buttons = [
            ('C', 1, 0), ('⌫', 1, 1), ('%', 1, 2), ('/', 1, 3),
            ('7', 2, 0), ('8', 2, 1), ('9', 2, 2), ('*', 2, 3),
            ('4', 3, 0), ('5', 3, 1), ('6', 3, 2), ('-', 3, 3),
            ('1', 4, 0), ('2', 4, 1), ('3', 4, 2), ('+', 4, 3),
            ('0', 5, 0), ('.', 5, 1), ('=', 5, 2, 2),
        ]
        
        for btn in buttons:
            if len(btn) == 4:
                text, row, column, colspan = btn
                action = lambda x=text: self.on_button_press(x)
                tk.Button(self.root, text=text, width=5, height=2, font=("Arial", 18),
                          command=action).grid(row=row, column=column, columnspan=colspan, padx=5, pady=5, sticky="nsew")
            else:
                text, row, column = btn
                action = lambda x=text: self.on_button_press(x)
                tk.Button(self.root, text=text, width=5, height=2, font=("Arial", 18),
                          command=action).grid(row=row, column=column, padx=5, pady=5)
        
        # Configure grid weights
        for i in range(6):
            self.root.grid_rowconfigure(i, weight=1)
        for j in range(4):
            self.root.grid_columnconfigure(j, weight=1)
    
    def on_button_press(self, char):
        self.input_handler.handle_button_press(char)
        self.update_display()
    
    def bind_keys(self):
        self.root.bind("<Key>", self.on_key_press)
    
    def on_key_press(self, event):
        self.input_handler.handle_key_press(event)
        self.update_display()
    
    def update_display(self):
        self.display.delete(0, tk.END)
        self.display.insert(tk.END, self.logic.get_expression())
    
    def display_error(self, message):
        messagebox.showerror("Error", message)
        self.logic.clear_expression()
        self.update_display()

# ------------------ Main Function ------------------

def main():
    root = tk.Tk()
    app = CalculatorUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
```

---

## **Dependencies**

Ensure you have the following dependencies installed:

1. **Python 3.10+**
2. **SQLAlchemy**: For ORM and database interactions.

You can install SQLAlchemy using pip:

```bash
pip install SQLAlchemy
```

*Note: Tkinter comes bundled with standard Python installations. If you're using a minimal Python environment and Tkinter is not available, you may need to install it separately based on your operating system.*

---

## **Running the Application**

1. **Save the Code**: Save the complete code into a file named `main.py`.
2. **Install Dependencies**: Ensure SQLAlchemy is installed as mentioned above.
3. **Execute the Application**:

   ```bash
   python main.py
   ```

   This command will launch the calculator GUI.

---

## **Application Features**

- **User Interface (UI)**
  - **Display Area**: Shows the current input and results.
  - **Buttons**: Includes numeric buttons (0-9), decimal point, arithmetic operations (`+`, `-`, `*`, `/`, `%`), equals (`=`), clear (`C`), and backspace (`⌫`).

- **Input Methods**
  - **GUI Buttons**: Users can click on-screen buttons to input expressions.
  - **Keyboard Support**: Users can also use the keyboard for input.

- **Arithmetic Operations**
  - Supports addition, subtraction, multiplication, division, and modulus.
  - Handles multi-digit and decimal numbers.
  - Maintains operator precedence (e.g., multiplication before addition).

- **Error Handling**
  - Detects and notifies users of division by zero.
  - Prevents and alerts users about invalid expressions.
  - Provides clear error messages without crashing the application.

- **Calculation History**
  - Stores past calculations in an SQLite database (`calculations.db`).
  - Although not displayed in the current UI, the history can be retrieved and utilized for future enhancements like displaying a history log.

---

## **Future Enhancements**

Based on the initial system architecture and specifications, the following enhancements can be considered for future development:

1. **History Log UI**: Display the history of past calculations within the GUI.
2. **Advanced Mathematical Functions**: Incorporate functions like exponentiation, square roots, logarithms, etc.
3. **Theming**: Allow users to switch between different UI themes or color schemes.
4. **Localization**: Support multiple languages for a broader user base.
5. **Accessibility Features**: Implement screen reader compatibility, high-contrast modes, and more keyboard shortcuts to enhance accessibility.

---

## **Testing the Application**

To ensure the reliability and correctness of the calculator, consider implementing unit tests for the `CalculationEngine` and integration tests for the UI interactions. Python's built-in `unittest` framework or third-party libraries like `pytest` can be utilized for this purpose.

---

## **Packaging and Deployment**

To distribute the calculator as a standalone executable across different operating systems, use packaging tools like **PyInstaller** or **cx_Freeze**.

**Using PyInstaller:**

1. **Install PyInstaller**:

   ```bash
   pip install pyinstaller
   ```

2. **Create Executable**:

   ```bash
   pyinstaller --onefile main.py
   ```

   This command will generate a standalone executable in the `dist` directory.

*Note: Ensure that all dependencies are correctly bundled. Test the executable on target operating systems to verify functionality.*

---

## **Conclusion**

This comprehensive codebase adheres to the provided system architecture and specifications, ensuring a modular, maintainable, and scalable Python-based calculator application. By following best practices in error handling, input validation, and secure expression evaluation, the application promises robustness and reliability. Future enhancements can further extend its capabilities, making it a versatile tool for users.