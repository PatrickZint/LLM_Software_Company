b'PK\x03\x04\x14\x00\x00\x00\x00\x00\x14a\xfeZ\xfe\xca\xfb\x90z\r\x00\x00z\r\x00\x00\x13\x00\x00\x00calculator_model.pyimport ast\nimport operator\nimport math\n\nclass CalculatorEngine:\n    def __init__(self):\n        # Allowed functions available for the calculation\n        self.allowed_funcs = {\n            \'sqrt\': math.sqrt,\n            \'log\': math.log,        # natural logarithm\n            \'log10\': math.log10,    \n            \'sin\': math.sin,\n            \'cos\': math.cos,\n            \'tan\': math.tan,\n            \'exp\': math.exp\n        }\n\n    def evaluate(self, expression: str) -> float:\n        """\n        Evaluates a mathematical expression string safely using AST parsing.\n        Supports basic arithmetic and a limited set of mathematical functions.\n\n        :param expression: the mathematical expression in string format\n        :return: evaluated result as float\n        :raises: ValueError if the expression is malformed or contains errors\n        """\n        try:\n            # Replace \'^\' with \'**\' for exponentiation if user enters caret\n            expression = expression.replace(\'^\', \'**\')\n            # Parse the expression into an AST\n            node = ast.parse(expression, mode=\'eval\')\n            return self._evaluate_ast(node.body)\n        except Exception as e:\n            raise ValueError(f"Error evaluating expression: {e}")\n\n    def _evaluate_ast(self, node):\n        if isinstance(node, ast.BinOp):\n            left = self._evaluate_ast(node.left)\n            right = self._evaluate_ast(node.right)\n            return self._apply_operator(node.op, left, right)\n        elif isinstance(node, ast.UnaryOp):\n            operand = self._evaluate_ast(node.operand)\n            return self._apply_unary_operator(node.op, operand)\n        elif isinstance(node, ast.Num):  # For Python < 3.8\n            return node.n\n        elif isinstance(node, ast.Constant):  # For Python 3.8+\n            if isinstance(node.value, (int, float)):\n                return node.value\n            else:\n                raise ValueError("Only int and float constants are allowed")\n        elif isinstance(node, ast.Call):\n            # Ensure that only allowed functions are called\n            if isinstance(node.func, ast.Name) and node.func.id in self.allowed_funcs:\n                args = [self._evaluate_ast(arg) for arg in node.args]\n                return self.allowed_funcs[node.func.id](*args)\n            else:\n                raise ValueError(f"Function \'{getattr(node.func, \'id\', \'unknown\')}\' is not allowed")\n        elif isinstance(node, ast.Expression):\n            return self._evaluate_ast(node.body)\n        else:\n            raise ValueError("Unsupported expression")\n\n    def _apply_operator(self, op, left, right):\n        if isinstance(op, ast.Add):\n            return operator.add(left, right)\n        elif isinstance(op, ast.Sub):\n            return operator.sub(left, right)\n        elif isinstance(op, ast.Mult):\n            return operator.mul(left, right)\n        elif isinstance(op, ast.Div):\n            if right == 0:\n                raise ValueError("Division by zero")\n            return operator.truediv(left, right)\n        elif isinstance(op, ast.Pow):\n            return operator.pow(left, right)\n        else:\n            raise ValueError("Unsupported operator")\n\n    def _apply_unary_operator(self, op, operand):\n        if isinstance(op, ast.UAdd):\n            return +operand\n        elif isinstance(op, ast.USub):\n            return -operand\n        else:\n            raise ValueError("Unsupported unary operator")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x14a\xfeZ\xb0\\\xd9jh\x0b\x00\x00h\x0b\x00\x00\x12\x00\x00\x00calculator_view.pyimport tkinter as tk\nfrom tkinter import messagebox\n\nclass CalculatorGUI:\n    def __init__(self, controller):\n        self.controller = controller\n        self.root = tk.Tk()\n        self.root.title("Advanced Calculator")\n        \n        # Create the display entry\n        self.display = tk.Entry(self.root, font=("Arial", 20), borderwidth=2, relief="ridge")\n        self.display.grid(row=0, column=0, columnspan=4, padx=10, pady=10, sticky="we")\n        \n        self.build_buttons()\n        self.bind_keys()\n\n    def build_buttons(self):\n        # Define buttons as tuples of (label, row, column)\n        buttons = [\n            (\'7\', 1, 0), (\'8\', 1, 1), (\'9\', 1, 2), (\'/\', 1, 3),\n            (\'4\', 2, 0), (\'5\', 2, 1), (\'6\', 2, 2), (\'*\', 2, 3),\n            (\'1\', 3, 0), (\'2\', 3, 1), (\'3\', 3, 2), (\'-\', 3, 3),\n            (\'0\', 4, 0), (\'.\', 4, 1), (\'(\', 4, 2), (\')\', 4, 3),\n            (\'C\', 5, 0), (\'\xe2\x8c\xab\', 5, 1), (\'=\', 5, 2), (\'+\', 5, 3),\n            (\'sqrt\', 6, 0), (\'log\', 6, 1), (\'sin\', 6, 2), (\'cos\', 6, 3),\n            (\'tan\', 7, 0), (\'exp\', 7, 1), (\'log10\', 7, 2), (\'^\', 7, 3)\n        ]\n\n        for (text, row, col) in buttons:\n            button = tk.Button(self.root, text=text, font=("Arial", 16), command=lambda t=text: self.on_button_click(t))\n            button.grid(row=row, column=col, padx=5, pady=5, sticky="nsew")\n            \n            # Ensure that each button expands properly\n            self.root.grid_rowconfigure(row, weight=1)\n            self.root.grid_columnconfigure(col, weight=1)\n\n    def bind_keys(self):\n        # Bind Enter to evaluate the expression\n        self.root.bind("<Return>", lambda event: self.on_button_click(\'=\'))\n        # Bind Backspace for delete\n        self.root.bind("<BackSpace>", lambda event: self.on_button_click(\'\xe2\x8c\xab\'))\n        # Bind numeric and operator keys\n        for char in "0123456789.+-*/()":\n            self.root.bind(char, lambda event, c=char: self.on_button_click(c))\n\n    def on_button_click(self, char):\n        if char == \'C\':\n            self.clear_display()\n        elif char == \'\xe2\x8c\xab\':\n            current_text = self.display.get()\n            # Delete last character\n            self.display.delete(0, tk.END)\n            self.display.insert(0, current_text[:-1])\n        elif char == \'=\':\n            expr = self.display.get()\n            self.controller.process_expression(expr)\n        elif char == \'^\':\n            # Convert caret to exponentiation operator\n            self.display.insert(tk.END, \'**\')\n        else:\n            # Append the pressed button\'s label to the display\n            self.display.insert(tk.END, char)\n\n    def update_display(self, text):\n        self.clear_display()\n        self.display.insert(0, text)\n\n    def clear_display(self):\n        self.display.delete(0, tk.END)\n\n    def show_error(self, message):\n        messagebox.showerror("Error", message)\n\n    def start(self):\n        self.root.mainloop()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x14a\xfeZ\xb0\xcf\xfe\x99?\x03\x00\x00?\x03\x00\x00\x18\x00\x00\x00calculator_controller.pyimport logging\nfrom calculator_model import CalculatorEngine\nfrom calculator_view import CalculatorGUI\n\nclass CalculatorController:\n    def __init__(self):\n        # Configure logging\n        logging.basicConfig(level=logging.INFO,\n                            format=\'%(asctime)s - %(levelname)s - %(message)s\')\n        self.logger = logging.getLogger(__name__)\n\n        self.engine = CalculatorEngine()\n        self.view = CalculatorGUI(self)\n\n    def process_expression(self, expression: str):\n        try:\n            # Process the expression using the CalculatorEngine\n            result = self.engine.evaluate(expression)\n            self.view.update_display(str(result))\n        except Exception as e:\n            self.logger.error(f"Error processing expression \'{expression}\': {e}")\n            self.view.show_error(str(e))\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x14a\xfeZ<2a1\xb1\x00\x00\x00\xb1\x00\x00\x00\x07\x00\x00\x00main.pyfrom calculator_controller import CalculatorController\n\n\ndef main():\n    controller = CalculatorController()\n    controller.view.start()\n\n\nif __name__ == \'__main__\':\n    main()\nPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x14a\xfeZ\xfe\xca\xfb\x90z\r\x00\x00z\r\x00\x00\x13\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00calculator_model.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x14a\xfeZ\xb0\\\xd9jh\x0b\x00\x00h\x0b\x00\x00\x12\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xab\r\x00\x00calculator_view.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x14a\xfeZ\xb0\xcf\xfe\x99?\x03\x00\x00?\x03\x00\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01C\x19\x00\x00calculator_controller.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x14a\xfeZ<2a1\xb1\x00\x00\x00\xb1\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xb8\x1c\x00\x00main.pyPK\x05\x06\x00\x00\x00\x00\x04\x00\x04\x00\xfc\x00\x00\x00\x8e\x1d\x00\x00\x00\x00'