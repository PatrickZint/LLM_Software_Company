b'PK\x03\x04\x14\x00\x00\x00\x00\x00\x15v*[\xb2\x1a\xc6::\x03\x00\x00:\x03\x00\x00\x07\x00\x00\x00main.pyimport threading\nimport time\nfrom config import load_config, create_default_config\nfrom file_monitor import FileMonitor\nfrom ui import start_ui\nimport database\n\n\ndef main():\n    # Load or create default configuration\n    config = load_config()\n    if config is None:\n        create_default_config()\n        config = load_config()\n    \n    # Initialize the database (default filename from config or fallback)\n    db_path = config.get(\'database\', {}).get(\'path\', \'file_logs.db\')\n    database.initialize_db(db_path)\n\n    # Start the file monitor in a background thread\n    monitor = FileMonitor(config)\n    monitor_thread = threading.Thread(target=monitor.start_monitoring, daemon=True)\n    monitor_thread.start()\n\n    # Start the UI (blocking call)\n    start_ui(config, monitor, db_path)\n\n\nif __name__ == "__main__":\n    main()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x15v*[/\xa5\x11\x15\x9e\x03\x00\x00\x9e\x03\x00\x00\t\x00\x00\x00config.pyimport json\nimport os\n\nCONFIG_FILE = \'config.json\'\n\nDEFAULT_CONFIG = {\n    "monitored_directories": ["/path/to/monitor"],\n    "sorting_rules": {\n        "by_file_type": true,\n        "by_creation_date": true\n    },\n    "database": {\n        "path": "file_logs.db"\n    },\n    "csv_export": {\n        "export_path": "logs_export.csv"\n    },\n    "monitor_interval": 5\n}\n\n\ndef load_config():\n    if not os.path.exists(CONFIG_FILE):\n        return None\n    try:\n        with open(CONFIG_FILE, \'r\') as f:\n            config = json.load(f)\n        return config\n    except Exception as e:\n        print(f"Error loading config: {e}")\n        return None\n\n\ndef create_default_config():\n    try:\n        with open(CONFIG_FILE, \'w\') as f:\n            json.dump(DEFAULT_CONFIG, f, indent=4)\n        print(f"Default configuration created at {CONFIG_FILE}")\n    except Exception as e:\n        print(f"Failed to create default config: {e}")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x15v*[y\x17W\xa6d\x07\x00\x00d\x07\x00\x00\x0f\x00\x00\x00file_monitor.pyimport os\nimport time\nfrom file_sorter import sort_file\nfrom database import log_file_movement\n\nclass FileMonitor:\n    def __init__(self, config):\n        self.config = config\n        self.directories = config.get(\'monitored_directories\', [])\n        self.interval = config.get(\'monitor_interval\', 5)\n        # To keep track of already seen files\n        self.seen_files = {}\n        for directory in self.directories:\n            self.seen_files[directory] = set()\n\n    def start_monitoring(self):\n        print("Starting directory monitoring...")\n        while True:\n            for directory in self.directories:\n                self.scan_directory(directory)\n            time.sleep(self.interval)\n\n    def scan_directory(self, directory):\n        if not os.path.exists(directory):\n            print(f"Directory not found: {directory}")\n            return\n        try:\n            current_files = set(os.listdir(directory))\n            new_files = current_files - self.seen_files[directory]\n            if new_files:\n                for filename in new_files:\n                    full_path = os.path.join(directory, filename)\n                    if os.path.isfile(full_path):\n                        # Process the new file\n                        destination, rule_applied = sort_file(full_path, self.config)\n                        if destination and rule_applied:\n                            # Log the move\n                            log_file_movement(full_path, destination, rule_applied)\n            # Update seen files for the directory\n            self.seen_files[directory] = current_files\n        except Exception as e:\n            print(f"Error scanning {directory}: {e}")\n\n    def manual_trigger(self):\n        # Allow manual scanning of directories\n        for directory in self.directories:\n            self.scan_directory(directory)\n        print("Manual trigger complete.")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x15v*[\xf0n<\x97\x89\x07\x00\x00\x89\x07\x00\x00\x0e\x00\x00\x00file_sorter.pyimport os\nimport shutil\nimport time\nimport datetime\n\n\ndef sort_file(file_path, config):\n    \'\'\'\n    Moves the file based on sorting rules and returns a tuple (destinationFolder, ruleApplied)\n    ruleApplied is a string identifying the sorting rule used.\n    \'\'\'\n    try:\n        sorting_rules = config.get(\'sorting_rules\', {})\n        destination = None\n        rule_applied = None\n        \n        # Determine destination based on file type\n        if sorting_rules.get(\'by_file_type\', False):\n            file_ext = os.path.splitext(file_path)[1].lstrip(\'.\').lower()\n            parent_dir = os.path.dirname(file_path)\n            dest_dir = os.path.join(parent_dir, file_ext + \'_files\')\n            os.makedirs(dest_dir, exist_ok=True)\n            destination = os.path.join(dest_dir, os.path.basename(file_path))\n            rule_applied = \'by_file_type\'\n            shutil.move(file_path, destination)\n            print(f"Moved {file_path} to {destination} based on file type.")\n            return destination, rule_applied\n        \n        # Alternatively, sort by creation date\n        if sorting_rules.get(\'by_creation_date\', False):\n            creation_time = os.path.getctime(file_path)\n            date_str = datetime.datetime.fromtimestamp(creation_time).strftime(\'%Y_%m_%d\')\n            parent_dir = os.path.dirname(file_path)\n            dest_dir = os.path.join(parent_dir, date_str)\n            os.makedirs(dest_dir, exist_ok=True)\n            destination = os.path.join(dest_dir, os.path.basename(file_path))\n            rule_applied = \'by_creation_date\'\n            shutil.move(file_path, destination)\n            print(f"Moved {file_path} to {destination} based on creation date.")\n            return destination, rule_applied\n        \n        # If no rule applied, do nothing\n        return None, None\n    except Exception as e:\n        print(f"Error sorting file {file_path}: {e}")\n        return None, None\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x15v*[\x98C)\x05I\x05\x00\x00I\x05\x00\x00\x0b\x00\x00\x00database.pyimport sqlite3\nimport os\nimport datetime\n\n\ndef get_db_connection(db_path):\n    conn = sqlite3.connect(db_path, check_same_thread=False)\n    return conn\n\n\ndef initialize_db(db_path):\n    conn = get_db_connection(db_path)\n    cursor = conn.cursor()\n    cursor.execute(\'\'\'\n        CREATE TABLE IF NOT EXISTS file_logs (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            original_path TEXT NOT NULL,\n            destination_path TEXT NOT NULL,\n            timestamp TEXT NOT NULL,\n            sorting_rule TEXT NOT NULL\n        )\n    \'\'\')\n    conn.commit()\n    conn.close()\n    print(f"Database initialized at {db_path}")\n\n\ndef log_file_movement(original, destination, rule, db_path_override=None):\n    # If db_path_override is provided use it, else open default db\n    from config import load_config\n    config = load_config() or {}\n    db_path = db_path_override or config.get(\'database\', {}).get(\'path\', \'file_logs.db\')\n    conn = get_db_connection(db_path)\n    cursor = conn.cursor()\n    timestamp = datetime.datetime.now().isoformat()\n    cursor.execute(\'\'\'\n        INSERT INTO file_logs (original_path, destination_path, timestamp, sorting_rule)\n        VALUES (?, ?, ?, ?)\n    \'\'\', (original, destination, timestamp, rule))\n    conn.commit()\n    conn.close()\n    print(f"Logged movement of {original} -> {destination} using rule {rule}")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x15v*[\x955\xc9,\xce\x04\x00\x00\xce\x04\x00\x00\x0f\x00\x00\x00csv_exporter.pyimport csv\nimport sqlite3\n\n\ndef export_logs_to_csv(db_path, export_path, start_date=None, end_date=None, rule_filter=None):\n    """\n    Exports logs from the database to a CSV file with optional filtering by date range and rule.\n    Dates should be in ISO format strings (e.g., \'2023-01-01T00:00:00\').\n    """\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n\n    query = "SELECT original_path, destination_path, timestamp, sorting_rule FROM file_logs WHERE 1=1"\n    params = []\n    if start_date:\n        query += " AND timestamp >= ?"\n        params.append(start_date)\n    if end_date:\n        query += " AND timestamp <= ?"\n        params.append(end_date)\n    if rule_filter:\n        query += " AND sorting_rule = ?"\n        params.append(rule_filter)\n\n    cursor.execute(query, params)\n    rows = cursor.fetchall()\n    conn.close()\n\n    try:\n        with open(export_path, \'w\', newline=\'\') as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerow([\'original_path\', \'destination_path\', \'timestamp\', \'sorting_rule\'])\n            writer.writerows(rows)\n        print(f"Logs exported successfully to {export_path}")\n    except Exception as e:\n        print(f"Failed to export CSV logs: {e}")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x15v*[n\x0f\xb3>\xe3\t\x00\x00\xe3\t\x00\x00\x05\x00\x00\x00ui.pyimport tkinter as tk\nfrom tkinter import ttk, filedialog, messagebox\nimport threading\nfrom csv_exporter import export_logs_to_csv\nfrom database import get_db_connection\nfrom database import log_file_movement\nimport os\n\n# UI for the file organizer\n\ndef start_ui(config, monitor, db_path):\n    root = tk.Tk()\n    root.title("Automated File Organizer")\n\n    # Frame for controls\n    frame = ttk.Frame(root, padding=10)\n    frame.grid(row=0, column=0, sticky=(tk.W, tk.E))\n\n    # Button to manually trigger file organization\n    def manual_organize():\n        threading.Thread(target=monitor.manual_trigger, daemon=True).start()\n        messagebox.showinfo("Manual Trigger", "File organization triggered.")\n\n    organize_button = ttk.Button(frame, text="Organize Files", command=manual_organize)\n    organize_button.grid(row=0, column=0, padx=5, pady=5)\n\n    # Button to export CSV logs\n    def csv_export():\n        # For simplicity, using the export path from config\n        export_path = config.get(\'csv_export\', {}).get(\'export_path\', \'logs_export.csv\')\n        # Optionally, you could add UI elements for filtering\n        export_logs_to_csv(db_path, export_path)\n        messagebox.showinfo("CSV Export", f"CSV logs exported to {export_path}")\n\n    export_button = ttk.Button(frame, text="Export CSV Logs", command=csv_export)\n    export_button.grid(row=0, column=1, padx=5, pady=5)\n\n    # Frame for log display\n    log_frame = ttk.Frame(root, padding=10)\n    log_frame.grid(row=1, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))\n    log_text = tk.Text(log_frame, width=80, height=20)\n    log_text.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n    scrollbar = ttk.Scrollbar(log_frame, orient=\'vertical\', command=log_text.yview)\n    scrollbar.pack(side=tk.RIGHT, fill=\'y\')\n    log_text[\'yscrollcommand\'] = scrollbar.set\n\n    # Function to update log display from the database\n    def update_logs():\n        try:\n            conn = get_db_connection(db_path)\n            cursor = conn.cursor()\n            cursor.execute("SELECT original_path, destination_path, timestamp, sorting_rule FROM file_logs ORDER BY id DESC LIMIT 50")\n            rows = cursor.fetchall()\n            conn.close()\n            log_text.delete(1.0, tk.END)\n            for row in rows:\n                log_text.insert(tk.END, f"{row}\\n")\n        except Exception as e:\n            log_text.insert(tk.END, f"Error fetching logs: {e}\\n")\n        # Schedule next update after 5 seconds\n        root.after(5000, update_logs)\n\n    update_logs()\n\n    root.mainloop()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x15v*[\\\xa0\xcf\x08\x8b\x01\x00\x00\x8b\x01\x00\x00\x10\x00\x00\x00inputs/goals.txtDevelop an automated file organizer that sorts files into folders based on type or creation date.\nThe result should be a functional application with a UI, so if necessary, create required config files.\nFeatures:\n- Monitor a specified directory for new files\n- Move files into organized folders based on rules\n- Store logs of file movements in a database\n- Export file organization reports as CSVPK\x03\x04\x14\x00\x00\x00\x00\x00\x15v*[1OT\xd1\x7f\x00\x00\x00\x7f\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtThe system must provide a reasonable performance.\nTechnology stack: Use Python, SQLite3, and the standard library (os, shutil).PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x15v*[\xb2\x1a\xc6::\x03\x00\x00:\x03\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x15v*[/\xa5\x11\x15\x9e\x03\x00\x00\x9e\x03\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01_\x03\x00\x00config.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x15v*[y\x17W\xa6d\x07\x00\x00d\x07\x00\x00\x0f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01$\x07\x00\x00file_monitor.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x15v*[\xf0n<\x97\x89\x07\x00\x00\x89\x07\x00\x00\x0e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xb5\x0e\x00\x00file_sorter.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x15v*[\x98C)\x05I\x05\x00\x00I\x05\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01j\x16\x00\x00database.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x15v*[\x955\xc9,\xce\x04\x00\x00\xce\x04\x00\x00\x0f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xdc\x1b\x00\x00csv_exporter.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x15v*[n\x0f\xb3>\xe3\t\x00\x00\xe3\t\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xd7 \x00\x00ui.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x15v*[\\\xa0\xcf\x08\x8b\x01\x00\x00\x8b\x01\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xdd*\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x15v*[1OT\xd1\x7f\x00\x00\x00\x7f\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x96,\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\t\x00\t\x00\x10\x02\x00\x00I-\x00\x00\x00\x00'