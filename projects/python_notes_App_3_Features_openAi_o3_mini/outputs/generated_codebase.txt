b'PK\x03\x04\x14\x00\x00\x00\x00\x00\xafp2[\rd\xee\xca\x18\x01\x00\x00\x18\x01\x00\x00\t\x00\x00\x00config.pyimport os\n\n# Base directory for the application\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\n\n# Path to the SQLite database file\nDB_PATH = os.path.join(BASE_DIR, "notes.db")\n\n# Default path for JSON export/import\nEXPORT_PATH = os.path.join(BASE_DIR, "notes_export.json")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xafp2[\r\xaf\x03\xc9O\x03\x00\x00O\x03\x00\x00\x07\x00\x00\x00note.pyfrom dataclasses import dataclass, asdict\nfrom datetime import datetime\n\n@dataclass\nclass Note:\n    id: int = None  # Autogenerated by the database\n    title: str = ""\n    content: str = ""\n    category: str = ""\n    tags: str = ""  # Comma-separated tags\n    created_at: str = None\n    updated_at: str = None\n\n    def to_dict(self):\n        return asdict(self)\n\n    @staticmethod\n    def from_dict(data: dict):\n        return Note(\n            id=data.get(\'id\'),\n            title=data.get(\'title\', \'\'),\n            content=data.get(\'content\', \'\'),\n            category=data.get(\'category\', \'\'),\n            tags=data.get(\'tags\', \'\'),\n            created_at=data.get(\'created_at\'),\n            updated_at=data.get(\'updated_at\')\n        )\n\n    @staticmethod\n    def current_timestamp():\n        return datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xafp2[\xbd\xb07\xda\xd5\x0e\x00\x00\xd5\x0e\x00\x00\x0b\x00\x00\x00database.pyimport sqlite3\nfrom note import Note\nfrom config import DB_PATH\n\nclass NoteDatabase:\n    def __init__(self, db_path=DB_PATH):\n        self.connection = sqlite3.connect(db_path)\n        self.connection.row_factory = sqlite3.Row\n        self.create_table()\n\n    def create_table(self):\n        cursor = self.connection.cursor()\n        cursor.execute(\'\'\'\n            CREATE TABLE IF NOT EXISTS notes (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                content TEXT NOT NULL,\n                category TEXT,\n                tags TEXT,\n                created_at TEXT,\n                updated_at TEXT\n            )\n        \'\'\')\n        self.connection.commit()\n\n    def add_note(self, note: Note):\n        cursor = self.connection.cursor()\n        note.created_at = Note.current_timestamp()\n        note.updated_at = note.created_at\n        cursor.execute(\'\'\'\n            INSERT INTO notes (title, content, category, tags, created_at, updated_at)\n            VALUES (?, ?, ?, ?, ?, ?)\n        \'\'\', (note.title, note.content, note.category, note.tags, note.created_at, note.updated_at))\n        self.connection.commit()\n        note.id = cursor.lastrowid\n        return note\n\n    def get_all_notes(self):\n        cursor = self.connection.cursor()\n        cursor.execute(\'SELECT * FROM notes ORDER BY created_at DESC\')\n        rows = cursor.fetchall()\n        notes = []\n        for row in rows:\n            note = Note(\n                id=row[\'id\'],\n                title=row[\'title\'],\n                content=row[\'content\'],\n                category=row[\'category\'],\n                tags=row[\'tags\'],\n                created_at=row[\'created_at\'],\n                updated_at=row[\'updated_at\']\n            )\n            notes.append(note)\n        return notes\n\n    def get_note_by_id(self, note_id):\n        cursor = self.connection.cursor()\n        cursor.execute(\'SELECT * FROM notes WHERE id = ?\', (note_id,))\n        row = cursor.fetchone()\n        if row:\n            return Note(\n                id=row[\'id\'],\n                title=row[\'title\'],\n                content=row[\'content\'],\n                category=row[\'category\'],\n                tags=row[\'tags\'],\n                created_at=row[\'created_at\'],\n                updated_at=row[\'updated_at\']\n            )\n        return None\n\n    def update_note(self, note: Note):\n        cursor = self.connection.cursor()\n        note.updated_at = Note.current_timestamp()\n        cursor.execute(\'\'\'\n            UPDATE notes\n            SET title = ?, content = ?, category = ?, tags = ?, updated_at = ?\n            WHERE id = ?\n        \'\'\', (note.title, note.content, note.category, note.tags, note.updated_at, note.id))\n        self.connection.commit()\n        return note\n\n    def delete_note(self, note_id):\n        cursor = self.connection.cursor()\n        cursor.execute(\'DELETE FROM notes WHERE id = ?\', (note_id,))\n        self.connection.commit()\n\n    def search_notes(self, keyword):\n        keyword = f"%{keyword}%"\n        cursor = self.connection.cursor()\n        cursor.execute(\'\'\'\n            SELECT * FROM notes\n            WHERE title LIKE ? OR content LIKE ? OR category LIKE ? OR tags LIKE ?\n            ORDER BY created_at DESC\n        \'\'\', (keyword, keyword, keyword, keyword))\n        rows = cursor.fetchall()\n        notes = []\n        for row in rows:\n            note = Note(\n                id=row[\'id\'],\n                title=row[\'title\'],\n                content=row[\'content\'],\n                category=row[\'category\'],\n                tags=row[\'tags\'],\n                created_at=row[\'created_at\'],\n                updated_at=row[\'updated_at\']\n            )\n            notes.append(note)\n        return notes\n\n    def close(self):\n        self.connection.close()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xafp2[\xa4bC\rR\x03\x00\x00R\x03\x00\x00\x0b\x00\x00\x00exporter.pyimport json\nfrom note import Note\nfrom config import EXPORT_PATH\n\n\ndef export_notes(notes, file_path=EXPORT_PATH):\n    """\n    Export a list of Note objects to a JSON file.\n    """\n    data = [note.to_dict() for note in notes]\n    with open(file_path, \'w\', encoding=\'utf-8\') as f:\n        json.dump(data, f, indent=4)\n    print(f"Exported {len(notes)} notes to {file_path}")\n\n\ndef import_notes(file_path=EXPORT_PATH):\n    """\n    Import notes from a JSON file and return a list of Note objects.\n    """\n    notes = []\n    try:\n        with open(file_path, \'r\', encoding=\'utf-8\') as f:\n            data = json.load(f)\n            for item in data:\n                notes.append(Note.from_dict(item))\n        print(f"Imported {len(notes)} notes from {file_path}")\n    except Exception as e:\n        print(f"Error importing notes: {e}")\n    return notes\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xafp2[\x93\xe3\xa2\x885\x1d\x00\x005\x1d\x00\x00\x05\x00\x00\x00ui.pyimport tkinter as tk\nfrom tkinter import ttk, messagebox\nfrom note import Note\nfrom database import NoteDatabase\nfrom exporter import export_notes, import_notes\n\n\nclass NoteAppUI:\n    def __init__(self, root):\n        self.root = root\n        self.root.title("Note Taking App")\n        self.db = NoteDatabase()\n\n        self.create_widgets()\n        self.populate_notes()\n\n    def create_widgets(self):\n        # Search Frame\n        search_frame = ttk.Frame(self.root)\n        search_frame.pack(fill=tk.X, padx=10, pady=5)\n        ttk.Label(search_frame, text="Search:").pack(side=tk.LEFT)\n        self.search_var = tk.StringVar()\n        search_entry = ttk.Entry(search_frame, textvariable=self.search_var)\n        search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)\n        ttk.Button(search_frame, text="Search", command=self.search_notes).pack(side=tk.LEFT, padx=5)\n        ttk.Button(search_frame, text="Reset", command=self.populate_notes).pack(side=tk.LEFT)\n\n        # Main Frame\n        main_frame = ttk.Frame(self.root)\n        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)\n\n        # List of Notes\n        self.notes_listbox = tk.Listbox(main_frame)\n        self.notes_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n        self.notes_listbox.bind(\'<<ListboxSelect>>\', self.on_note_select)\n\n        # Button Frame\n        button_frame = ttk.Frame(main_frame)\n        button_frame.pack(side=tk.RIGHT, fill=tk.Y, padx=5)\n        ttk.Button(button_frame, text="New Note", command=self.new_note).pack(fill=tk.X, pady=2)\n        ttk.Button(button_frame, text="Edit Note", command=self.edit_note).pack(fill=tk.X, pady=2)\n        ttk.Button(button_frame, text="Delete Note", command=self.delete_note).pack(fill=tk.X, pady=2)\n        ttk.Button(button_frame, text="Export Notes", command=self.export_notes_ui).pack(fill=tk.X, pady=2)\n        ttk.Button(button_frame, text="Import Notes", command=self.import_notes_ui).pack(fill=tk.X, pady=2)\n\n        # Note Detail Frame\n        self.detail_frame = ttk.Frame(self.root)\n        self.detail_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)\n\n        ttk.Label(self.detail_frame, text="Title:").grid(row=0, column=0, sticky=tk.W)\n        self.title_var = tk.StringVar()\n        self.title_entry = ttk.Entry(self.detail_frame, textvariable=self.title_var, width=50)\n        self.title_entry.grid(row=0, column=1, sticky=tk.W)\n\n        ttk.Label(self.detail_frame, text="Category:").grid(row=1, column=0, sticky=tk.W)\n        self.category_var = tk.StringVar()\n        self.category_entry = ttk.Entry(self.detail_frame, textvariable=self.category_var, width=50)\n        self.category_entry.grid(row=1, column=1, sticky=tk.W)\n\n        ttk.Label(self.detail_frame, text="Tags (comma separated):").grid(row=2, column=0, sticky=tk.W)\n        self.tags_var = tk.StringVar()\n        self.tags_entry = ttk.Entry(self.detail_frame, textvariable=self.tags_var, width=50)\n        self.tags_entry.grid(row=2, column=1, sticky=tk.W)\n\n        ttk.Label(self.detail_frame, text="Content:").grid(row=3, column=0, sticky=tk.NW)\n        self.content_text = tk.Text(self.detail_frame, width=50, height=10)\n        self.content_text.grid(row=3, column=1, sticky=tk.W)\n\n        # Save Button\n        self.save_button = ttk.Button(self.detail_frame, text="Save Note", command=self.save_note)\n        self.save_button.grid(row=4, column=1, sticky=tk.E, pady=5)\n\n        # Currently selected note id\n        self.current_note_id = None\n\n    def populate_notes(self):\n        self.notes_listbox.delete(0, tk.END)\n        self.notes = self.db.get_all_notes()\n        for note in self.notes:\n            display_text = f"{note.title} - {note.created_at}"\n            self.notes_listbox.insert(tk.END, display_text)\n        # Clear detail form\n        self.clear_form()\n\n    def search_notes(self):\n        keyword = self.search_var.get()\n        self.notes_listbox.delete(0, tk.END)\n        self.notes = self.db.search_notes(keyword)\n        for note in self.notes:\n            display_text = f"{note.title} - {note.created_at}"\n            self.notes_listbox.insert(tk.END, display_text)\n        self.clear_form()\n\n    def on_note_select(self, event):\n        selection = self.notes_listbox.curselection()\n        if selection:\n            index = selection[0]\n            note = self.notes[index]\n            self.populate_form(note)\n\n    def populate_form(self, note):\n        self.current_note_id = note.id\n        self.title_var.set(note.title)\n        self.category_var.set(note.category)\n        self.tags_var.set(note.tags)\n        self.content_text.delete(1.0, tk.END)\n        self.content_text.insert(tk.END, note.content)\n\n    def clear_form(self):\n        self.current_note_id = None\n        self.title_var.set("")\n        self.category_var.set("")\n        self.tags_var.set("")\n        self.content_text.delete(1.0, tk.END)\n\n    def new_note(self):\n        self.clear_form()\n\n    def save_note(self):\n        title = self.title_var.get()\n        content = self.content_text.get(1.0, tk.END).strip()\n        category = self.category_var.get()\n        tags = self.tags_var.get()\n\n        if not title or not content:\n            messagebox.showerror("Error", "Title and Content are required.")\n            return\n\n        if self.current_note_id:\n            # Update existing note\n            note = self.db.get_note_by_id(self.current_note_id)\n            note.title = title\n            note.content = content\n            note.category = category\n            note.tags = tags\n            self.db.update_note(note)\n            messagebox.showinfo("Info", "Note updated successfully.")\n        else:\n            # Create new note\n            note = Note(title=title, content=content, category=category, tags=tags)\n            self.db.add_note(note)\n            messagebox.showinfo("Info", "Note created successfully.")\n\n        self.populate_notes()\n\n    def edit_note(self):\n        selection = self.notes_listbox.curselection()\n        if not selection:\n            messagebox.showerror("Error", "Please select a note to edit.")\n            return\n        # Form is already populated via on_note_select\n        messagebox.showinfo("Info", "Edit the fields and click \'Save Note\'.")\n\n    def delete_note(self):\n        selection = self.notes_listbox.curselection()\n        if not selection:\n            messagebox.showerror("Error", "Please select a note to delete.")\n            return\n        index = selection[0]\n        note = self.notes[index]\n        confirm = messagebox.askyesno("Confirm Delete", f"Are you sure you want to delete note: {note.title}?")\n        if confirm:\n            self.db.delete_note(note.id)\n            messagebox.showinfo("Info", "Note deleted successfully.")\n            self.populate_notes()\n\n    def export_notes_ui(self):\n        notes = self.db.get_all_notes()\n        export_notes(notes)\n        messagebox.showinfo("Export", "Notes exported successfully.")\n\n    def import_notes_ui(self):\n        imported_notes = import_notes()\n        for note in imported_notes:\n            # Only add if the note doesn\'t already exist (simple check: by title and creation time)\n            existing = self.db.search_notes(note.title)\n            if not existing:\n                self.db.add_note(note)\n        messagebox.showinfo("Import", "Notes imported successfully.")\n        self.populate_notes()\n\n    def on_close(self):\n        self.db.close()\n        self.root.destroy()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xafp2[\xeaD\xc7\xd4\xd9\x00\x00\x00\xd9\x00\x00\x00\x07\x00\x00\x00main.pyimport tkinter as tk\nfrom ui import NoteAppUI\n\n\ndef main():\n    root = tk.Tk()\n    app = NoteAppUI(root)\n    root.protocol("WM_DELETE_WINDOW", app.on_close)\n    root.mainloop()\n\n\nif __name__ == "__main__":\n    main()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xafp2[\xcay\xbbt\x9b\t\x00\x00\x9b\t\x00\x00\x08\x00\x00\x00tests.pyimport unittest\nimport os\nimport json\nfrom note import Note\nfrom database import NoteDatabase\nfrom exporter import export_notes, import_notes\nfrom config import DB_PATH, EXPORT_PATH\n\n\nclass TestNoteDatabase(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        # Use an in-memory database for testing\n        cls.db = NoteDatabase(":memory:")\n\n    def test_add_and_get_note(self):\n        note = Note(title="Test Note", content="Content of test note", category="Test", tags="unit,test")\n        inserted = self.db.add_note(note)\n        self.assertIsNotNone(inserted.id)\n\n        fetched = self.db.get_note_by_id(inserted.id)\n        self.assertEqual(fetched.title, "Test Note")\n\n    def test_update_note(self):\n        note = Note(title="Original Title", content="Original Content")\n        inserted = self.db.add_note(note)\n        inserted.title = "Updated Title"\n        self.db.update_note(inserted)\n        updated = self.db.get_note_by_id(inserted.id)\n        self.assertEqual(updated.title, "Updated Title")\n\n    def test_delete_note(self):\n        note = Note(title="To be deleted", content="Some content")\n        inserted = self.db.add_note(note)\n        self.db.delete_note(inserted.id)\n        deleted = self.db.get_note_by_id(inserted.id)\n        self.assertIsNone(deleted)\n\n    def test_search_notes(self):\n        note = Note(title="UniqueTitle123", content="Content")\n        self.db.add_note(note)\n        results = self.db.search_notes("UniqueTitle123")\n        self.assertTrue(any(n.title == "UniqueTitle123" for n in results))\n\n\nclass TestExporter(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.db = NoteDatabase(":memory:")\n        cls.note = Note(title="Export Test", content="Export Content")\n        cls.db.add_note(cls.note)\n        cls.export_file = EXPORT_PATH\n\n    def test_export_notes(self):\n        notes = self.db.get_all_notes()\n        export_notes(notes, self.export_file)\n        self.assertTrue(os.path.exists(self.export_file))\n\n    def test_import_notes(self):\n        # First export a note\n        notes = self.db.get_all_notes()\n        export_notes(notes, self.export_file)\n        # Now import\n        imported = import_notes(self.export_file)\n        self.assertGreaterEqual(len(imported), 1)\n\n    @classmethod\n    def tearDownClass(cls):\n        if os.path.exists(cls.export_file):\n            os.remove(cls.export_file)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xafp2[\x10\xb3\xb5\x8as\x02\x00\x00s\x02\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\n- Store notes locally in a SQLite database\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nAdd support for note categories and tags:\n- Implement a search function for notes\n- Store note metadata (timestamps, tags, categories)\n- Export and import notes as JSON files\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00\xafp2[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xafp2[\rd\xee\xca\x18\x01\x00\x00\x18\x01\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00config.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xafp2[\r\xaf\x03\xc9O\x03\x00\x00O\x03\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01?\x01\x00\x00note.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xafp2[\xbd\xb07\xda\xd5\x0e\x00\x00\xd5\x0e\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xb3\x04\x00\x00database.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xafp2[\xa4bC\rR\x03\x00\x00R\x03\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xb1\x13\x00\x00exporter.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xafp2[\x93\xe3\xa2\x885\x1d\x00\x005\x1d\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01,\x17\x00\x00ui.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xafp2[\xeaD\xc7\xd4\xd9\x00\x00\x00\xd9\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x844\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xafp2[\xcay\xbbt\x9b\t\x00\x00\x9b\t\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x825\x00\x00tests.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xafp2[\x10\xb3\xb5\x8as\x02\x00\x00s\x02\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01C?\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xafp2[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xe4A\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\t\x00\t\x00\xfe\x01\x00\x00AB\x00\x00\x00\x00'