b'PK\x03\x04\x14\x00\x00\x00\x00\x00\x18a\x1b[\xa6p]\x0c\'\x05\x00\x00\'\x05\x00\x00\t\x00\x00\x00config.pyimport numpy as np\n\n# Configuration Manager for simulation parameters\n\nclass Config:\n    # Gravitational constant in SI units: m^3 kg^-1 s^-2\n    G = 6.67430e-11\n\n    # Default time step (seconds)\n    TIME_STEP = 1.0\n\n    # Simulation mode: \'real-time\' or \'accelerated\'\n    MODE = \'real-time\'\n\n    # Integration method: \'euler\' for fast/less accurate, \'rk4\' for accurate simulation\n    INTEGRATION_METHOD = \'rk4\'\n\n    # Default simulation window size (for GUI rendering)\n    WINDOW_WIDTH = 800\n    WINDOW_HEIGHT = 600\n\n    # Colors (RGB)\n    BG_COLOR = (0, 0, 0)\n    BODY_COLOR = (255, 255, 255)\n    TRAIL_COLOR = (0, 255, 0)\n    TEXT_COLOR = (255, 255, 0)\n\n    # Default bodies configuration. Each body is represented as a dict:\n    # \'mass\': mass in kg, \'pos\': np.array([x, y]) in meters, \'vel\': np.array([vx, vy]) in m/s.\n    BODY1 = {\n        \'mass\': 5.972e24,  # Earth mass\n        \'pos\': np.array([0.0, 0.0]),\n        \'vel\': np.array([0.0, 0.0])\n    }\n\n    BODY2 = {\n        \'mass\': 7.348e22,  # Moon mass\n        \'pos\': np.array([384400000.0, 0.0]),  # distance from Earth\n        \'vel\': np.array([0.0, 1022.0])  # orbital speed of the Moon around Earth\n    }\n\n    # Scaling factor for rendering (to convert meters to pixels)\n    SCALE = 1e-6\n\n    # Maximum length of trail to display\n    MAX_TRAIL_LENGTH = 100\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x18a\x1b[.\xd2\xadd\xee\x06\x00\x00\xee\x06\x00\x00\x0f\x00\x00\x00data_logging.pyimport csv\nimport json\n\nclass DataLogger:\n    """Manages simulation state logging and data export."""\n\n    def __init__(self):\n        # Use an in-memory buffer to store simulation states\n        self.logs = []\n\n    def log_state(self, time, bodies):\n        """Log the simulation state for a given time stamp.\n        bodies: list of dictionaries, each with keys: \'pos\', \'vel\', \'mass\'\n        """\n        state = {\n            \'time\': time,\n            \'bodies\': [\n                {\n                    \'mass\': body[\'mass\'],\n                    \'pos\': body[\'pos\'].tolist(),\n                    \'vel\': body[\'vel\'].tolist()\n                } for body in bodies\n            ]\n        }\n        self.logs.append(state)\n\n    def export_to_csv(self, filename):\n        """Exports logged data to CSV format."""\n        with open(filename, mode=\'w\', newline=\'\') as csvfile:\n            fieldnames = [\'time\', \'body\', \'mass\', \'pos_x\', \'pos_y\', \'vel_x\', \'vel_y\']\n            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)\n            writer.writeheader()\n            for entry in self.logs:\n                time_stamp = entry[\'time\']\n                for i, body in enumerate(entry[\'bodies\']):\n                    writer.writerow({\n                        \'time\': time_stamp,\n                        \'body\': f\'body{i+1}\',\n                        \'mass\': body[\'mass\'],\n                        \'pos_x\': body[\'pos\'][0],\n                        \'pos_y\': body[\'pos\'][1],\n                        \'vel_x\': body[\'vel\'][0],\n                        \'vel_y\': body[\'vel\'][1]\n                    })\n\n    def export_to_json(self, filename):\n        """Exports logged data to JSON format."""\n        with open(filename, \'w\') as jsonfile:\n            json.dump(self.logs, jsonfile, indent=4)\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x18a\x1b[/\x80\xd9d\xe5\x0c\x00\x00\xe5\x0c\x00\x00\x18\x00\x00\x00numerical_integration.pyimport numpy as np\n\ndef euler_integration(bodies, dt, G):\n    """Perform one integration step using Euler\'s method.\n\n    bodies: list of dicts, each with keys \'mass\', \'pos\' (np.array), \'vel\' (np.array)\n    dt: time step\n    G: gravitational constant\n\n    Returns new state of bodies.\n    """\n    # Calculate accelerations for two-body problem\n    b1, b2 = bodies[0], bodies[1]\n    r_vec = b2[\'pos\'] - b1[\'pos\']\n    r = np.linalg.norm(r_vec) + 1e-10  # avoid divide by zero\n    direction = r_vec / r\n\n    # acceleration on body1 due to body2\na1 = G * b2[\'mass\'] / (r ** 2) * direction\n    # acceleration on body2 due to body1\n    a2 = G * b1[\'mass\'] / (r ** 2) * (-direction)\n\n    new_bodies = []\n    for body, accel in zip(bodies, [a1, a2]):\n        new_vel = body[\'vel\'] + accel * dt\n        new_pos = body[\'pos\'] + body[\'vel\'] * dt\n        # Update trail: accumulate past positions\n        trail = body.get(\'trail\', [])\n        trail.append(new_pos.copy())\n        if len(trail) > body.get(\'max_trail_length\', 100):\n            trail.pop(0)\n        new_body = {\n            \'mass\': body[\'mass\'],\n            \'pos\': new_pos,\n            \'vel\': new_vel,\n            \'trail\': trail,\n            \'max_trail_length\': body.get(\'max_trail_length\', 100)\n        }\n        new_bodies.append(new_body)\n\n    return new_bodies\n\n\ndef rk4_integration(bodies, dt, G):\n    """Perform one integration step using fourth-order Runge-Kutta.\n\n    The state for each body is defined as y = [x, y, vx, vy].\n    """\n    # For two bodies\n    b1, b2 = bodies[0], bodies[1]\n\n    def deriv(y1, y2):\n        """Compute derivatives for two bodies given state y1 and y2.\n           y = [x, y, vx, vy]\n        """\n        pos1 = y1[0:2]\n        vel1 = y1[2:4]\n        pos2 = y2[0:2]\n        vel2 = y2[2:4]\n\n        r_vec = pos2 - pos1\n        r = np.linalg.norm(r_vec) + 1e-10\n        direction = r_vec / r\n        # accelerations\n        a1 = G * b2[\'mass\'] / (r**2) * direction\n        a2 = G * b1[\'mass\'] / (r**2) * (-direction)\n\n        return np.concatenate([vel1, a1]), np.concatenate([vel2, a2])\n\n    # Prepare state vectors\n    y1 = np.concatenate([b1[\'pos\'], b1[\'vel\']])\n    y2 = np.concatenate([b2[\'pos\'], b2[\'vel\']])\n\n    k1_y1, k1_y2 = deriv(y1, y2)\n    k2_y1, k2_y2 = deriv(y1 + 0.5 * dt * k1_y1, y2 + 0.5 * dt * k1_y2)\n    k3_y1, k3_y2 = deriv(y1 + 0.5 * dt * k2_y1, y2 + 0.5 * dt * k2_y2)\n    k4_y1, k4_y2 = deriv(y1 + dt * k3_y1, y2 + dt * k3_y2)\n\n    y1_new = y1 + (dt / 6.0) * (k1_y1 + 2 * k2_y1 + 2 * k3_y1 + k4_y1)\n    y2_new = y2 + (dt / 6.0) * (k1_y2 + 2 * k2_y2 + 2 * k3_y2 + k4_y2)\n\n    # Update trails\n    trail1 = b1.get(\'trail\', [])\n    trail2 = b2.get(\'trail\', [])\n    trail1.append(y1_new[0:2].copy())\n    trail2.append(y2_new[0:2].copy())\n    if len(trail1) > b1.get(\'max_trail_length\', 100):\n        trail1.pop(0)\n    if len(trail2) > b2.get(\'max_trail_length\', 100):\n        trail2.pop(0)\n\n    new_b1 = {\n        \'mass\': b1[\'mass\'],\n        \'pos\': y1_new[0:2],\n        \'vel\': y1_new[2:4],\n        \'trail\': trail1,\n        \'max_trail_length\': b1.get(\'max_trail_length\', 100)\n    }\n    new_b2 = {\n        \'mass\': b2[\'mass\'],\n        \'pos\': y2_new[0:2],\n        \'vel\': y2_new[2:4],\n        \'trail\': trail2,\n        \'max_trail_length\': b2.get(\'max_trail_length\', 100)\n    }\n\n    return [new_b1, new_b2]\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x18a\x1b[\x83\xb1\x81\x1eO\x08\x00\x00O\x08\x00\x00\x11\x00\x00\x00physics_engine.pyimport numpy as np\nfrom config import Config\nfrom numerical_integration import euler_integration, rk4_integration\n\nclass PhysicsEngine:\n    """Handles the physics simulation using Newton\'s law of gravitation and numerical integration."""\n\n    def __init__(self, integration_method=None):\n        # Initialize bodies using configuration\n        self.G = Config.G\n        self.dt = Config.TIME_STEP\n        self.integration_method = integration_method if integration_method else Config.INTEGRATION_METHOD\n\n        # Initialize two bodies. Each body carries a \'trail\' for rendering paths.\n        self.bodies = [\n            {\n                \'mass\': Config.BODY1[\'mass\'],\n                \'pos\': Config.BODY1[\'pos\'].copy(),\n                \'vel\': Config.BODY1[\'vel\'].copy(),\n                \'trail\': [],\n                \'max_trail_length\': Config.MAX_TRAIL_LENGTH\n            },\n            {\n                \'mass\': Config.BODY2[\'mass\'],\n                \'pos\': Config.BODY2[\'pos\'].copy(),\n                \'vel\': Config.BODY2[\'vel\'].copy(),\n                \'trail\': [],\n                \'max_trail_length\': Config.MAX_TRAIL_LENGTH\n            }\n        ]\n\n    def set_integration_method(self, method):\n        """Switch the integration method on the fly."""\n        if method in [\'euler\', \'rk4\']:\n            self.integration_method = method\n        else:\n            raise ValueError(\'Unknown integration method: choose "euler" or "rk4"\')\n\n    def step(self):\n        """Simulate a single time step using the selected numerical integration method."""\n        if self.integration_method == \'euler\':\n            self.bodies = euler_integration(self.bodies, self.dt, self.G)\n        elif self.integration_method == \'rk4\':\n            self.bodies = rk4_integration(self.bodies, self.dt, self.G)\n        else:\n            raise ValueError(\'Invalid integration method set in PhysicsEngine\')\n\n    def get_state(self):\n        """Return the current state of the simulation (bodies data)."""\n        return self.bodies\n\n    def reset(self):\n        """Reset the simulation to initial state as defined in config."""\n        self.__init__()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x18a\x1b[\xdbfW1\xfd\x06\x00\x00\xfd\x06\x00\x00\r\x00\x00\x00simulation.pyimport time\nfrom threading import Thread, Event\nfrom physics_engine import PhysicsEngine\nfrom data_logging import DataLogger\nfrom config import Config\n\nclass SimulationCore:\n    """Encapsulates the simulation loop, time management, and logging."""\n\n    def __init__(self):\n        self.engine = PhysicsEngine()\n        self.logger = DataLogger()\n        self.time_elapsed = 0.0\n        self.is_running = False\n        self.is_paused = False\n        self.dt = Config.TIME_STEP\n        \n        # Event to signal simulation loop to stop\n        self._stop_event = Event()\n\n    def start(self):\n        """Start the simulation loop in a separate thread."""\n        if not self.is_running:\n            self.is_running = True\n            self._stop_event.clear()\n            self.thread = Thread(target=self._run_loop, daemon=True)\n            self.thread.start()\n\n    def _run_loop(self):\n        while not self._stop_event.is_set():\n            if not self.is_paused:\n                # Perform one physics step\n                self.engine.step()\n                self.time_elapsed += self.dt\n                # Log the state\n                self.logger.log_state(self.time_elapsed, self.engine.get_state())\n            time.sleep(0.01)  # sleep briefly to yield execution\n\n    def pause(self):\n        self.is_paused = True\n\n    def resume(self):\n        self.is_paused = False\n\n    def reset(self):\n        self.pause()\n        self.engine.reset()\n        self.time_elapsed = 0.0\n        self.logger.logs = []\n        self.resume()\n\n    def stop(self):\n        self._stop_event.set()\n        self.is_running = False\n\n    def get_state(self):\n        """Expose current state for GUI rendering."""\n        return self.engine.get_state()\n\n    def get_time(self):\n        return self.time_elapsed\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x18a\x1b[V,<\xc7:\x0c\x00\x00:\x0c\x00\x00\x06\x00\x00\x00gui.pyimport pygame\nfrom pygame.locals import QUIT, KEYDOWN, K_SPACE, K_r, K_e, K_k\nfrom config import Config\n\nclass GUI:\n    """Handles the graphical interface, rendering, and user interactions using Pygame."""\n\n    def __init__(self, simulation):\n        pygame.init()\n        self.simulation = simulation\n        self.width = Config.WINDOW_WIDTH\n        self.height = Config.WINDOW_HEIGHT\n        self.screen = pygame.display.set_mode((self.width, self.height))\n        pygame.display.set_caption(\'Two-Body Orbital Simulator\')\n        self.clock = pygame.time.Clock()\n        self.font = pygame.font.SysFont(\'Arial\', 14)\n        \n    def draw(self):\n        # Clear screen\n        self.screen.fill(Config.BG_COLOR)\n        \n        # Get current simulation state\n        bodies = self.simulation.get_state()\n        \n        for body in bodies:\n            # Convert simulation coordinates to screen coordinates\n            pos = body[\'pos\'] * Config.SCALE\n            x = int(pos[0] + self.width/2)\n            y = int(pos[1] + self.height/2)\n            \n            # Draw the body (circle)\n            pygame.draw.circle(self.screen, Config.BODY_COLOR, (x, y), 5)\n            \n            # Draw trail\n            trail = body.get(\'trail\', [])\n            if len(trail) > 1:\n                pts = [ (int(p[0]*Config.SCALE + self.width/2), int(p[1]*Config.SCALE + self.height/2)) for p in trail ]\n                pygame.draw.lines(self.screen, Config.TRAIL_COLOR, False, pts, 2)\n\n        # Render simulation time\n        time_text = self.font.render(f"Time: {self.simulation.get_time():.2f} s", True, Config.TEXT_COLOR)\n        self.screen.blit(time_text, (10, 10))\n        \n        # Render integration method\n        method_text = self.font.render(f"Integration: {self.simulation.engine.integration_method}", True, Config.TEXT_COLOR)\n        self.screen.blit(method_text, (10, 30))\n\n        pygame.display.flip()\n\n    def handle_events(self):\n        """Handle user inputs: start/pause, reset, and switch integration methods."""\n        for event in pygame.event.get():\n            if event.type == QUIT:\n                return False\n\n            if event.type == KEYDOWN:\n                if event.key == K_SPACE:\n                    # Toggle pause/resume\n                    if self.simulation.is_paused:\n                        self.simulation.resume()\n                    else:\n                        self.simulation.pause()\n                if event.key == K_r:\n                    self.simulation.reset()\n                if event.key == K_e:\n                    # Switch to Euler integration\n                    self.simulation.engine.set_integration_method(\'euler\')\n                if event.key == K_k:\n                    # Switch to Runge-Kutta 4 integration\n                    self.simulation.engine.set_integration_method(\'rk4\')\n        return True\n\n    def run(self):\n        """Main GUI loop."""\n        running = True\n        while running:\n            running = self.handle_events()\n            self.draw()\n\n            # Ensure at least 30 frames per second\n            self.clock.tick(30)\n        pygame.quit()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x18a\x1b[\x1f\x9eE#7\x02\x00\x007\x02\x00\x00\x07\x00\x00\x00main.pyfrom simulation import SimulationCore\nfrom gui import GUI\nimport time\n\nif __name__ == \'__main__\':\n    # Initialize simulation core and start simulation thread\n    simulation = SimulationCore()\n    simulation.start()\n\n    # Initialize and run the GUI\n    gui = GUI(simulation)\n    try:\n        gui.run()\n    except KeyboardInterrupt:\n        pass\n    finally:\n        simulation.stop()\n        # Optional: Export simulation log data\n        simulation.logger.export_to_json(\'simulation_log.json\')\n        print(\'Simulation ended. Log exported to simulation_log.json\')\nPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x18a\x1b[\xa6p]\x0c\'\x05\x00\x00\'\x05\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00config.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x18a\x1b[.\xd2\xadd\xee\x06\x00\x00\xee\x06\x00\x00\x0f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01N\x05\x00\x00data_logging.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x18a\x1b[/\x80\xd9d\xe5\x0c\x00\x00\xe5\x0c\x00\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01i\x0c\x00\x00numerical_integration.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x18a\x1b[\x83\xb1\x81\x1eO\x08\x00\x00O\x08\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x84\x19\x00\x00physics_engine.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x18a\x1b[\xdbfW1\xfd\x06\x00\x00\xfd\x06\x00\x00\r\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x02"\x00\x00simulation.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x18a\x1b[V,<\xc7:\x0c\x00\x00:\x0c\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01*)\x00\x00gui.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x18a\x1b[\x1f\x9eE#7\x02\x00\x007\x02\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x885\x00\x00main.pyPK\x05\x06\x00\x00\x00\x00\x07\x00\x07\x00\x9d\x01\x00\x00\xe47\x00\x00\x00\x00'