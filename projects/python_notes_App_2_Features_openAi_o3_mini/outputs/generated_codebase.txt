b'PK\x03\x04\x14\x00\x00\x00\x00\x00\xb1y7[\xc8\xb1e\xee\xf3\x18\x00\x00\xf3\x18\x00\x00\x07\x00\x00\x00main.pyimport tkinter as tk\nfrom tkinter import ttk, messagebox\nimport json\nimport os\nfrom database import init_db, get_all_notes, get_note_by_id, create_note, update_note, delete_note\n\n\nclass NoteApp(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title("Note Taking App")\n        self.geometry("800x600")\n        self.config_data = self.load_config()\n        self.db_path = self.config_data.get("database", "notes.db")\n        self.conn = init_db(self.db_path)\n        self.create_widgets()\n        self.refresh_note_list()\n\n    def load_config(self):\n        config_file = "config.json"\n        if os.path.exists(config_file):\n            with open(config_file, "r") as f:\n                return json.load(f)\n        else:\n            messagebox.showerror("Error", "Configuration file not found!")\n            self.quit()\n            return {}\n\n    def create_widgets(self):\n        main_frame = ttk.Frame(self)\n        main_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n\n        # Left frame: Note list and buttons\n        left_frame = ttk.Frame(main_frame)\n        left_frame.pack(side=tk.LEFT, fill=tk.Y)\n\n        self.note_listbox = tk.Listbox(left_frame, width=40)\n        self.note_listbox.pack(side=tk.TOP, fill=tk.BOTH, expand=True)\n        self.note_listbox.bind(\'<<ListboxSelect>>\', self.on_note_select)\n\n        button_frame = ttk.Frame(left_frame)\n        button_frame.pack(side=tk.TOP, pady=10)\n\n        add_button = ttk.Button(button_frame, text="Add New Note", command=self.add_note)\n        add_button.pack(side=tk.LEFT, padx=5)\n\n        edit_button = ttk.Button(button_frame, text="Edit Note", command=self.edit_note)\n        edit_button.pack(side=tk.LEFT, padx=5)\n\n        delete_button = ttk.Button(button_frame, text="Delete Note", command=self.delete_note)\n        delete_button.pack(side=tk.LEFT, padx=5)\n\n        # Right frame: Note details\n        right_frame = ttk.Frame(main_frame)\n        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)\n        self.note_detail = tk.Text(right_frame, wrap=tk.WORD)\n        self.note_detail.pack(fill=tk.BOTH, expand=True)\n        self.note_detail.config(state=tk.DISABLED)\n\n    def refresh_note_list(self):\n        self.note_listbox.delete(0, tk.END)\n        self.notes = get_all_notes(self.conn)\n        for note in self.notes:\n            # note tuple: (id, title, content, created_timestamp, updated_timestamp)\n            display_text = f"{note[1]} ({note[3]})"\n            self.note_listbox.insert(tk.END, display_text)\n\n        # Clear the note detail pane\n        self.note_detail.config(state=tk.NORMAL)\n        self.note_detail.delete("1.0", tk.END)\n        self.note_detail.config(state=tk.DISABLED)\n\n    def on_note_select(self, event):\n        selection = self.note_listbox.curselection()\n        if selection:\n            index = selection[0]\n            note_id = self.notes[index][0]\n            note = get_note_by_id(self.conn, note_id)\n            if note:\n                self.note_detail.config(state=tk.NORMAL)\n                self.note_detail.delete("1.0", tk.END)\n                info = (\n                    f"Title: {note[1]}\\n"\n                    f"Created: {note[3]}\\n"\n                    f"Updated: {note[4]}\\n\\n"\n                    f"Content:\\n{note[2]}"\n                )\n                self.note_detail.insert(tk.END, info)\n                self.note_detail.config(state=tk.DISABLED)\n\n    def add_note(self):\n        NoteEditor(self, self.conn, mode="add", refresh_callback=self.refresh_note_list)\n\n    def edit_note(self):\n        selection = self.note_listbox.curselection()\n        if not selection:\n            messagebox.showwarning("Warning", "Please select a note to edit.")\n            return\n        index = selection[0]\n        note_id = self.notes[index][0]\n        NoteEditor(self, self.conn, mode="edit", note_id=note_id, refresh_callback=self.refresh_note_list)\n\n    def delete_note(self):\n        selection = self.note_listbox.curselection()\n        if not selection:\n            messagebox.showwarning("Warning", "Please select a note to delete.")\n            return\n        confirm = messagebox.askyesno("Confirm Deletion", "Are you sure you want to delete this note?")\n        if confirm:\n            index = selection[0]\n            note_id = self.notes[index][0]\n            delete_note(self.conn, note_id)\n            self.refresh_note_list()\n\n\nclass NoteEditor(tk.Toplevel):\n    def __init__(self, master, conn, mode, refresh_callback, note_id=None):\n        super().__init__(master)\n        self.conn = conn\n        self.mode = mode  # "add" or "edit"\n        self.refresh_callback = refresh_callback\n        self.note_id = note_id\n        self.title("Add Note" if mode == "add" else "Edit Note")\n        self.geometry("400x300")\n        self.create_widgets()\n        if self.mode == "edit":\n            self.load_note_data()\n\n    def create_widgets(self):\n        frame = ttk.Frame(self)\n        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)\n\n        # Title label and entry\n        title_label = ttk.Label(frame, text="Title:")\n        title_label.pack(anchor=tk.W)\n        self.title_entry = ttk.Entry(frame)\n        self.title_entry.pack(fill=tk.X)\n\n        # Content label and text widget\n        content_label = ttk.Label(frame, text="Content:")\n        content_label.pack(anchor=tk.W, pady=(10, 0))\n        self.content_text = tk.Text(frame, height=10, wrap=tk.WORD)\n        self.content_text.pack(fill=tk.BOTH, expand=True)\n\n        # Save button\n        save_button = ttk.Button(frame, text="Save", command=self.save_note)\n        save_button.pack(pady=10)\n\n    def load_note_data(self):\n        note = get_note_by_id(self.conn, self.note_id)\n        if note:\n            self.title_entry.insert(0, note[1])\n            self.content_text.insert("1.0", note[2])\n\n    def save_note(self):\n        title = self.title_entry.get().strip()\n        content = self.content_text.get("1.0", tk.END).strip()\n        if not title:\n            messagebox.showerror("Error", "Title cannot be empty.")\n            return\n        if self.mode == "add":\n            create_note(self.conn, title, content)\n        elif self.mode == "edit":\n            update_note(self.conn, self.note_id, title, content)\n        self.refresh_callback()\n        self.destroy()\n\n\nif __name__ == "__main__":\n    app = NoteApp()\n    app.mainloop()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb1y7[\xc2\x17\x00\xe6J\x06\x00\x00J\x06\x00\x00\x0b\x00\x00\x00database.pyimport sqlite3\n\n\ndef init_db(db_path):\n    """\n    Initialize the SQLite database. If the notes table does not exist, create it.\n    """\n    conn = sqlite3.connect(db_path)\n    create_table(conn)\n    return conn\n\n\ndef create_table(conn):\n    cursor = conn.cursor()\n    cursor.execute("""\n    CREATE TABLE IF NOT EXISTS notes (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        title TEXT NOT NULL,\n        content TEXT,\n        created_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n    );\n    """)\n    conn.commit()\n\n\ndef get_all_notes(conn):\n    cursor = conn.cursor()\n    cursor.execute("SELECT id, title, content, created_timestamp, updated_timestamp FROM notes ORDER BY created_timestamp DESC")\n    return cursor.fetchall()\n\n\ndef get_note_by_id(conn, note_id):\n    cursor = conn.cursor()\n    cursor.execute("SELECT id, title, content, created_timestamp, updated_timestamp FROM notes WHERE id = ?", (note_id,))\n    return cursor.fetchone()\n\n\ndef create_note(conn, title, content):\n    cursor = conn.cursor()\n    cursor.execute("INSERT INTO notes (title, content) VALUES (?, ?)", (title, content))\n    conn.commit()\n    return cursor.lastrowid\n\n\ndef update_note(conn, note_id, title, content):\n    cursor = conn.cursor()\n    cursor.execute("UPDATE notes SET title = ?, content = ?, updated_timestamp = CURRENT_TIMESTAMP WHERE id = ?",\n                   (title, content, note_id))\n    conn.commit()\n\n\ndef delete_note(conn, note_id):\n    cursor = conn.cursor()\n    cursor.execute("DELETE FROM notes WHERE id = ?", (note_id,))\n    conn.commit()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb1y7[\xb0^P\xe5Z\x00\x00\x00Z\x00\x00\x00\x0b\x00\x00\x00config.json{\n  "database": "notes.db",\n  "app_name": "Note Taking App",\n  "window_size": "800x600"\n}\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb1y7[\xb4\x10\xf2\xfa\x17\x01\x00\x00\x17\x01\x00\x00\n\x00\x00\x00schema.sql-- Schema Definition for the notes table\nCREATE TABLE IF NOT EXISTS notes (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    title TEXT NOT NULL,\n    content TEXT,\n    created_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\n    updated_timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n);\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb1y7[y@0\xef\x81\x01\x00\x00\x81\x01\x00\x00\x08\x00\x00\x00setup.pyfrom setuptools import setup, find_packages\n\nsetup(\n    name="note_taking_app",\n    version="1.0.0",\n    packages=find_packages(),\n    install_requires=[],\n    entry_points={\n        "console_scripts": [\n            "note_taking_app = main:main"\n        ]\n    },\n    author="Your Name",\n    description="A simple note taking app using Python, Tkinter, and SQLite for local storage."\n)\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb1y7[\xf1\x1f\x82hp\x00\x00\x00p\x00\x00\x00\x10\x00\x00\x00requirements.txt# This application requires Python 3.8 or later.\n# Tkinter and sqlite3 are part of the Python standard library.\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb1y7[\x07{\xcc\x00\xc4\x01\x00\x00\xc4\x01\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\n- Store notes locally in a SQLite database\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00\xb1y7[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb1y7[\xc8\xb1e\xee\xf3\x18\x00\x00\xf3\x18\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb1y7[\xc2\x17\x00\xe6J\x06\x00\x00J\x06\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x18\x19\x00\x00database.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb1y7[\xb0^P\xe5Z\x00\x00\x00Z\x00\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x8b\x1f\x00\x00config.jsonPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb1y7[\xb4\x10\xf2\xfa\x17\x01\x00\x00\x17\x01\x00\x00\n\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x0e \x00\x00schema.sqlPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb1y7[y@0\xef\x81\x01\x00\x00\x81\x01\x00\x00\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01M!\x00\x00setup.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb1y7[\xf1\x1f\x82hp\x00\x00\x00p\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xf4"\x00\x00requirements.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb1y7[\x07{\xcc\x00\xc4\x01\x00\x00\xc4\x01\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x92#\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb1y7[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x84%\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\x08\x00\x08\x00\xd5\x01\x00\x00\xe1%\x00\x00\x00\x00'