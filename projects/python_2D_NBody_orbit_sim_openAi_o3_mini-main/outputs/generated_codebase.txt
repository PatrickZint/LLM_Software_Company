b'PK\x03\x04\x14\x00\x00\x00\x00\x00\x16b\x1b[N\xb4\xb4W\r\t\x00\x00\r\t\x00\x00\x07\x00\x00\x00main.pyimport sys\nimport pygame\nimport threading\nimport time\n\nfrom config import load_config\nfrom physics_engine import PhysicsEngine\nfrom integration_strategies import EulerIntegration, VerletIntegration, RungeKuttaIntegration\nfrom visualization import SimulationWindow\nfrom controller import Controller\nfrom logging_module import SimulationLogger\n\n\ndef select_integration_strategy(strategy_name):\n    if strategy_name.lower() == \'euler\':\n        return EulerIntegration()\n    elif strategy_name.lower() == \'verlet\':\n        return VerletIntegration()\n    elif strategy_name.lower() == \'rungekutta\':\n        return RungeKuttaIntegration()\n    else:\n        raise ValueError(f"Unknown integration strategy: {strategy_name}")\n\n\ndef main():\n    # Load and validate configuration\n    config = load_config(\'config.json\')\n\n    # Select integration method based on config\n    integration_method = select_integration_strategy(config.get(\'integration_method\', \'euler\'))\n\n    # Initialize Logger\n    sim_logger = SimulationLogger(config.get(\'log_file\', \'simulation_log.json\'))\n\n    # Initialize Physics Engine with initial bodies and parameters\n    physics = PhysicsEngine(\n        bodies=config.get(\'bodies\', []),\n        time_step=config.get(\'time_step\', 0.01),\n        gravitational_constant=config.get(\'gravitational_constant\', 6.67430e-11),\n        integration_strategy=integration_method,\n        logger=sim_logger\n    )\n\n    # Initialize Visualization\n    pygame.init()\n    window_size = config.get(\'window_size\', [800, 600])\n    simulation_window = SimulationWindow(window_size)\n\n    # Initialize Controller\n    controller = Controller(physics, simulation_window)\n\n    # Start logger thread\n    sim_logger.start()\n\n    # Start simulation in a separate thread\n    simulation_thread = threading.Thread(target=controller.run, daemon=True)\n    simulation_thread.start()\n\n    try:\n        # Main loop for visualization (View)\n        while True:\n            simulation_window.handle_events(controller)\n            simulation_window.render(physics.get_state())\n            pygame.display.flip()\n            time.sleep(1/30)  # Aim for 30 FPS\n    except KeyboardInterrupt:\n        controller.stop()\n    finally:\n        pygame.quit()\n        sim_logger.stop()\n        simulation_thread.join()\n\n\nif __name__ == \'__main__\':\n    main()PK\x03\x04\x14\x00\x00\x00\x00\x00\x16b\x1b[\x93\xa604\x80\x04\x00\x00\x80\x04\x00\x00\t\x00\x00\x00config.pyimport json\nimport os\n\n\ndef load_config(filename):\n    """\n    Loads simulation configuration from a JSON file and validates input values.\n\n    Required keys:\n      - bodies: list of celestial bodies with their properties\n      - time_step: positive float\n      - gravitational_constant: float\n      - integration_method: \'euler\', \'verlet\', or \'rungekutta\'\n      - window_size: [width, height]\n\n    Returns a dictionary with configuration.\n    """\n    if not os.path.isfile(filename):\n        raise FileNotFoundError(f"Configuration file {filename} not found.")\n\n    with open(filename, \'r\') as f:\n        config = json.load(f)\n\n    # Validate time_step\n    if config.get(\'time_step\', 0) <= 0:\n        raise ValueError("time_step must be a positive float.")\n\n    # Validate gravitational constant (should be positive)\n    if config.get(\'gravitational_constant\', 0) <= 0:\n        raise ValueError("gravitational_constant must be a positive float.")\n\n    # Validate bodies\n    for body in config.get(\'bodies\', []):\n        if body.get(\'mass\', -1) < 0:\n            raise ValueError(f"Body {body.get(\'id\', \'unknown\')} has invalid mass.")\n\n    return configPK\x03\x04\x14\x00\x00\x00\x00\x00\x16b\x1b[\xed\xf5,\xd2\x0f\x0f\x00\x00\x0f\x0f\x00\x00\x11\x00\x00\x00physics_engine.pyimport threading\nimport math\n\n\nclass CelestialBody:\n    def __init__(self, id, position, velocity, mass):\n        self.id = id\n        self.position = position  # [x, y]\n        self.velocity = velocity  # [vx, vy]\n        self.mass = mass\n\n    def to_dict(self):\n        return {\n            \'id\': self.id,\n            \'position\': self.position,\n            \'velocity\': self.velocity,\n            \'mass\': self.mass\n        }\n\n\nclass PhysicsEngine:\n    def __init__(self, bodies, time_step, gravitational_constant, integration_strategy, logger):\n        # Convert each body config dict to a CelestialBody instance\n        self.bodies = {}\n        for body in bodies:\n            b = CelestialBody(\n                id=body.get(\'id\'),\n                position=body.get(\'position\', [0.0, 0.0]),\n                velocity=body.get(\'velocity\', [0.0, 0.0]),\n                mass=body.get(\'mass\', 1.0)\n            )\n            self.bodies[b.id] = b\n\n        self.time_step = time_step\n        self.G = gravitational_constant\n        self.integration_strategy = integration_strategy\n        self.lock = threading.Lock()\n        self.running = False\n        self.logger = logger\n        self.current_time = 0.0\n\n    def add_body(self, body_config):\n        with self.lock:\n            b = CelestialBody(\n                id=body_config.get(\'id\'),\n                position=body_config.get(\'position\', [0.0, 0.0]),\n                velocity=body_config.get(\'velocity\', [0.0, 0.0]),\n                mass=body_config.get(\'mass\', 1.0)\n            )\n            self.bodies[b.id] = b\n\n    def remove_body(self, body_id):\n        with self.lock:\n            if body_id in self.bodies:\n                del self.bodies[body_id]\n\n    def compute_forces(self):\n        """\n        Computes gravitational forces between every pair of bodies.\n        Returns a dictionary with key as tuple (id1, id2) and value as force vector [fx, fy].\n        """\n        forces = {}\n        bodies_list = list(self.bodies.values())\n        n = len(bodies_list)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                b1 = bodies_list[i]\n                b2 = bodies_list[j]\n                dx = b2.position[0] - b1.position[0]\n                dy = b2.position[1] - b1.position[1]\n                distance_sq = dx * dx + dy * dy + 1e-10  # Avoid division by zero\n                distance = math.sqrt(distance_sq)\n                force_magnitude = self.G * b1.mass * b2.mass / distance_sq\n                # Force vector components\n                fx = force_magnitude * dx / distance\n                fy = force_magnitude * dy / distance\n                forces[(b1.id, b2.id)] = [fx, fy]\n                forces[(b2.id, b1.id)] = [-fx, -fy]\n        return forces\n\n    def update(self):\n        """\n        Advances the simulation by one time step using the configured integration strategy.\n        """\n        with self.lock:\n            forces = self.compute_forces()\n            # Delegate integration step to the chosen strategy\n            self.integration_strategy.step(self.bodies, forces, self.time_step, self.G)\n            self.current_time += self.time_step\n            if self.logger is not None:\n                # Log current state\n                state = self.get_state()\n                self.logger.log(self.current_time, state, forces)\n\n    def get_state(self):\n        """\n        Returns the current state of the simulation (all bodies as dictionaries).\n        """\n        with self.lock:\n            return {bid: body.to_dict() for bid, body in self.bodies.items()}\n\n    def run(self):\n        self.running = True\n        while self.running:\n            self.update()\n\n    def pause(self):\n        self.running = False\n\n    def resume(self):\n        if not self.running:\n            self.running = True\n\n    def stop(self):\n        self.running = False\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x16b\x1b[CnaM\x08\x13\x00\x00\x08\x13\x00\x00\x19\x00\x00\x00integration_strategies.pyfrom abc import ABC, abstractmethod\nimport math\n\n\nclass IntegrationStrategy(ABC):\n    @abstractmethod\n    def step(self, bodies, forces, time_step, G):\n        pass\n\n\nclass EulerIntegration(IntegrationStrategy):\n    def step(self, bodies, forces, time_step, G):\n        # Simple Euler integration\n        for body in bodies.values():\n            # Sum forces on this body\n            total_force = [0.0, 0.0]\n            for other_id, other_body in bodies.items():\n                if other_id == body.id:\n                    continue\n                # Use the precomputed forces if available\n                key = (body.id, other_id)\n                if key in forces:\n                    f = forces[key]\n                    total_force[0] += f[0]\n                    total_force[1] += f[1]\n            # Acceleration = force / mass\n            ax = total_force[0] / body.mass\n            ay = total_force[1] / body.mass\n            # Update velocity\n            body.velocity[0] += ax * time_step\n            body.velocity[1] += ay * time_step\n            # Update position\n            body.position[0] += body.velocity[0] * time_step\n            body.position[1] += body.velocity[1] * time_step\n\n\nclass VerletIntegration(IntegrationStrategy):\n    def __init__(self):\n        self.previous_positions = {}\n\n    def step(self, bodies, forces, time_step, G):\n        # Verlet integration method\n        for body in bodies.values():\n            # Save current position\n            current_position = body.position.copy()\n            # Sum forces\n            total_force = [0.0, 0.0]\n            for other_id, other_body in bodies.items():\n                if other_id == body.id:\n                    continue\n                key = (body.id, other_id)\n                if key in forces:\n                    f = forces[key]\n                    total_force[0] += f[0]\n                    total_force[1] += f[1]\n            # Acceleration = force / mass\n            ax = total_force[0] / body.mass\n            ay = total_force[1] / body.mass\n            if body.id not in self.previous_positions:\n                # For the first time step, use Euler to initialize\n                new_x = body.position[0] + body.velocity[0] * time_step + 0.5 * ax * time_step * time_step\n                new_y = body.position[1] + body.velocity[1] * time_step + 0.5 * ay * time_step * time_step\n            else:\n                new_x = 2 * body.position[0] - self.previous_positions[body.id][0] + ax * time_step * time_step\n                new_y = 2 * body.position[1] - self.previous_positions[body.id][1] + ay * time_step * time_step\n            # Update velocity estimate\n            body.velocity[0] = (new_x - self.previous_positions.get(body.id, body.position)[0]) / (2 * time_step)\n            body.velocity[1] = (new_y - self.previous_positions.get(body.id, body.position)[1]) / (2 * time_step)\n\n            self.previous_positions[body.id] = current_position\n            body.position[0] = new_x\n            body.position[1] = new_y\n\n\nclass RungeKuttaIntegration(IntegrationStrategy):\n    def step(self, bodies, forces, time_step, G):\n        # A simplified RK4 integration for updating positions and velocities\n        # Note: In a full implementation, you would calculate intermediate slopes\n        for body in bodies.values():\n            # Sum forces on body\n            total_force = [0.0, 0.0]\n            for other_id, other_body in bodies.items():\n                if other_id == body.id:\n                    continue\n                key = (body.id, other_id)\n                if key in forces:\n                    f = forces[key]\n                    total_force[0] += f[0]\n                    total_force[1] += f[1]\n            ax = total_force[0] / body.mass\n            ay = total_force[1] / body.mass\n            # RK4 intermediate calculations - simplified version\n            k1_vx = ax\n            k1_vy = ay\n            k1_x = body.velocity[0]\n            k1_y = body.velocity[1]\n\n            k2_vx = ax  # For simplicity, using same acceleration\n            k2_vy = ay\n            k2_x = body.velocity[0] + 0.5 * k1_vx * time_step\n            k2_y = body.velocity[1] + 0.5 * k1_vy * time_step\n\n            k3_vx = ax\n            k3_vy = ay\n            k3_x = body.velocity[0] + 0.5 * k2_vx * time_step\n            k3_y = body.velocity[1] + 0.5 * k2_vy * time_step\n\n            k4_vx = ax\n            k4_vy = ay\n            k4_x = body.velocity[0] + k3_vx * time_step\n            k4_y = body.velocity[1] + k3_vy * time_step\n\n            body.velocity[0] += (time_step / 6) * (k1_vx + 2*k2_vx + 2*k3_vx + k4_vx)\n            body.velocity[1] += (time_step / 6) * (k1_vy + 2*k2_vy + 2*k3_vy + k4_vy)\n            \n            body.position[0] += (time_step / 6) * (k1_x + 2*k2_x + 2*k3_x + k4_x)\n            body.position[1] += (time_step / 6) * (k1_y + 2*k2_y + 2*k3_y + k4_y)\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x16b\x1b[\x9cMa\xcb\xa7\x06\x00\x00\xa7\x06\x00\x00\x10\x00\x00\x00visualization.pyimport pygame\n\n\nclass SimulationWindow:\n    def __init__(self, window_size):\n        self.width, self.height = window_size\n        self.screen = pygame.display.set_mode((self.width, self.height))\n        pygame.display.set_caption(\'N-Body Simulation\')\n        self.font = pygame.font.SysFont(\'Arial\', 14)\n\n    def render(self, state):\n        # Clear the screen\n        self.screen.fill((0, 0, 0))\n\n        # Render each celestial body\n        for body_id, body in state.items():\n            x, y = int(body[\'position\'][0]), int(body[\'position\'][1])\n            # Scale radius by mass (simple approach)\n            radius = max(2, int(body[\'mass\'] ** 0.33))\n            color = (255, 255, 255)  # white\n            pygame.draw.circle(self.screen, color, (x, y), radius)\n\n        # Optionally, display extra info (e.g., FPS, instructions) here\n        info_text = self.font.render(\'Press SPACE to start/pause, ESC to quit\', True, (200, 200, 200))\n        self.screen.blit(info_text, (10, 10))\n\n    def handle_events(self, controller):\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                controller.stop()\n                pygame.quit()\n                exit(0)\n            elif event.type == pygame.KEYDOWN:\n                if event.key == pygame.K_ESCAPE:\n                    controller.stop()\n                    pygame.quit()\n                    exit(0)\n                elif event.key == pygame.K_SPACE:\n                    if controller.is_running():\n                        controller.pause()\n                    else:\n                        controller.resume()\n                # Additional key events for zoom, pan or adding bodies could be added here\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x16b\x1b[\xf5\x16^HE\x05\x00\x00E\x05\x00\x00\r\x00\x00\x00controller.pyimport threading\nimport time\n\n\nclass Controller:\n    def __init__(self, physics_engine, simulation_window):\n        self.physics_engine = physics_engine\n        self.simulation_window = simulation_window\n        self._running = False\n        self.lock = threading.Lock()\n\n    def run(self):\n        self._running = True\n        # Run the simulation loop in this thread\n        while self._running:\n            self.physics_engine.update()\n            time.sleep(self.physics_engine.time_step)  # Regulate simulation speed\n\n    def pause(self):\n        with self.lock:\n            self.physics_engine.pause()\n            self._running = False\n\n    def resume(self):\n        with self.lock:\n            if not self._running:\n                self.physics_engine.resume()\n                # Restart the simulation loop in a new thread\n                threading.Thread(target=self.run, daemon=True).start()\n                self._running = True\n\n    def stop(self):\n        with self.lock:\n            self.physics_engine.stop()\n            self._running = False\n\n    def is_running(self):\n        return self._running\n\n    # Methods to dispatch runtime events e.g., add/remove body\n    def add_body(self, body_config):\n        self.physics_engine.add_body(body_config)\n\n    def remove_body(self, body_id):\n        self.physics_engine.remove_body(body_id)\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x16b\x1b[\xcf~\\\xa97\x05\x00\x007\x05\x00\x00\x11\x00\x00\x00logging_module.pyimport json\nimport threading\nimport time\n\n\nclass SimulationLogger:\n    def __init__(self, log_file):\n        self.log_file = log_file\n        self.entries = []\n        self.running = False\n        self.lock = threading.Lock()\n        self.thread = None\n\n    def log(self, simulation_time, state, forces):\n        entry = {\n            \'time\': simulation_time,\n            \'state\': state,\n            \'forces\': {f\'{k[0]}-{k[1]}\': v for k, v in forces.items()}\n        }\n        with self.lock:\n            self.entries.append(entry)\n\n    def _write_logs(self):\n        while self.running:\n            time.sleep(1)  # Write every second; adjust as needed\n            with self.lock:\n                if self.entries:\n                    try:\n                        with open(self.log_file, \'a\') as f:\n                            for entry in self.entries:\n                                f.write(json.dumps(entry) + \'\\n\')\n                        self.entries = []\n                    except Exception as e:\n                        print(f"Error writing log: {e}")\n\n    def start(self):\n        self.running = True\n        self.thread = threading.Thread(target=self._write_logs, daemon=True)\n        self.thread.start()\n\n    def stop(self):\n        self.running = False\n        if self.thread is not None:\n            self.thread.join()\nPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x16b\x1b[N\xb4\xb4W\r\t\x00\x00\r\t\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x16b\x1b[\x93\xa604\x80\x04\x00\x00\x80\x04\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x012\t\x00\x00config.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x16b\x1b[\xed\xf5,\xd2\x0f\x0f\x00\x00\x0f\x0f\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xd9\r\x00\x00physics_engine.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x16b\x1b[CnaM\x08\x13\x00\x00\x08\x13\x00\x00\x19\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x17\x1d\x00\x00integration_strategies.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x16b\x1b[\x9cMa\xcb\xa7\x06\x00\x00\xa7\x06\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01V0\x00\x00visualization.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x16b\x1b[\xf5\x16^HE\x05\x00\x00E\x05\x00\x00\r\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01+7\x00\x00controller.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x16b\x1b[\xcf~\\\xa97\x05\x00\x007\x05\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x9b<\x00\x00logging_module.pyPK\x05\x06\x00\x00\x00\x00\x07\x00\x07\x00\xaa\x01\x00\x00\x01B\x00\x00\x00\x00'