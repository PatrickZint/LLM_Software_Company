b'PK\x03\x04\x14\x00\x00\x00\x00\x00\xdbP8[\xa7\t\xe0z\x04\x01\x00\x00\x04\x01\x00\x00\t\x00\x00\x00config.py\'\'\'Configuration module for the Secure Note-Taking Application\'\'\'\n\n# Database configuration\nDB_PATH = "notes.db"\n\n# Encryption configuration\n# Number of iterations for key derivation (PBKDF2)\nENCRYPTION_ITERATIONS = 100000\n\n# Salt size in bytes\nSALT_SIZE = 16\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xdbP8[\xd2\xcc\xe67\x1d\n\x00\x00\x1d\n\x00\x00\x0b\x00\x00\x00database.py\'\'\'Database module: Handles SQLite connection and schema initialization\'\'\' \n\nimport sqlite3\nfrom config import DB_PATH\n\n\ndef get_connection():\n    conn = sqlite3.connect(DB_PATH)\n    conn.row_factory = sqlite3.Row\n    return conn\n\n\ndef init_db():\n    conn = get_connection()\n    cursor = conn.cursor()\n    \n    # Create users table\n    cursor.execute("""\n    CREATE TABLE IF NOT EXISTS users (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        username TEXT UNIQUE NOT NULL,\n        password_hash TEXT NOT NULL,\n        salt BLOB NOT NULL\n    );\n    """)\n    \n    # Create notes table\n    cursor.execute("""\n    CREATE TABLE IF NOT EXISTS notes (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        user_id INTEGER NOT NULL,\n        title TEXT NOT NULL,\n        content BLOB NOT NULL,\n        timestamp TEXT NOT NULL,\n        tags TEXT,\n        categories TEXT,\n        FOREIGN KEY (user_id) REFERENCES users(id)\n    );\n    """)\n    \n    conn.commit()\n    conn.close()\n\n\ndef add_user(username, password_hash, salt):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\n        "INSERT INTO users (username, password_hash, salt) VALUES (?, ?, ?)", \n        (username, password_hash, salt)\n    )\n    conn.commit()\n    conn.close()\n\n\ndef get_user(username):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("SELECT * FROM users WHERE username = ?", (username,))\n    user = cursor.fetchone()\n    conn.close()\n    return user\n\n\ndef add_note(user_id, title, content, timestamp, tags=None, categories=None):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("""\n        INSERT INTO notes (user_id, title, content, timestamp, tags, categories)\n        VALUES (?, ?, ?, ?, ?, ?)\n    """, (user_id, title, content, timestamp, tags, categories))\n    conn.commit()\n    conn.close()\n\n\ndef get_notes(user_id):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("SELECT * FROM notes WHERE user_id = ?", (user_id,))\n    notes = cursor.fetchall()\n    conn.close()\n    return notes\n\n\ndef update_note(note_id, title, content, tags=None, categories=None):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("""\n        UPDATE notes\n        SET title = ?, content = ?, tags = ?, categories = ?\n        WHERE id = ?\n    """, (title, content, tags, categories, note_id))\n    conn.commit()\n    conn.close()\n\n\ndef delete_note(note_id):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute("DELETE FROM notes WHERE id = ?", (note_id,))\n    conn.commit()\n    conn.close()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xdbP8[\xb9\xc0\xb4\xaf7\x02\x00\x007\x02\x00\x00\t\x00\x00\x00models.py\'\'\'Models module: Defines User and Note data structures\'\'\'\n\n\nclass User:\n    def __init__(self, id, username, password_hash, salt):\n        self.id = id\n        self.username = username\n        self.password_hash = password_hash\n        self.salt = salt\n\n\nclass Note:\n    def __init__(self, id, user_id, title, content, timestamp, tags=None, categories=None):\n        self.id = id\n        self.user_id = user_id\n        self.title = title\n        self.content = content\n        self.timestamp = timestamp\n        self.tags = tags\n        self.categories = categories\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xdbP8[\xdaY\xf5K\x98\x05\x00\x00\x98\x05\x00\x00\x0b\x00\x00\x00security.py\'\'\'Security module: Handles password hashing and note encryption/decryption using Fernet\'\'\'\n\nimport bcrypt\nimport base64\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.fernet import Fernet\nfrom config import ENCRYPTION_ITERATIONS\n\n\ndef hash_password(password):\n    \'\'\'Hashes a password and returns (hashed_password, salt)\'\'\'\n    password_bytes = password.encode()\n    salt = bcrypt.gensalt()\n    hashed = bcrypt.hashpw(password_bytes, salt)\n    # Return hash as string and salt as bytes\n    return hashed.decode(), salt\n\n\ndef verify_password(password, hashed):\n    \'\'\'Verifies a password against the stored hash\'\'\'\n    return bcrypt.checkpw(password.encode(), hashed.encode())\n\n\ndef derive_key(password, salt):\n    \'\'\'Derives a symmetric encryption key from the password and salt using PBKDF2HMAC\'\'\'\n    kdf = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=salt,\n        iterations=ENCRYPTION_ITERATIONS,\n    )\n    key = base64.urlsafe_b64encode(kdf.derive(password.encode()))\n    return key\n\n\ndef encrypt_note_content(content, key):\n    \'\'\'Encrypts the note content using the provided key\'\'\'\n    f = Fernet(key)\n    return f.encrypt(content.encode())\n\n\ndef decrypt_note_content(token, key):\n    \'\'\'Decrypts the note content token using the provided key\'\'\'\n    f = Fernet(key)\n    return f.decrypt(token).decode()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xdbP8[\xf3`3\x9f\t\x1a\x00\x00\t\x1a\x00\x00\x05\x00\x00\x00ui.py\'\'\'UI module: Defines Tkinter-based user interface for login/registration and note management\'\'\'\n\nimport tkinter as tk\nfrom tkinter import ttk, messagebox, simpledialog, scrolledtext\nimport datetime\nfrom database import get_user, add_user, add_note, get_notes, update_note, delete_note\nfrom security import hash_password, verify_password, derive_key, encrypt_note_content, decrypt_note_content\n\n\nclass LoginFrame(ttk.Frame):\n    def __init__(self, master, on_login, on_register):\n        super().__init__(master)\n        self.on_login = on_login\n        self.on_register = on_register\n        self.username_var = tk.StringVar()\n        self.password_var = tk.StringVar()\n        self.create_widgets()\n\n    def create_widgets(self):\n        ttk.Label(self, text="Username:").grid(row=0, column=0, pady=5, sticky=tk.W)\n        ttk.Entry(self, textvariable=self.username_var).grid(row=0, column=1, pady=5)\n        ttk.Label(self, text="Password:").grid(row=1, column=0, pady=5, sticky=tk.W)\n        ttk.Entry(self, textvariable=self.password_var, show="*").grid(row=1, column=1, pady=5)\n        \n        ttk.Button(self, text="Login", command=self.login).grid(row=2, column=0, pady=5)\n        ttk.Button(self, text="Register", command=self.register).grid(row=2, column=1, pady=5)\n\n    def login(self):\n        username = self.username_var.get().strip()\n        password = self.password_var.get().strip()\n        if not username or not password:\n            messagebox.showerror("Error", "Please enter username and password")\n            return\n        user_data = get_user(username)\n        if user_data and verify_password(password, user_data["password_hash"]):\n            # Derive the encryption key from the password and stored salt\n            key = derive_key(password, user_data["salt"])\n            self.on_login(user_data, key)\n        else:\n            messagebox.showerror("Error", "Invalid username or password")\n\n    def register(self):\n        self.on_register()\n\n\nclass NoteFrame(ttk.Frame):\n    def __init__(self, master, user, encryption_key):\n        super().__init__(master)\n        self.user = user\n        self.encryption_key = encryption_key\n        self.selected_note_id = None\n        self.create_widgets()\n        self.refresh_notes()\n\n    def create_widgets(self):\n        # List of notes\n        self.note_list = tk.Listbox(self, height=10)\n        self.note_list.grid(row=0, column=0, columnspan=2, sticky="nsew")\n        self.note_list.bind(\'<<ListboxSelect>>\', self.on_note_select)\n\n        ttk.Button(self, text="New Note", command=self.new_note).grid(row=1, column=0, pady=5)\n        ttk.Button(self, text="Delete Note", command=self.delete_selected_note).grid(row=1, column=1, pady=5)\n\n        ttk.Label(self, text="Title:").grid(row=2, column=0, sticky=tk.W, pady=(10, 0))\n        self.title_entry = ttk.Entry(self)\n        self.title_entry.grid(row=2, column=1, sticky="ew", pady=(10, 0))\n\n        ttk.Label(self, text="Content:").grid(row=3, column=0, sticky=tk.W, pady=(10, 0))\n        self.content_text = scrolledtext.ScrolledText(self, wrap=\'word\', height=10)\n        self.content_text.grid(row=3, column=1, sticky="nsew", pady=(10, 0))\n\n        ttk.Button(self, text="Save Note", command=self.save_note).grid(row=4, column=0, columnspan=2, pady=10)\n\n        self.rowconfigure(3, weight=1)\n        self.columnconfigure(1, weight=1)\n\n    def refresh_notes(self):\n        self.note_list.delete(0, tk.END)\n        notes = get_notes(self.user["id"])\n        self.notes = []\n        for note in notes:\n            self.notes.append(note)\n            display_text = f"{note[\'title\']} - {note[\'timestamp\']}"\n            self.note_list.insert(tk.END, display_text)\n\n    def on_note_select(self, event):\n        selection = event.widget.curselection()\n        if selection:\n            index = selection[0]\n            note = self.notes[index]\n            self.selected_note_id = note["id"]\n            self.title_entry.delete(0, tk.END)\n            self.title_entry.insert(0, note["title"])\n            try:\n                decrypted = decrypt_note_content(note["content"], self.encryption_key)\n            except Exception as e:\n                decrypted = "Error decrypting note"\n            self.content_text.delete("1.0", tk.END)\n            self.content_text.insert(tk.END, decrypted)\n\n    def new_note(self):\n        self.selected_note_id = None\n        self.title_entry.delete(0, tk.END)\n        self.content_text.delete("1.0", tk.END)\n\n    def save_note(self):\n        title = self.title_entry.get().strip()\n        content = self.content_text.get("1.0", tk.END).strip()\n        if not title or not content:\n            messagebox.showerror("Error", "Title and content cannot be empty")\n            return\n        encrypted_content = encrypt_note_content(content, self.encryption_key)\n        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")\n        if self.selected_note_id:\n            update_note(self.selected_note_id, title, encrypted_content)\n        else:\n            add_note(self.user["id"], title, encrypted_content, timestamp)\n        self.refresh_notes()\n\n    def delete_selected_note(self):\n        selection = self.note_list.curselection()\n        if selection:\n            index = selection[0]\n            note = self.notes[index]\n            if messagebox.askyesno("Confirm Delete", "Are you sure you want to delete this note?"):\n                delete_note(note["id"])\n                self.new_note()\n                self.refresh_notes()\n\n\ndef registration_dialog(master):\n    reg_win = tk.Toplevel(master)\n    reg_win.title("Register New User")\n    \n    ttk.Label(reg_win, text="Username:").grid(row=0, column=0, pady=5, sticky=tk.W)\n    username_entry = ttk.Entry(reg_win)\n    username_entry.grid(row=0, column=1, pady=5)\n    \n    ttk.Label(reg_win, text="Password:").grid(row=1, column=0, pady=5, sticky=tk.W)\n    password_entry = ttk.Entry(reg_win, show="*")\n    password_entry.grid(row=1, column=1, pady=5)\n\n    def register_user():\n        username = username_entry.get().strip()\n        password = password_entry.get().strip()\n        if not username or not password:\n            messagebox.showerror("Error", "Username and password cannot be empty")\n            return\n        if get_user(username):\n            messagebox.showerror("Error", "Username already exists")\n            return\n        pwd_hash, salt = hash_password(password)\n        add_user(username, pwd_hash, salt)\n        messagebox.showinfo("Success", "User registered successfully")\n        reg_win.destroy()\n\n    ttk.Button(reg_win, text="Register", command=register_user).grid(row=2, column=0, columnspan=2, pady=10)\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xdbP8[/\x07\xa5\x9e\x1c\x03\x00\x00\x1c\x03\x00\x00\x07\x00\x00\x00main.py\'\'\'Main module: Application entry point for the Secure Note-Taking Application\'\'\'\n\nimport tkinter as tk\nfrom tkinter import ttk\nfrom database import init_db\nfrom ui import LoginFrame, NoteFrame, registration_dialog\n\n\ndef on_login(user, encryption_key):\n    login_frame.destroy()\n    note_frame = NoteFrame(root, user, encryption_key)\n    note_frame.pack(fill="both", expand=True)\n\n\ndef on_register():\n    registration_dialog(root)\n\n\nif __name__ == "__main__":\n    # Initialize the local SQLite database\n    init_db()\n\n    # Setup main Tkinter window\n    root = tk.Tk()\n    root.title("Secure Note-Taking App")\n    root.geometry("600x400")\n\n    # Display the login frame\n    login_frame = LoginFrame(root, on_login, on_register)\n    login_frame.pack(fill="both", expand=True)\n\n    root.mainloop()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xdbP8[\x1e,\xc8\tf\x04\x00\x00f\x04\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\n- Store notes locally in a SQLite database\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nAdd support for note categories and tags:\n- Implement a search function for notes\n- Store note metadata (timestamps, tags, categories)\n- Export and import notes as JSON files\nRich Text & Formatting:\n- Support for Markdown and Rich-Text (bold, italic, headings, lists)\n- Add highlighting and color options for notes\n- Support code snippets with syntax highlighting\nAuthentication & Security (local):\n- Implement local user accounts with username and password\n- Securely store passwords using hashing (e.g., bcrypt or argon2)\n- Encrypt all notes using a key derived from the user\'s password (AES or Fernet)\n- Allow multiple users on the same device, each with their own notes\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00\xdbP8[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xdbP8[\xa7\t\xe0z\x04\x01\x00\x00\x04\x01\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00config.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xdbP8[\xd2\xcc\xe67\x1d\n\x00\x00\x1d\n\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01+\x01\x00\x00database.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xdbP8[\xb9\xc0\xb4\xaf7\x02\x00\x007\x02\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01q\x0b\x00\x00models.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xdbP8[\xdaY\xf5K\x98\x05\x00\x00\x98\x05\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xcf\r\x00\x00security.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xdbP8[\xf3`3\x9f\t\x1a\x00\x00\t\x1a\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x90\x13\x00\x00ui.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xdbP8[/\x07\xa5\x9e\x1c\x03\x00\x00\x1c\x03\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xbc-\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xdbP8[\x1e,\xc8\tf\x04\x00\x00f\x04\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xfd0\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xdbP8[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x915\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\x08\x00\x08\x00\xca\x01\x00\x00\xee5\x00\x00\x00\x00'