b'PK\x03\x04\x14\x00\x00\x00\x00\x00\xb8{7[\xbd\\\xaa\x04\x85\x01\x00\x00\x85\x01\x00\x00\t\x00\x00\x00config.pyCONFIG = {\n    "database": {\n        "path": "./data/notes.db"\n    },\n    "encryption": {\n        "algorithm": "Fernet",\n        "key_derivation": "PBKDF2",\n        "salt": b\'random_salt_here\',\n        "iterations": 100000\n    },\n    "ui": {\n        "theme": "light",\n        "default_view": "list"\n    },\n    "logging": {\n        "level": "INFO",\n        "file": "./logs/app.log"\n    }\n}\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb8{7[L\x1e\xce\xf6~\x0c\x00\x00~\x0c\x00\x00\x05\x00\x00\x00db.pyimport sqlite3\nimport os\nimport json\nfrom datetime import datetime\n\nfrom config import CONFIG\n\nDB_PATH = CONFIG[\'database\'][\'path\']\n\n# Ensure that the database directory exists\nos.makedirs(os.path.dirname(DB_PATH), exist_ok=True)\n\n\ndef get_connection():\n    conn = sqlite3.connect(DB_PATH, detect_types=sqlite3.PARSE_DECLTYPES | sqlite3.PARSE_COLNAMES)\n    conn.row_factory = sqlite3.Row\n    return conn\n\n\ndef create_tables():\n    conn = get_connection()\n    cursor = conn.cursor()\n\n    # Create Users table\n    cursor.execute(\'\'\'\n        CREATE TABLE IF NOT EXISTS Users (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            username TEXT NOT NULL UNIQUE,\n            password_hash TEXT NOT NULL\n        );\n    \'\'\')\n\n    # Create Notes table\n    cursor.execute(\'\'\'\n        CREATE TABLE IF NOT EXISTS Notes (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            content TEXT NOT NULL,\n            timestamp DATETIME NOT NULL,\n            categories TEXT,\n            tags TEXT,\n            user_id INTEGER NOT NULL,\n            FOREIGN KEY (user_id) REFERENCES Users(id)\n        );\n    \'\'\')\n\n    conn.commit()\n    conn.close()\n\n\n# Utility functions for Note operations\n\ndef create_note(title, content, categories, tags, user_id):\n    conn = get_connection()\n    cursor = conn.cursor()\n    timestamp = datetime.now()\n    # Store categories and tags as JSON strings\n    categories_json = json.dumps(categories) if categories else json.dumps([])\n    tags_json = json.dumps(tags) if tags else json.dumps([])\n    cursor.execute(\'\'\'\n        INSERT INTO Notes (title, content, timestamp, categories, tags, user_id)\n        VALUES (?, ?, ?, ?, ?, ?)\n    \'\'\', (title, content, timestamp, categories_json, tags_json, user_id))\n    conn.commit()\n    conn.close()\n\n\ndef get_notes(user_id):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\'\'\'\n        SELECT * FROM Notes WHERE user_id = ? ORDER BY timestamp DESC\n    \'\'\', (user_id,))\n    notes = cursor.fetchall()\n    conn.close()\n    return notes\n\n\ndef update_note(note_id, title, content, categories, tags):\n    conn = get_connection()\n    cursor = conn.cursor()\n    timestamp = datetime.now()\n    categories_json = json.dumps(categories) if categories else json.dumps([])\n    tags_json = json.dumps(tags) if tags else json.dumps([])\n    cursor.execute(\'\'\'\n        UPDATE Notes SET title = ?, content = ?, timestamp = ?, categories = ?, tags = ? WHERE id = ?\n    \'\'\', (title, content, timestamp, categories_json, tags_json, note_id))\n    conn.commit()\n    conn.close()\n\n\ndef delete_note(note_id):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\'DELETE FROM Notes WHERE id = ?\', (note_id,))\n    conn.commit()\n    conn.close()\n\n\ndef search_notes(user_id, keyword):\n    conn = get_connection()\n    cursor = conn.cursor()\n    pattern = f\'%{keyword}%\'\n    cursor.execute(\'\'\'\n        SELECT * FROM Notes \n        WHERE user_id = ? AND (title LIKE ? OR content LIKE ? OR categories LIKE ? OR tags LIKE ?)\n        ORDER BY timestamp DESC\n    \'\'\', (user_id, pattern, pattern, pattern, pattern))\n    results = cursor.fetchall()\n    conn.close()\n    return results\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb8{7[D8\x08\xd9\xfa\x02\x00\x00\xfa\x02\x00\x00\r\x00\x00\x00encryption.pyimport base64\nfrom cryptography.fernet import Fernet\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n\nfrom config import CONFIG\n\n\ndef generate_key(password: str) -> bytes:\n    salt = CONFIG[\'encryption\'][\'salt\']\n    iterations = CONFIG[\'encryption\'][\'iterations\']\n    kdf = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=salt,\n        iterations=iterations,\n    )\n    key = base64.urlsafe_b64encode(kdf.derive(password.encode()))\n    return key\n\n\ndef encrypt_data(data: str, key: bytes) -> bytes:\n    f = Fernet(key)\n    return f.encrypt(data.encode())\n\n\ndef decrypt_data(token: bytes, key: bytes) -> str:\n    f = Fernet(key)\n    return f.decrypt(token).decode()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb8{7[\x85_\xda\x80\x9f\x03\x00\x00\x9f\x03\x00\x00\x07\x00\x00\x00auth.pyimport sqlite3\nimport bcrypt\nfrom db import get_connection\n\n\ndef register_user(username: str, password: str) -> bool:\n    conn = get_connection()\n    cursor = conn.cursor()\n    # Hash the password\n    password_hash = bcrypt.hashpw(password.encode(\'utf-8\'), bcrypt.gensalt())\n    try:\n        cursor.execute(\'INSERT INTO Users (username, password_hash) VALUES (?, ?)\', (username, password_hash))\n        conn.commit()\n    except sqlite3.IntegrityError:\n        conn.close()\n        return False  # Username already exists\n    conn.close()\n    return True\n\n\ndef authenticate_user(username: str, password: str):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\'SELECT * FROM Users WHERE username = ?\', (username,))\n    user = cursor.fetchone()\n    conn.close()\n    if user and bcrypt.checkpw(password.encode(\'utf-8\'), user[\'password_hash\']):\n        return user  # Return the user record\n    return None\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb8{7[\xd9\xd1\x03[X\x03\x00\x00X\x03\x00\x00\t\x00\x00\x00models.pyfrom dataclasses import dataclass, field\nfrom datetime import datetime\nfrom typing import List\nimport json\n\n\n@dataclass\nclass User:\n    id: int\n    username: str\n    password_hash: str\n\n\n@dataclass\nclass Note:\n    id: int = None\n    title: str = \'\'\n    content: str = \'\'\n    timestamp: datetime = field(default_factory=datetime.now)\n    categories: List[str] = field(default_factory=list)\n    tags: List[str] = field(default_factory=list)\n    user_id: int = None\n\n    @classmethod\n    def from_row(cls, row):\n        return cls(\n            id=row[\'id\'],\n            title=row[\'title\'],\n            content=row[\'content\'],\n            timestamp=row[\'timestamp\'],\n            categories=json.loads(row[\'categories\']) if row[\'categories\'] else [],\n            tags=json.loads(row[\'tags\']) if row[\'tags\'] else [],\n            user_id=row[\'user_id\']\n        )\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb8{7[\xe6\xd5\x92L-\x1e\x00\x00-\x1e\x00\x00\x05\x00\x00\x00ui.pyimport tkinter as tk\nfrom tkinter import ttk, messagebox, filedialog\nimport json\n\nfrom db import create_tables, create_note, get_notes, update_note, delete_note, search_notes\nfrom auth import register_user, authenticate_user\n\n\nclass LoginWindow:\n    def __init__(self, master, on_login_success):\n        self.master = master\n        self.on_login_success = on_login_success\n        self.master.title(\'Login / Register\')\n\n        self.frame = ttk.Frame(master, padding="10")\n        self.frame.grid(row=0, column=0, sticky=\'nsew\')\n\n        # Username\n        ttk.Label(self.frame, text="Username:").grid(row=0, column=0, sticky=\'w\')\n        self.username_entry = ttk.Entry(self.frame)\n        self.username_entry.grid(row=0, column=1, sticky=\'ew\')\n\n        # Password\n        ttk.Label(self.frame, text="Password:").grid(row=1, column=0, sticky=\'w\')\n        self.password_entry = ttk.Entry(self.frame, show=\'*\')\n        self.password_entry.grid(row=1, column=1, sticky=\'ew\')\n\n        # Buttons\n        self.login_button = ttk.Button(self.frame, text="Login", command=self.login)\n        self.login_button.grid(row=2, column=0, pady=5)\n        self.register_button = ttk.Button(self.frame, text="Register", command=self.register)\n        self.register_button.grid(row=2, column=1, pady=5)\n\n    def login(self):\n        username = self.username_entry.get()\n        password = self.password_entry.get()\n        user = authenticate_user(username, password)\n        if user:\n            messagebox.showinfo("Success", "Logged in successfully")\n            self.on_login_success(user)\n        else:\n            messagebox.showerror("Error", "Invalid credentials")\n\n    def register(self):\n        username = self.username_entry.get()\n        password = self.password_entry.get()\n        if register_user(username, password):\n            messagebox.showinfo("Success", "User registered. You can now log in.")\n        else:\n            messagebox.showerror("Error", "Username already exists")\n\n\nclass NotesApp:\n    def __init__(self, master, user):\n        self.master = master\n        self.user = user\n        self.master.title(f"Notes - {self.user[\'username\']}")\n\n        self.frame = ttk.Frame(master, padding="10")\n        self.frame.pack(fill=\'both\', expand=True)\n\n        # Search bar\n        self.search_var = tk.StringVar()\n        search_frame = ttk.Frame(self.frame)\n        search_frame.pack(fill=\'x\')\n        ttk.Label(search_frame, text="Search:").pack(side=\'left\')\n        self.search_entry = ttk.Entry(search_frame, textvariable=self.search_var)\n        self.search_entry.pack(side=\'left\', fill=\'x\', expand=True)\n        self.search_entry.bind(\'<Return>\', lambda event: self.perform_search())\n\n        # Notes list\n        self.notes_listbox = tk.Listbox(self.frame, height=10)\n        self.notes_listbox.pack(fill=\'both\', expand=True)\n        self.notes_listbox.bind(\'<<ListboxSelect>>\', self.load_selected_note)\n\n        # Note editor\n        self.title_var = tk.StringVar()\n        ttk.Label(self.frame, text="Title:").pack(anchor=\'w\')\n        self.title_entry = ttk.Entry(self.frame, textvariable=self.title_var)\n        self.title_entry.pack(fill=\'x\')\n        ttk.Label(self.frame, text="Content:").pack(anchor=\'w\')\n        self.content_text = tk.Text(self.frame, height=10)\n        self.content_text.pack(fill=\'both\', expand=True)\n\n        # Buttons\n        buttons_frame = ttk.Frame(self.frame)\n        buttons_frame.pack(fill=\'x\')\n        ttk.Button(buttons_frame, text="New Note", command=self.new_note).pack(side=\'left\')\n        ttk.Button(buttons_frame, text="Save Note", command=self.save_note).pack(side=\'left\')\n        ttk.Button(buttons_frame, text="Delete Note", command=self.delete_note).pack(side=\'left\')\n        ttk.Button(buttons_frame, text="Export", command=self.export_notes).pack(side=\'left\')\n        ttk.Button(buttons_frame, text="Import", command=self.import_notes).pack(side=\'left\')\n\n        self.selected_note_id = None\n        self.load_notes()\n\n    def perform_search(self):\n        keyword = self.search_var.get()\n        notes = search_notes(self.user[\'id\'], keyword) if keyword else get_notes(self.user[\'id\'])\n        self.populate_notes_list(notes)\n\n    def populate_notes_list(self, notes):\n        self.notes_listbox.delete(0, tk.END)\n        self.notes_data = []\n        for note in notes:\n            self.notes_listbox.insert(tk.END, note[\'title\'])\n            self.notes_data.append(note)\n\n    def load_notes(self):\n        notes = get_notes(self.user[\'id\'])\n        self.populate_notes_list(notes)\n\n    def load_selected_note(self, event):\n        selection = self.notes_listbox.curselection()\n        if not selection:\n            return\n        index = selection[0]\n        note = self.notes_data[index]\n        self.selected_note_id = note[\'id\']\n        self.title_var.set(note[\'title\'])\n        self.content_text.delete(\'1.0\', tk.END)\n        self.content_text.insert(tk.END, note[\'content\'])\n\n    def new_note(self):\n        self.selected_note_id = None\n        self.title_var.set("")\n        self.content_text.delete(\'1.0\', tk.END)\n\n    def save_note(self):\n        title = self.title_var.get()\n        content = self.content_text.get(\'1.0\', tk.END).strip()\n        if not title or not content:\n            messagebox.showerror("Error", "Title and content cannot be empty.")\n            return\n        if self.selected_note_id:\n            update_note(self.selected_note_id, title, content, categories=[], tags=[])\n        else:\n            create_note(title, content, categories=[], tags=[], user_id=self.user[\'id\'])\n        messagebox.showinfo("Success", "Note saved successfully")\n        self.load_notes()\n\n    def delete_note(self):\n        if self.selected_note_id:\n            delete_note(self.selected_note_id)\n            messagebox.showinfo("Success", "Note deleted")\n            self.new_note()\n            self.load_notes()\n        else:\n            messagebox.showerror("Error", "No note selected")\n\n    def export_notes(self):\n        notes = get_notes(self.user[\'id\'])\n        export_data = []\n        for note in notes:\n            export_data.append({\n                \'id\': note[\'id\'],\n                \'title\': note[\'title\'],\n                \'content\': note[\'content\'],\n                \'timestamp\': str(note[\'timestamp\']),\n                \'categories\': note[\'categories\'],\n                \'tags\': note[\'tags\']\n            })\n        file_path = filedialog.asksaveasfilename(defaultextension=\'.json\', filetypes=[(\'JSON Files\', \'*.json\')])\n        if file_path:\n            with open(file_path, \'w\') as f:\n                json.dump(export_data, f, indent=4)\n            messagebox.showinfo("Export", "Notes exported successfully.")\n\n    def import_notes(self):\n        file_path = filedialog.askopenfilename(filetypes=[(\'JSON Files\', \'*.json\')])\n        if file_path:\n            with open(file_path, \'r\') as f:\n                try:\n                    imported_notes = json.load(f)\n                    for note in imported_notes:\n                        # Here we assume no duplicates; production code should check for duplicates\n                        create_note(note.get(\'title\', \'Untitled\'), note.get(\'content\', \'\'), \n                                    categories=json.loads(note.get(\'categories\', \'[]\')) if note.get(\'categories\') else [], \n                                    tags=json.loads(note.get(\'tags\', \'[]\')) if note.get(\'tags\') else [], \n                                    user_id=self.user[\'id\'])\n                    messagebox.showinfo("Import", "Notes imported successfully.")\n                    self.load_notes()\n                except Exception as e:\n                    messagebox.showerror("Error", f"Failed to import notes: {e}")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb8{7[\x9eD\x01\x7fj\x02\x00\x00j\x02\x00\x00\x07\x00\x00\x00main.pyimport tkinter as tk\nfrom tkinter import ttk\n\nfrom db import create_tables\nfrom ui import LoginWindow, NotesApp\n\n\ndef start_notes_app(user):\n    # Destroy the login window and open the notes app\n    for widget in root.winfo_children():\n        widget.destroy()\n    app = NotesApp(root, user)\n\n\nif __name__ == \'__main__\':\n    # Create database tables if they don\'t exist\n    create_tables()\n\n    root = tk.Tk()\n    root.geometry(\'800x600\')\n    # Use themed widgets\n    ttk.Style().theme_use(\'clam\')\n\n    # Start with the login window\n    login = LoginWindow(root, on_login_success=start_notes_app)\n\n    root.mainloop()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb8{7[\x1e,\xc8\tf\x04\x00\x00f\x04\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\n- Store notes locally in a SQLite database\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nAdd support for note categories and tags:\n- Implement a search function for notes\n- Store note metadata (timestamps, tags, categories)\n- Export and import notes as JSON files\nRich Text & Formatting:\n- Support for Markdown and Rich-Text (bold, italic, headings, lists)\n- Add highlighting and color options for notes\n- Support code snippets with syntax highlighting\nAuthentication & Security (local):\n- Implement local user accounts with username and password\n- Securely store passwords using hashing (e.g., bcrypt or argon2)\n- Encrypt all notes using a key derived from the user\'s password (AES or Fernet)\n- Allow multiple users on the same device, each with their own notes\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00\xb8{7[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb8{7[\xbd\\\xaa\x04\x85\x01\x00\x00\x85\x01\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00config.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb8{7[L\x1e\xce\xf6~\x0c\x00\x00~\x0c\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xac\x01\x00\x00db.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb8{7[D8\x08\xd9\xfa\x02\x00\x00\xfa\x02\x00\x00\r\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01M\x0e\x00\x00encryption.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb8{7[\x85_\xda\x80\x9f\x03\x00\x00\x9f\x03\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01r\x11\x00\x00auth.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb8{7[\xd9\xd1\x03[X\x03\x00\x00X\x03\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x016\x15\x00\x00models.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb8{7[\xe6\xd5\x92L-\x1e\x00\x00-\x1e\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xb5\x18\x00\x00ui.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb8{7[\x9eD\x01\x7fj\x02\x00\x00j\x02\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x057\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb8{7[\x1e,\xc8\tf\x04\x00\x00f\x04\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x949\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb8{7[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01(>\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\t\x00\t\x00\xfb\x01\x00\x00\x85>\x00\x00\x00\x00'