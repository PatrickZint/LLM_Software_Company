b'PK\x03\x04\x14\x00\x00\x00\x00\x00<z7[%\x1b\x02j;\x1d\x00\x00;\x1d\x00\x00\x07\x00\x00\x00main.pyimport os\nimport json\nimport tkinter as tk\nfrom tkinter import ttk, messagebox, filedialog\nfrom datetime import datetime\n\nimport db\nimport import_export\n\nCONFIG_FILE = \'config.json\'\n\nclass NoteApp(tk.Tk):\n    def __init__(self):\n        super().__init__()\n        self.title(\'Note Taking Application\')\n        self.geometry(\'800x600\')\n        self.db = db.Database(self.get_config().get(\'database\', \'notes.db\'))\n        self.selected_note_id = None\n        self.create_widgets()\n        self.refresh_note_list()\n\n    def get_config(self):\n        if os.path.exists(CONFIG_FILE):\n            with open(CONFIG_FILE, \'r\') as f:\n                return json.load(f)\n        else:\n            return {}\n\n    def create_widgets(self):\n        # Top frame for search\n        top_frame = ttk.Frame(self)\n        top_frame.pack(side=tk.TOP, fill=tk.X, padx=5, pady=5)\n\n        ttk.Label(top_frame, text=\'Search:\').pack(side=tk.LEFT)\n        self.search_var = tk.StringVar()\n        search_entry = ttk.Entry(top_frame, textvariable=self.search_var)\n        search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5)\n        search_entry.bind(\'<Return>\', lambda event: self.search_notes())\n        ttk.Button(top_frame, text=\'Search\', command=self.search_notes).pack(side=tk.LEFT, padx=5)\n        ttk.Button(top_frame, text=\'Clear\', command=self.clear_search).pack(side=tk.LEFT, padx=5)\n\n        # Main frame split: list and detail\n        main_frame = ttk.Frame(self)\n        main_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n\n        # Left pane: List of notes\n        left_frame = ttk.Frame(main_frame)\n        left_frame.pack(side=tk.LEFT, fill=tk.Y)\n        ttk.Label(left_frame, text=\'Notes\').pack(anchor=tk.W)\n        self.notes_listbox = tk.Listbox(left_frame, width=30)\n        self.notes_listbox.pack(fill=tk.Y, expand=True, pady=5)\n        self.notes_listbox.bind(\'<<ListboxSelect>>\', self.on_note_select)\n\n        btn_frame = ttk.Frame(left_frame)\n        btn_frame.pack(fill=tk.X, pady=5)\n        ttk.Button(btn_frame, text=\'New Note\', command=self.new_note).pack(side=tk.LEFT, padx=2)\n        ttk.Button(btn_frame, text=\'Delete\', command=self.delete_note).pack(side=tk.LEFT, padx=2)\n        ttk.Button(btn_frame, text=\'Import\', command=self.import_notes).pack(side=tk.LEFT, padx=2)\n        ttk.Button(btn_frame, text=\'Export\', command=self.export_notes).pack(side=tk.LEFT, padx=2)\n\n        # Right pane: Note Details\n        right_frame = ttk.Frame(main_frame)\n        right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)\n\n        ttk.Label(right_frame, text=\'Title:\').pack(anchor=tk.W)\n        self.title_var = tk.StringVar()\n        self.title_entry = ttk.Entry(right_frame, textvariable=self.title_var, font=(\'Arial\', 14))\n        self.title_entry.pack(fill=tk.X, padx=5, pady=5)\n\n        ttk.Label(right_frame, text=\'Content (Markdown supported):\').pack(anchor=tk.W)\n        self.content_text = tk.Text(right_frame, wrap=tk.WORD)\n        self.content_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n\n        # Footer: Save button and timestamps\n        footer_frame = ttk.Frame(self)\n        footer_frame.pack(side=tk.BOTTOM, fill=tk.X, padx=5, pady=5)\n        self.info_label = ttk.Label(footer_frame, text=\'\')\n        self.info_label.pack(side=tk.LEFT)\n        ttk.Button(footer_frame, text=\'Save\', command=self.save_note).pack(side=tk.RIGHT)\n\n    def refresh_note_list(self, notes=None):\n        self.notes_listbox.delete(0, tk.END)\n        if notes is None:\n            notes = self.db.get_all_notes()\n        self.notes = notes  # Store list for lookup\n        for note in notes:\n            # Show title and truncated content\n            display = f"{note[\'title\']} - {note[\'content\'][:30].replace(\'\\n\', \' \')}..."\n            self.notes_listbox.insert(tk.END, display)\n\n    def on_note_select(self, event):\n        selection = self.notes_listbox.curselection()\n        if selection:\n            index = selection[0]\n            note = self.notes[index]\n            self.selected_note_id = note[\'id\']\n            self.title_var.set(note[\'title\'])\n            self.content_text.delete(1.0, tk.END)\n            self.content_text.insert(tk.END, note[\'content\'])\n            created = note.get(\'created_at\', \'N/A\')\n            updated = note.get(\'updated_at\', \'N/A\')\n            self.info_label.config(text=f\'Created: {created} | Updated: {updated}\')\n\n    def new_note(self):\n        self.selected_note_id = None\n        self.title_var.set(\'\')\n        self.content_text.delete(1.0, tk.END)\n        self.info_label.config(text=\'New note (not yet saved)\')\n        self.notes_listbox.selection_clear(0, tk.END)\n\n    def save_note(self):\n        title = self.title_var.get().strip()\n        content = self.content_text.get(1.0, tk.END).strip()\n        if not title:\n            messagebox.showwarning(\'Warning\', \'Title cannot be empty\')\n            return\n\n        now = datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')\n        if self.selected_note_id is None:\n            # New note\n            self.db.add_note(title, content, now, now)\n            messagebox.showinfo(\'Info\', \'Note added successfully.\')\n        else:\n            # Update existing note\n            self.db.update_note(self.selected_note_id, title, content, now)\n            messagebox.showinfo(\'Info\', \'Note updated successfully.\')\n\n        self.refresh_note_list()\n        self.clear_form()\n\n    def delete_note(self):\n        if self.selected_note_id is None:\n            messagebox.showwarning(\'Warning\', \'No note selected to delete.\')\n            return\n        confirm = messagebox.askyesno(\'Confirm\', \'Are you sure you want to delete this note?\')\n        if confirm:\n            self.db.delete_note(self.selected_note_id)\n            messagebox.showinfo(\'Info\', \'Note deleted.\')\n            self.refresh_note_list()\n            self.clear_form()\n\n    def clear_form(self):\n        self.selected_note_id = None\n        self.title_var.set(\'\')\n        self.content_text.delete(1.0, tk.END)\n        self.info_label.config(text=\'\')\n\n    def search_notes(self):\n        query = self.search_var.get().strip()\n        if query:\n            notes = self.db.search_notes(query)\n            self.refresh_note_list(notes)\n        else:\n            self.refresh_note_list()\n\n    def clear_search(self):\n        self.search_var.set(\'\')\n        self.refresh_note_list()\n\n    def export_notes(self):\n        export_path = filedialog.asksaveasfilename(defaultextension=\'.json\', filetypes=[(\'JSON Files\', \'*.json\')])\n        if export_path:\n            try:\n                import_export.export_notes(self.db, export_path)\n                messagebox.showinfo(\'Export\', f\'Notes exported to {export_path}\')\n            except Exception as e:\n                messagebox.showerror(\'Error\', f\'Export failed: {e}\')\n\n    def import_notes(self):\n        import_path = filedialog.askopenfilename(filetypes=[(\'JSON Files\', \'*.json\')])\n        if import_path:\n            try:\n                # Ask the user how to handle duplicates:\n                merge = messagebox.askyesno(\'Import\', \'Merge with existing notes? (No will overwrite duplicates)\')\n                import_export.import_notes(self.db, import_path, merge)\n                messagebox.showinfo(\'Import\', \'Notes imported successfully.\')\n                self.refresh_note_list()\n            except Exception as e:\n                messagebox.showerror(\'Error\', f\'Import failed: {e}\')\n\nif __name__ == \'__main__\':\n    app = NoteApp()\n    app.mainloop()\nPK\x03\x04\x14\x00\x00\x00\x00\x00<z7[\x90\x8f\xc1\xea<\n\x00\x00<\n\x00\x00\x05\x00\x00\x00db.pyimport sqlite3\nimport os\n\nclass Database:\n    def __init__(self, db_path=\'notes.db\'):\n        self.db_path = db_path\n        self.conn = sqlite3.connect(self.db_path)\n        self.conn.row_factory = sqlite3.Row\n        self.create_tables()\n\n    def create_tables(self):\n        cursor = self.conn.cursor()\n        cursor.execute(\'\'\'\n            CREATE TABLE IF NOT EXISTS notes (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                content TEXT,\n                created_at TEXT,\n                updated_at TEXT\n            )\n        \'\'\')\n        // Future table definitions for categories and tags can be added here\n        self.conn.commit()\n\n    def add_note(self, title, content, created_at, updated_at):\n        cursor = self.conn.cursor()\n        cursor.execute(\'\'\'\n            INSERT INTO notes (title, content, created_at, updated_at)\n            VALUES (?, ?, ?, ?)\n        \'\'\', (title, content, created_at, updated_at))\n        self.conn.commit()\n\n    def get_all_notes(self):\n        cursor = self.conn.cursor()\n        cursor.execute(\'SELECT * FROM notes ORDER BY created_at DESC\')\n        rows = cursor.fetchall()\n        notes = [dict(row) for row in rows]\n        return notes\n\n    def get_note(self, note_id):\n        cursor = self.conn.cursor()\n        cursor.execute(\'SELECT * FROM notes WHERE id = ?\', (note_id,))\n        row = cursor.fetchone()\n        return dict(row) if row else None\n\n    def update_note(self, note_id, title, content, updated_at):\n        cursor = self.conn.cursor()\n        cursor.execute(\'\'\'\n            UPDATE notes SET title = ?, content = ?, updated_at = ? WHERE id = ?\n        \'\'\', (title, content, updated_at, note_id))\n        self.conn.commit()\n\n    def delete_note(self, note_id):\n        cursor = self.conn.cursor()\n        cursor.execute(\'DELETE FROM notes WHERE id = ?\', (note_id,))\n        self.conn.commit()\n\n    def search_notes(self, query):\n        cursor = self.conn.cursor()\n        like_query = f\'%{query}%\'\n        cursor.execute(\'\'\'\n            SELECT * FROM notes\n            WHERE title LIKE ? OR content LIKE ?\n            ORDER BY created_at DESC\n        \'\'\', (like_query, like_query))\n        rows = cursor.fetchall()\n        notes = [dict(row) for row in rows]\n        return notes\n\n    def close(self):\n        if self.conn:\n            self.conn.close()\n\nif __name__ == \'__main__\':\n    # For testing db functionality\n    db = Database()\n    db.add_note("Test Note", "This is a test.", "2023-10-01 12:00:00", "2023-10-01 12:00:00")\n    notes = db.get_all_notes()\n    print(notes)\n    db.close()\nPK\x03\x04\x14\x00\x00\x00\x00\x00<z7[\x12\x05\x8f|\xc7\x06\x00\x00\xc7\x06\x00\x00\x10\x00\x00\x00import_export.pyimport json\nfrom datetime import datetime\n\ndef export_notes(db, export_path):\n    # Retrieve all notes from the database\n    notes = db.get_all_notes()\n    # Write notes to the specified JSON file\n    with open(export_path, \'w\', encoding=\'utf-8\') as f:\n        json.dump(notes, f, indent=4)\n\n\ndef import_notes(db, import_path, merge=True):\n    # Load notes from the JSON file\n    with open(import_path, \'r\', encoding=\'utf-8\') as f:\n        notes = json.load(f)\n\n    # If not merging, clear existing notes\n    if not merge:\n        cursor = db.conn.cursor()\n        cursor.execute(\'DELETE FROM notes\')\n        db.conn.commit()\n\n    # Insert or update notes\n    for note in notes:\n        # Try to find an existing note with the same title and created_at\n        query = "SELECT id FROM notes WHERE title = ? AND created_at = ?"\n        cursor = db.conn.cursor()\n        cursor.execute(query, (note[\'title\'], note.get(\'created_at\', \'\')))\n        row = cursor.fetchone()\n        if row:\n            # Update the note\n            note_id = row[0]\n            update_query = "UPDATE notes SET content = ?, updated_at = ? WHERE id = ?"\n            cursor.execute(update_query, (note[\'content\'], note.get(\'updated_at\', datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')), note_id))\n        else:\n            # Insert new note\n            insert_query = "INSERT INTO notes (title, content, created_at, updated_at) VALUES (?, ?, ?, ?)"\n            cursor.execute(insert_query, (\n                note[\'title\'],\n                note[\'content\'],\n                note.get(\'created_at\', datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')),\n                note.get(\'updated_at\', datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\'))\n            ))\n    db.conn.commit()\nPK\x03\x04\x14\x00\x00\x00\x00\x00<z7[\x80\xc7\xfe"U\x00\x00\x00U\x00\x00\x00\x0b\x00\x00\x00config.json{\n    "database": "notes.db",\n    "theme": "light",\n    "export_path": "./exports"\n}\nPK\x03\x04\x14\x00\x00\x00\x00\x00<z7[\x9d\xb9\xc2\xbd0\x03\x00\x000\x03\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\n- Store notes locally in a SQLite database\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nAdd support for note categories and tags:\n- Implement a search function for notes\n- Store note metadata (timestamps, tags, categories)\n- Export and import notes as JSON files\nRich Text & Formatting:\n- Support for Markdown and Rich-Text (bold, italic, headings, lists)\n- Add highlighting and color options for notes\n- Support code snippets with syntax highlighting\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00<z7[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00<z7[%\x1b\x02j;\x1d\x00\x00;\x1d\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00<z7[\x90\x8f\xc1\xea<\n\x00\x00<\n\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01`\x1d\x00\x00db.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00<z7[\x12\x05\x8f|\xc7\x06\x00\x00\xc7\x06\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xbf\'\x00\x00import_export.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00<z7[\x80\xc7\xfe"U\x00\x00\x00U\x00\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xb4.\x00\x00config.jsonPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00<z7[\x9d\xb9\xc2\xbd0\x03\x00\x000\x03\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x012/\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00<z7[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x902\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\x06\x00\x06\x00a\x01\x00\x00\xed2\x00\x00\x00\x00'