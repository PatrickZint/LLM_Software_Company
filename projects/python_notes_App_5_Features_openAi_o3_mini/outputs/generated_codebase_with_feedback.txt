b'PK\x03\x04\x14\x00\x00\x00\x00\x00RWH[\xd7P\x8c\xf1\xe1#\x00\x00\xe1#\x00\x00\x07\x00\x00\x00main.pyimport tkinter as tk\nfrom tkinter import ttk, messagebox, filedialog\nimport datetime\nimport json\n\nimport db\nimport encryption\nimport export_import\nimport user\nimport markdown\n\n# Global variable to hold logged in user info\nglobal_user = None\n\ndef login_window():\n    def attempt_login():\n        username = username_entry.get()\n        password = password_entry.get()\n        usr = user.get_user(username)\n        if usr is None:\n            messagebox.showerror(\'Login Failed\', \'User not found.\')\n            return\n        if not user.check_password(password, usr[\'password_hash\']):\n            messagebox.showerror(\'Login Failed\', \'Incorrect password.\')\n            return\n        global global_user\n        # Derive encryption key from user\'s password\n        enc_key = encryption.derive_key(password)\n        global_user = { \'id\': usr[\'id\'], \'username\': username, \'encryption_key\': enc_key }\n        login.destroy()\n        main_app()\n\n    login = tk.Tk()\n    login.title(\'Note-Taking App - Login\')\n    login.geometry(\'300x150\')\n\n    ttk.Label(login, text=\'Username:\').pack(pady=5)\n    username_entry = ttk.Entry(login)\n    username_entry.pack()\n    ttk.Label(login, text=\'Password:\').pack(pady=5)\n    password_entry = ttk.Entry(login, show=\'*\')\n    password_entry.pack()\n\n    ttk.Button(login, text=\'Login\', command=attempt_login).pack(pady=10)\n    ttk.Button(login, text=\'Register\', command=lambda: register_window(login)).pack()\n\n    login.mainloop()\n\n\ndef register_window(parent):\n    reg = tk.Toplevel(parent)\n    reg.title(\'Register New User\')\n    reg.geometry(\'300x200\')\n\n    ttk.Label(reg, text=\'Username:\').pack(pady=5)\n    username_entry = ttk.Entry(reg)\n    username_entry.pack()\n    ttk.Label(reg, text=\'Password:\').pack(pady=5)\n    password_entry = ttk.Entry(reg, show=\'*\')\n    password_entry.pack()\n    ttk.Label(reg, text=\'Confirm Password:\').pack(pady=5)\n    password2_entry = ttk.Entry(reg, show=\'*\')\n    password2_entry.pack()\n\n    def register_action():\n        username = username_entry.get()\n        password = password_entry.get()\n        password2 = password2_entry.get()\n        if password != password2:\n            messagebox.showerror(\'Error\', \'Passwords do not match.\')\n            return\n        if user.get_user(username) is not None:\n            messagebox.showerror(\'Error\', \'User already exists.\')\n            return\n        user.register_user(username, password)\n        messagebox.showinfo(\'Success\', \'User registered successfully. You can now login.\')\n        reg.destroy()\n\n    ttk.Button(reg, text=\'Register\', command=register_action).pack(pady=10)\n\n\ndef main_app():\n    app = tk.Tk()\n    app.title(\'Note-Taking App\')\n    app.geometry(\'800x600\')\n\n    # Search Frame\n    search_frame = ttk.Frame(app)\n    search_frame.pack(fill=tk.X, padx=10, pady=5)\n    ttk.Label(search_frame, text=\'Search:\').pack(side=tk.LEFT, padx=5)\n    search_var = tk.StringVar()\n    search_entry = ttk.Entry(search_frame, textvariable=search_var)\n    search_entry.pack(side=tk.LEFT, expand=True, fill=tk.X, padx=5)\n    \n    def refresh_note_list(query=""):\n        for row in note_list.get_children():\n            note_list.delete(row)\n        notes = db.search_notes(global_user[\'id\'], query)\n        for note in notes:\n            # Decrypt the note content for display if needed\n            try:\n                content = encryption.decrypt_data(global_user[\'encryption_key\'], note[\'content\'])\n            except Exception as e:\n                content = "<decryption error>"\n            note_list.insert(\'\', \'end\', iid=note[\'id\'], values=(note[\'title\'], note[\'timestamp\'], note[\'tags\'], note[\'categories\']))\n\n    def on_search(*args):\n        refresh_note_list(search_var.get())\n\n    search_var.trace(\'w\', on_search)\n\n    # Note List Frame\n    list_frame = ttk.Frame(app)\n    list_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)\n    columns = (\'Title\', \'Timestamp\', \'Tags\', \'Categories\')\n    note_list = ttk.Treeview(list_frame, columns=columns, show=\'headings\')\n    for col in columns:\n        note_list.heading(col, text=col)\n    note_list.pack(fill=tk.BOTH, expand=True)\n\n    # Button Frame\n    btn_frame = ttk.Frame(app)\n    btn_frame.pack(fill=tk.X, padx=10, pady=5)\n    ttk.Button(btn_frame, text=\'Create Note\', command=lambda: open_note_editor()).pack(side=tk.LEFT, padx=5)\n    ttk.Button(btn_frame, text=\'Edit Note\', command=lambda: open_note_editor(edit=True)).pack(side=tk.LEFT, padx=5)\n    ttk.Button(btn_frame, text=\'Delete Note\', command=lambda: delete_note()).pack(side=tk.LEFT, padx=5)\n    ttk.Button(btn_frame, text=\'Preview Markdown\', command=lambda: preview_note()).pack(side=tk.LEFT, padx=5)\n    ttk.Button(btn_frame, text=\'Export Notes\', command=lambda: export_import.export_notes(global_user[\'id\'])).pack(side=tk.LEFT, padx=5)\n    ttk.Button(btn_frame, text=\'Import Notes\', command=lambda: import_notes()).pack(side=tk.LEFT, padx=5)\n\n    def open_note_editor(edit=False):\n        selected = None\n        if edit:\n            sel = note_list.selection()\n            if not sel:\n                messagebox.showwarning(\'Warning\', \'No note selected.\')\n                return\n            note_id = sel[0]\n            selected = db.get_note_by_id(note_id)\n\n        editor = tk.Toplevel(app)\n        editor.title(\'Note Editor\')\n        editor.geometry(\'600x500\')\n        \n        ttk.Label(editor, text=\'Title:\').pack(pady=2)\n        title_var = tk.StringVar()\n        title_entry = ttk.Entry(editor, textvariable=title_var)\n        title_entry.pack(fill=tk.X, padx=10)\n        \n        ttk.Label(editor, text=\'Tags (comma separated):\').pack(pady=2)\n        tags_var = tk.StringVar()\n        tags_entry = ttk.Entry(editor, textvariable=tags_var)\n        tags_entry.pack(fill=tk.X, padx=10)\n\n        ttk.Label(editor, text=\'Categories (comma separated):\').pack(pady=2)\n        categories_var = tk.StringVar()\n        categories_entry = ttk.Entry(editor, textvariable=categories_var)\n        categories_entry.pack(fill=tk.X, padx=10)\n\n        ttk.Label(editor, text=\'Markdown Content:\').pack(pady=2)\n        content_text = tk.Text(editor, height=15)\n        content_text.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)\n\n        if selected is not None:\n            title_var.set(selected[\'title\'])\n            tags_var.set(selected[\'tags\'])\n            categories_var.set(selected[\'categories\'])\n            try:\n                decrypted = encryption.decrypt_data(global_user[\'encryption_key\'], selected[\'content\'])\n            except Exception as e:\n                decrypted = ""\n            content_text.insert(\'1.0\', decrypted)\n\n        def save_note():\n            title = title_var.get()\n            tags = tags_var.get()\n            categories = categories_var.get()\n            content = content_text.get(\'1.0\', tk.END).strip()\n            encrypted_content = encryption.encrypt_data(global_user[\'encryption_key\'], content)\n            timestamp = datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\')\n            if edit and selected is not None:\n                db.update_note(selected[\'id\'], title, encrypted_content, timestamp, tags, categories)\n            else:\n                db.add_note(global_user[\'id\'], title, encrypted_content, timestamp, tags, categories)\n            refresh_note_list()\n            editor.destroy()\n\n        ttk.Button(editor, text=\'Save\', command=save_note).pack(pady=5)\n\n    def delete_note():\n        sel = note_list.selection()\n        if not sel:\n            messagebox.showwarning(\'Warning\', \'No note selected.\')\n            return\n        note_id = sel[0]\n        if messagebox.askyesno(\'Confirm\', \'Are you sure you want to delete this note?\'):\n            db.delete_note(note_id)\n            refresh_note_list()\n\n    def preview_note():\n        sel = note_list.selection()\n        if not sel:\n            messagebox.showwarning(\'Warning\', \'No note selected.\')\n            return\n        note_id = sel[0]\n        note_data = db.get_note_by_id(note_id)\n        try:\n            decrypted = encryption.decrypt_data(global_user[\'encryption_key\'], note_data[\'content\'])\n        except Exception as e:\n            messagebox.showerror(\'Error\', \'Could not decrypt note content.\')\n            return\n        # Convert Markdown to HTML\n        html_content = markdown.markdown(decrypted, extensions=[\'fenced_code\'])\n\n        preview = tk.Toplevel(app)\n        preview.title(\'Markdown Preview\')\n        preview.geometry(\'600x500\')\n        text_widget = tk.Text(preview, wrap=tk.WORD)\n        text_widget.insert(\'1.0\', html_content)\n        text_widget.pack(fill=tk.BOTH, expand=True)\n\n    def import_notes():\n        file_path = filedialog.askopenfilename(title=\'Select JSON file\', filetypes=[(\'JSON Files\', \'*.json\')])\n        if file_path:\n            result = export_import.import_notes(global_user[\'id\'], file_path, global_user[\'encryption_key\'])\n            if result:\n                messagebox.showinfo(\'Success\', \'Notes imported successfully.\')\n                refresh_note_list()\n            else:\n                messagebox.showerror(\'Error\', \'There was an error importing notes.\')\n\n    refresh_note_list()\n    app.mainloop()\n\n\nif __name__ == \'__main__\':\n    db.initialize_db()\n    login_window()PK\x03\x04\x14\x00\x00\x00\x00\x00RWH[\xb3\xea\xceDy\r\x00\x00y\r\x00\x00\x05\x00\x00\x00db.pyimport sqlite3\nimport os\n\nDB_NAME = \'notes_app.db\'\n\n\ndef get_connection():\n    conn = sqlite3.connect(DB_NAME)\n    conn.row_factory = sqlite3.Row\n    return conn\n\n\ndef initialize_db():\n    conn = get_connection()\n    cursor = conn.cursor()\n\n    # Create users table\n    cursor.execute(\'\'\'\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            username TEXT UNIQUE NOT NULL,\n            password_hash TEXT NOT NULL\n        )\n    \'\'\')\n\n    # Create notes table\n    cursor.execute(\'\'\'\n        CREATE TABLE IF NOT EXISTS notes (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user_id INTEGER NOT NULL,\n            title TEXT NOT NULL,\n            content BLOB NOT NULL,\n            timestamp TEXT NOT NULL,\n            tags TEXT,\n            categories TEXT,\n            FOREIGN KEY (user_id) REFERENCES users (id)\n        )\n    \'\'\')\n\n    conn.commit()\n    conn.close()\n\n\ndef add_user(username, password_hash):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\'INSERT INTO users (username, password_hash) VALUES (?, ?)\', (username, password_hash))\n    conn.commit()\n    conn.close()\n\n\ndef get_user(username):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\'SELECT * FROM users WHERE username=?\', (username,))\n    row = cursor.fetchone()\n    conn.close()\n    if row:\n        return dict(row)\n    return None\n\n\ndef add_note(user_id, title, content, timestamp, tags, categories):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\'\'\'\n        INSERT INTO notes (user_id, title, content, timestamp, tags, categories)\n        VALUES (?, ?, ?, ?, ?, ?)\n    \'\'\', (user_id, title, content, timestamp, tags, categories))\n    conn.commit()\n    conn.close()\n\n\ndef update_note(note_id, title, content, timestamp, tags, categories):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\'\'\'\n        UPDATE notes\n        SET title=?, content=?, timestamp=?, tags=?, categories=?\n        WHERE id=?\n    \'\'\', (title, content, timestamp, tags, categories, note_id))\n    conn.commit()\n    conn.close()\n\n\ndef delete_note(note_id):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\'DELETE FROM notes WHERE id=?\', (note_id,))\n    conn.commit()\n    conn.close()\n\n\ndef get_notes(user_id):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\'SELECT * FROM notes WHERE user_id=? ORDER BY timestamp DESC\', (user_id,))\n    rows = cursor.fetchall()\n    conn.close()\n    return [dict(row) for row in rows]\n\n\ndef get_note_by_id(note_id):\n    conn = get_connection()\n    cursor = conn.cursor()\n    cursor.execute(\'SELECT * FROM notes WHERE id=?\', (note_id,))\n    row = cursor.fetchone()\n    conn.close()\n    if row:\n        return dict(row)\n    return None\n\n\ndef search_notes(user_id, query):\n    conn = get_connection()\n    cursor = conn.cursor()\n    if query.strip() == "":\n        cursor.execute(\'SELECT * FROM notes WHERE user_id=? ORDER BY timestamp DESC\', (user_id,))\n    else:\n        like_query = f\'%{query}%\' \n        cursor.execute(\'\'\'\n            SELECT * FROM notes \n            WHERE user_id=? AND (title LIKE ? OR tags LIKE ? OR categories LIKE ? OR timestamp LIKE ?)\n            ORDER BY timestamp DESC\n        \'\'\', (user_id, like_query, like_query, like_query, like_query))\n    rows = cursor.fetchall()\n    conn.close()\n    return [dict(row) for row in rows]\nPK\x03\x04\x14\x00\x00\x00\x00\x00RWH[vLMh^\x03\x00\x00^\x03\x00\x00\r\x00\x00\x00encryption.pyimport base64\nimport os\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.fernet import Fernet\n\n# In a production system, use a unique salt per user and store it securely.\n# For this MVP, we use a constant salt.\nSALT = b\'static_salt_12345\'\n\n\ndef derive_key(password: str) -> bytes:\n    password_bytes = password.encode()\n    kdf = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=SALT,\n        iterations=100000,\n    )\n    key = base64.urlsafe_b64encode(kdf.derive(password_bytes))\n    return key\n\n\ndef encrypt_data(key: bytes, data: str) -> bytes:\n    f = Fernet(key)\n    token = f.encrypt(data.encode())\n    return token\n\n\ndef decrypt_data(key: bytes, token: bytes) -> str:\n    f = Fernet(key)\n    data = f.decrypt(token)\n    return data.decode()\nPK\x03\x04\x14\x00\x00\x00\x00\x00RWH[\xbe\r\xb7\'\x9c\x07\x00\x00\x9c\x07\x00\x00\x10\x00\x00\x00export_import.pyimport json\nimport os\nimport db\nimport encryption\nimport tkinter as tk\nfrom tkinter import filedialog, messagebox\n\n\ndef export_notes(user_id):\n    notes = db.get_notes(user_id)\n    # Prepare export data. Note: encrypted content is stored; export as base64 encoded string if needed\n    export_data = []\n    for note in notes:\n        export_data.append({\n            \'id\': note[\'id\'],\n            \'title\': note[\'title\'],\n            \'content\': note[\'content\'].decode(\'utf-8\') if isinstance(note[\'content\'], bytes) else note[\'content\'],\n            \'timestamp\': note[\'timestamp\'],\n            \'tags\': note[\'tags\'],\n            \'categories\': note[\'categories\']\n        })\n    \n    root = tk.Tk()\n    root.withdraw()\n    file_path = filedialog.asksaveasfilename(\n        defaultextension=\'.json\',\n        filetypes=[(\'JSON Files\', \'*.json\')],\n        title=\'Export Notes\')\n    if file_path:\n        try:\n            with open(file_path, \'w\', encoding=\'utf-8\') as f:\n                json.dump(export_data, f, indent=4)\n            messagebox.showinfo(\'Export\', \'Notes exported successfully.\')\n        except Exception as e:\n            messagebox.showerror(\'Export Error\', str(e))\n    root.destroy()\n\n\ndef import_notes(user_id, file_path, encryption_key):\n    try:\n        with open(file_path, \'r\', encoding=\'utf-8\') as f:\n            data = json.load(f)\n        # Validate schema\n        for note in data:\n            if not all(k in note for k in (\'title\', \'content\', \'timestamp\')):\n                return False\n            # Re-encrypt the content before storing\n            encrypted_content = encryption.encrypt_data(encryption_key, note[\'content\'])\n            tags = note.get(\'tags\', \'\')\n            categories = note.get(\'categories\', \'\')\n            db.add_note(user_id, note[\'title\'], encrypted_content, note[\'timestamp\'], tags, categories)\n        return True\n    except Exception as e:\n        print(\'Import error:\', e)\n        return False\nPK\x03\x04\x14\x00\x00\x00\x00\x00RWH[u\xd2PE\xe0\x01\x00\x00\xe0\x01\x00\x00\x07\x00\x00\x00user.pyimport bcrypt\nimport db\n\n\ndef hash_password(password: str) -> str:\n    salt = bcrypt.gensalt()\n    hashed = bcrypt.hashpw(password.encode(), salt)\n    return hashed.decode()\n\n\ndef check_password(password: str, hashed: str) -> bool:\n    return bcrypt.checkpw(password.encode(), hashed.encode())\n\n\ndef register_user(username: str, password: str):\n    hashed = hash_password(password)\n    db.add_user(username, hashed)\n\n\ndef get_user(username: str):\n    return db.get_user(username)\nPK\x03\x04\x14\x00\x00\x00\x00\x00RWH[\x0c\xf4\xac\x95\x1d\x00\x00\x00\x1d\x00\x00\x00\x10\x00\x00\x00requirements.txtbcrypt\ncryptography\nmarkdown\nPK\x03\x04\x14\x00\x00\x00\x00\x00RWH[\x02a\xa7\x1c;\x04\x00\x00;\x04\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nAdd support for note categories and tags:\n- Implement a search function for notes\n- Store note metadata (timestamps, tags, categories)\n- Export and import notes as JSON files\nRich Text & Formatting:\n- Support for Markdown and Rich-Text (bold, italic, headings, lists)\n- Add highlighting and color options for notes\n- Support code snippets with syntax highlighting\nAuthentication & Security (local):\n- Implement local user accounts with username and password\n- Securely store passwords using hashing (e.g., bcrypt or argon2)\n- Encrypt all notes using a key derived from the user\'s password (AES or Fernet)\n- Allow multiple users on the same device, each with their own notes\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00RWH[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00RWH[\xd7P\x8c\xf1\xe1#\x00\x00\xe1#\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00RWH[\xb3\xea\xceDy\r\x00\x00y\r\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x06$\x00\x00db.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00RWH[vLMh^\x03\x00\x00^\x03\x00\x00\r\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xa21\x00\x00encryption.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00RWH[\xbe\r\xb7\'\x9c\x07\x00\x00\x9c\x07\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01+5\x00\x00export_import.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00RWH[u\xd2PE\xe0\x01\x00\x00\xe0\x01\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xf5<\x00\x00user.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00RWH[\x0c\xf4\xac\x95\x1d\x00\x00\x00\x1d\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xfa>\x00\x00requirements.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00RWH[\x02a\xa7\x1c;\x04\x00\x00;\x04\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01E?\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00RWH[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xaeC\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\x08\x00\x08\x00\xd6\x01\x00\x00\x0bD\x00\x00\x00\x00'