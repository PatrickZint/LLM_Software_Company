b'PK\x03\x04\x14\x00\x00\x00\x00\x00\xfbTH[-\x84\x82\x05P\x02\x00\x00P\x02\x00\x00\x07\x00\x00\x00main.pyimport tkinter as tk\nfrom auth import LoginWindow\nfrom note_app import NoteApp\n\n\ndef main():\n    root = tk.Tk()\n    root.title("Note App - Login")\n    root.geometry("300x200")\n\n    # Start with login window\n    login_window = LoginWindow(root, on_success=launch_app)\n\n    root.mainloop()\n\n\ndef launch_app(user, encryption_key):\n    # Destroys the current window widgets and launches the note app UI\n    root = tk._default_root\n    for widget in root.winfo_children():\n        widget.destroy()\n    app = NoteApp(user, encryption_key)\n    app.mainloop()\n\n\nif __name__ == \'__main__\':\n    main()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xfbTH[\xdf\x92u|\x84\n\x00\x00\x84\n\x00\x00\x07\x00\x00\x00auth.pyimport tkinter as tk\nfrom tkinter import messagebox\nimport bcrypt\nfrom database import get_user_by_username, create_user\nfrom encryption_helper import derive_key, generate_salt\n\n\nclass LoginWindow(tk.Frame):\n    def __init__(self, master, on_success):\n        super().__init__(master)\n        self.on_success = on_success\n        self.pack(pady=20)\n\n        tk.Label(self, text="Login").pack()\n\n        tk.Label(self, text="Username").pack()\n        self.username_entry = tk.Entry(self)\n        self.username_entry.pack()\n\n        tk.Label(self, text="Password").pack()\n        self.password_entry = tk.Entry(self, show="*")\n        self.password_entry.pack()\n\n        tk.Button(self, text="Login", command=self.login).pack(pady=5)\n        tk.Button(self, text="Register", command=self.open_register).pack(pady=5)\n\n    def login(self):\n        username = self.username_entry.get()\n        password = self.password_entry.get().encode(\'utf-8\')\n        user = get_user_by_username(username)\n        if user and bcrypt.checkpw(password, user[\'password_hash\']):\n            # Derive an encryption key based on user\'s password and stored salt\n            encryption_key = derive_key(password, user[\'encryption_salt\'])\n            messagebox.showinfo("Success", "Logged in successfully!")\n            self.on_success(user, encryption_key)\n        else:\n            messagebox.showerror("Error", "Invalid username or password.")\n\n    def open_register(self):\n        register_win = tk.Toplevel(self)\n        RegisterWindow(register_win)\n\n\nclass RegisterWindow(tk.Frame):\n    def __init__(self, master):\n        super().__init__(master)\n        self.master = master\n        self.pack(pady=20)\n\n        tk.Label(self, text="Register").pack()\n\n        tk.Label(self, text="Username").pack()\n        self.username_entry = tk.Entry(self)\n        self.username_entry.pack()\n\n        tk.Label(self, text="Password").pack()\n        self.password_entry = tk.Entry(self, show="*")\n        self.password_entry.pack()\n\n        tk.Button(self, text="Register", command=self.register).pack(pady=5)\n\n    def register(self):\n        username = self.username_entry.get()\n        password = self.password_entry.get().encode(\'utf-8\')\n        if get_user_by_username(username):\n            tk.messagebox.showerror("Error", "Username already exists!")\n            return\n        \n        # Generate a salt for encryption and hash password with bcrypt\n        encryption_salt = generate_salt()\n        password_hash = bcrypt.hashpw(password, bcrypt.gensalt())\n        create_user(username, password_hash, encryption_salt)\n        tk.messagebox.showinfo("Success", "Registration successful!")\n        self.master.destroy()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xfbTH[\x80\x00\xe4\xcb\xce\x02\x00\x00\xce\x02\x00\x00\x14\x00\x00\x00encryption_helper.pyimport base64\nimport os\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\nfrom cryptography.fernet import Fernet\n\n\ndef generate_salt():\n    return os.urandom(16)\n\n\ndef derive_key(password, salt):\n    # Derive a 32-byte key from the password and salt using PBKDF2\n    kdf = PBKDF2HMAC(\n        algorithm=hashes.SHA256(),\n        length=32,\n        salt=salt,\n        iterations=100000,\n    )\n    key = base64.urlsafe_b64encode(kdf.derive(password))\n    return key\n\n\ndef encrypt_text(key, text):\n    f = Fernet(key)\n    return f.encrypt(text.encode(\'utf-8\'))\n\n\ndef decrypt_text(key, token):\n    f = Fernet(key)\n    return f.decrypt(token).decode(\'utf-8\')\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xfbTH[KQ\xaa\xb6_\x0b\x00\x00_\x0b\x00\x00\x0b\x00\x00\x00database.pyimport sqlite3\n\nDB_PATH = "notes_app.db"\n\n\ndef get_connection():\n    conn = sqlite3.connect(DB_PATH)\n    conn.row_factory = sqlite3.Row\n    return conn\n\n\ndef init_db():\n    conn = get_connection()\n    c = conn.cursor()\n    # Create users table\n    c.execute(\'\'\'\n        CREATE TABLE IF NOT EXISTS users (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            username TEXT UNIQUE,\n            password_hash BLOB,\n            encryption_salt BLOB\n        )\n    \'\'\')\n    \n    # Create notes table\n    c.execute(\'\'\'\n        CREATE TABLE IF NOT EXISTS notes (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            user_id INTEGER,\n            title TEXT,\n            content BLOB,\n            timestamp TEXT,\n            tags TEXT,\n            category TEXT,\n            FOREIGN KEY(user_id) REFERENCES users(id)\n        )\n    \'\'\')\n    \n    conn.commit()\n    conn.close()\n\n\ndef get_user_by_username(username):\n    conn = get_connection()\n    c = conn.cursor()\n    c.execute("SELECT * FROM users WHERE username = ?", (username,))\n    user = c.fetchone()\n    conn.close()\n    if user:\n        return dict(user)\n    return None\n\n\ndef create_user(username, password_hash, encryption_salt):\n    conn = get_connection()\n    c = conn.cursor()\n    c.execute("INSERT INTO users (username, password_hash, encryption_salt) VALUES (?, ?, ?)", (username, password_hash, encryption_salt))\n    conn.commit()\n    conn.close()\n\n\ndef create_note(user_id, title, content, timestamp, tags, category):\n    conn = get_connection()\n    c = conn.cursor()\n    c.execute("INSERT INTO notes (user_id, title, content, timestamp, tags, category) VALUES (?, ?, ?, ?, ?, ?)",\n              (user_id, title, content, timestamp, tags, category))\n    conn.commit()\n    conn.close()\n\n\ndef update_note(note_id, title, content, timestamp, tags, category):\n    conn = get_connection()\n    c = conn.cursor()\n    c.execute("UPDATE notes SET title = ?, content = ?, timestamp = ?, tags = ?, category = ? WHERE id = ?",\n              (title, content, timestamp, tags, category, note_id))\n    conn.commit()\n    conn.close()\n\n\ndef delete_note(note_id):\n    conn = get_connection()\n    c = conn.cursor()\n    c.execute("DELETE FROM notes WHERE id = ?", (note_id,))\n    conn.commit()\n    conn.close()\n\n\ndef get_notes_by_user(user_id):\n    conn = get_connection()\n    c = conn.cursor()\n    c.execute("SELECT * FROM notes WHERE user_id = ?", (user_id,))\n    notes = c.fetchall()\n    conn.close()\n    return [dict(note) for note in notes]\n\n\ndef search_notes(user_id, query):\n    conn = get_connection()\n    c = conn.cursor()\n    q = f"%{query}%"\n    c.execute("SELECT * FROM notes WHERE user_id = ? AND (title LIKE ? OR content LIKE ? OR tags LIKE ? OR category LIKE ?)",\n              (user_id, q, q, q, q))\n    notes = c.fetchall()\n    conn.close()\n    return [dict(note) for note in notes]\n\n\n# Initialize database when module is loaded\ninit_db()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xfbTH[\x8d&\xa9f\xc3\x1c\x00\x00\xc3\x1c\x00\x00\x0b\x00\x00\x00note_app.pyimport tkinter as tk\nfrom tkinter import messagebox, filedialog\nfrom database import create_note, update_note, delete_note, get_notes_by_user, search_notes\nfrom encryption_helper import encrypt_text, decrypt_text\nimport json\nfrom datetime import datetime\n\n\nclass NoteApp(tk.Tk):\n    def __init__(self, user, encryption_key):\n        super().__init__()\n        self.title("Note App")\n        self.geometry("800x600")\n        self.user = user\n        self.encryption_key = encryption_key\n\n        # Search bar\n        search_frame = tk.Frame(self)\n        search_frame.pack(pady=5)\n        self.search_var = tk.StringVar()\n        tk.Entry(search_frame, textvariable=self.search_var, width=50).pack(side=tk.LEFT, padx=5)\n        tk.Button(search_frame, text="Search", command=self.search_notes).pack(side=tk.LEFT, padx=5)\n\n        # Notes list\n        self.notes_listbox = tk.Listbox(self, width=80)\n        self.notes_listbox.pack(pady=10)\n        self.notes_listbox.bind(\'<<ListboxSelect>>\', self.load_note)\n\n        # Note details\n        details_frame = tk.Frame(self)\n        details_frame.pack(pady=5)\n\n        tk.Label(details_frame, text="Title:").grid(row=0, column=0, sticky=tk.W)\n        self.title_var = tk.StringVar()\n        self.title_entry = tk.Entry(details_frame, textvariable=self.title_var, width=80)\n        self.title_entry.grid(row=0, column=1, pady=5)\n\n        tk.Label(details_frame, text="Content:").grid(row=1, column=0, sticky=tk.NW)\n        self.content_text = tk.Text(details_frame, width=60, height=15)\n        self.content_text.grid(row=1, column=1, pady=5)\n\n        tk.Label(details_frame, text="Tags (comma separated):").grid(row=2, column=0, sticky=tk.W)\n        self.tags_entry = tk.Entry(details_frame, width=80)\n        self.tags_entry.grid(row=2, column=1, pady=5)\n\n        tk.Label(details_frame, text="Category:").grid(row=3, column=0, sticky=tk.W)\n        self.category_entry = tk.Entry(details_frame, width=80)\n        self.category_entry.grid(row=3, column=1, pady=5)\n\n        # Buttons\n        btn_frame = tk.Frame(self)\n        btn_frame.pack(pady=10)\n        tk.Button(btn_frame, text="Add Note", command=self.add_note).grid(row=0, column=0, padx=5)\n        tk.Button(btn_frame, text="Update Note", command=self.update_note).grid(row=0, column=1, padx=5)\n        tk.Button(btn_frame, text="Delete Note", command=self.delete_note).grid(row=0, column=2, padx=5)\n        tk.Button(btn_frame, text="Export Notes", command=self.export_notes).grid(row=0, column=3, padx=5)\n        tk.Button(btn_frame, text="Import Notes", command=self.import_notes).grid(row=0, column=4, padx=5)\n\n        self.selected_note = None\n        self.refresh_notes()\n\n    def refresh_notes(self, notes=None):\n        self.notes_listbox.delete(0, tk.END)\n        if notes is None:\n            notes = get_notes_by_user(self.user[\'id\'])\n        self.notes = notes\n        for note in notes:\n            # Display the note title and timestamp\n            display = f"{note[\'title\']} - {note[\'timestamp\']}"\n            self.notes_listbox.insert(tk.END, display)\n\n    def load_note(self, event):\n        selection = self.notes_listbox.curselection()\n        if selection:\n            index = selection[0]\n            note = self.notes[index]\n            self.selected_note = note\n            self.title_var.set(note[\'title\'])\n            try:\n                content = decrypt_text(self.encryption_key, note[\'content\'])\n            except Exception:\n                content = "[Decryption Error]"\n            self.content_text.delete("1.0", tk.END)\n            self.content_text.insert(tk.END, content)\n            self.tags_entry.delete(0, tk.END)\n            self.tags_entry.insert(0, note[\'tags\'] if note[\'tags\'] else "")\n            self.category_entry.delete(0, tk.END)\n            self.category_entry.insert(0, note[\'category\'] if note[\'category\'] else "")\n\n    def add_note(self):\n        title = self.title_entry.get()\n        content = self.content_text.get("1.0", tk.END).strip()\n        tags = self.tags_entry.get()\n        category = self.category_entry.get()\n        if not title or not content:\n            messagebox.showerror("Error", "Title and content cannot be empty")\n            return\n        \n        encrypted_content = encrypt_text(self.encryption_key, content)\n        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")\n        create_note(self.user[\'id\'], title, encrypted_content, timestamp, tags, category)\n        messagebox.showinfo("Success", "Note added successfully!")\n        self.refresh_notes()\n\n    def update_note(self):\n        if not self.selected_note:\n            messagebox.showerror("Error", "No note selected")\n            return\n        title = self.title_entry.get()\n        content = self.content_text.get("1.0", tk.END).strip()\n        tags = self.tags_entry.get()\n        category = self.category_entry.get()\n        if not title or not content:\n            messagebox.showerror("Error", "Title and content cannot be empty")\n            return\n        \n        encrypted_content = encrypt_text(self.encryption_key, content)\n        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")\n        update_note(self.selected_note[\'id\'], title, encrypted_content, timestamp, tags, category)\n        messagebox.showinfo("Success", "Note updated successfully!")\n        self.refresh_notes()\n\n    def delete_note(self):\n        if not self.selected_note:\n            messagebox.showerror("Error", "No note selected")\n            return\n        delete_note(self.selected_note[\'id\'])\n        messagebox.showinfo("Success", "Note deleted successfully!")\n        self.refresh_notes()\n\n    def search_notes(self):\n        query = self.search_var.get()\n        if query.strip() == "":\n            self.refresh_notes()\n        else:\n            notes = search_notes(self.user[\'id\'], query)\n            self.refresh_notes(notes)\n\n    def export_notes(self):\n        notes = get_notes_by_user(self.user[\'id\'])\n        export_data = []\n        for note in notes:\n            try:\n                content = decrypt_text(self.encryption_key, note[\'content\'])\n            except Exception:\n                content = "[Decryption Error]"\n            export_data.append({\n                "title": note[\'title\'],\n                "content": content,\n                "timestamp": note[\'timestamp\'],\n                "tags": note[\'tags\'],\n                "category": note[\'category\']\n            })\n        \n        file_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON Files", "*.json")])\n        if file_path:\n            with open(file_path, "w") as f:\n                json.dump(export_data, f, indent=4)\n            messagebox.showinfo("Success", "Notes exported successfully!")\n\n    def import_notes(self):\n        file_path = filedialog.askopenfilename(filetypes=[("JSON Files", "*.json")])\n        if file_path:\n            with open(file_path, "r") as f:\n                imported_notes = json.load(f)\n            for note in imported_notes:\n                encrypted_content = encrypt_text(self.encryption_key, note["content"])\n                create_note(self.user[\'id\'], note["title"], encrypted_content, note["timestamp"], note.get("tags", ""), note.get("category", ""))\n            messagebox.showinfo("Success", "Notes imported successfully!")\n            self.refresh_notes()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xfbTH[\x02a\xa7\x1c;\x04\x00\x00;\x04\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nAdd support for note categories and tags:\n- Implement a search function for notes\n- Store note metadata (timestamps, tags, categories)\n- Export and import notes as JSON files\nRich Text & Formatting:\n- Support for Markdown and Rich-Text (bold, italic, headings, lists)\n- Add highlighting and color options for notes\n- Support code snippets with syntax highlighting\nAuthentication & Security (local):\n- Implement local user accounts with username and password\n- Securely store passwords using hashing (e.g., bcrypt or argon2)\n- Encrypt all notes using a key derived from the user\'s password (AES or Fernet)\n- Allow multiple users on the same device, each with their own notes\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00\xfbTH[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xfbTH[-\x84\x82\x05P\x02\x00\x00P\x02\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xfbTH[\xdf\x92u|\x84\n\x00\x00\x84\n\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01u\x02\x00\x00auth.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xfbTH[\x80\x00\xe4\xcb\xce\x02\x00\x00\xce\x02\x00\x00\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x1e\r\x00\x00encryption_helper.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xfbTH[KQ\xaa\xb6_\x0b\x00\x00_\x0b\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x1e\x10\x00\x00database.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xfbTH[\x8d&\xa9f\xc3\x1c\x00\x00\xc3\x1c\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xa6\x1b\x00\x00note_app.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xfbTH[\x02a\xa7\x1c;\x04\x00\x00;\x04\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x928\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xfbTH[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xfb<\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\x07\x00\x07\x00\xa0\x01\x00\x00X=\x00\x00\x00\x00'