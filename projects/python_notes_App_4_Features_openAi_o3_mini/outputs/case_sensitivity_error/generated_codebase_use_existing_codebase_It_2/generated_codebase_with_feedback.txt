b'PK\x03\x04\x14\x00\x00\x00\x00\x00XaH[`\xabe\xde\x12\x01\x00\x00\x12\x01\x00\x00\x07\x00\x00\x00main.pyimport tkinter as tk\nfrom view_main import MainView\n\n\ndef main():\n    root = tk.Tk()\n    root.title(\'Note Taking App\')\n    # Set a minimum size if needed\n    root.geometry(\'800x600\')\n    app = MainView(master=root)\n    app.mainloop()\n\n\nif __name__ == \'__main__\':\n    main()\nPK\x03\x04\x14\x00\x00\x00\x00\x00XaH[\xdc\xb9\x0cx\xfe/\x00\x00\xfe/\x00\x00\x0c\x00\x00\x00view_main.pyimport tkinter as tk\nfrom tkinter import ttk, messagebox, filedialog, font\n\nfrom note_controller import NoteController\nfrom config_manager import ConfigManager\nfrom formatting_controller import FormattingController\n\n\nclass MainView(tk.Frame):\n    def __init__(self, master=None):\n        super().__init__(master)\n        self.master = master\n        self.pack(fill=tk.BOTH, expand=True)\n        self.controller = NoteController()\n        self.config_manager = ConfigManager()\n        self.formatting_controller = FormattingController()\n        self.current_format_mode = "WYSIWYG"  # Modes: WYSIWYG or Markdown\n        self.current_note_id = None\n        self.notes = []\n        self.create_widgets()\n        self.load_notes()\n\n    def create_widgets(self):\n        # Header Frame for navigation buttons\n        self.header_frame = tk.Frame(self, height=50, bg=\'lightgray\')\n        self.header_frame.pack(side=tk.TOP, fill=tk.X)\n\n        self.btn_create = tk.Button(self.header_frame, text=\'Create Note\', command=self.create_note)\n        self.btn_create.pack(side=tk.LEFT, padx=5, pady=10)\n        self.btn_export = tk.Button(self.header_frame, text=\'Export\', command=self.export_notes)\n        self.btn_export.pack(side=tk.LEFT, padx=5, pady=10)\n        self.btn_import = tk.Button(self.header_frame, text=\'Import\', command=self.import_notes)\n        self.btn_import.pack(side=tk.LEFT, padx=5, pady=10)\n\n        # Sidebar Frame for filters (e.g., search, categories, tags)\n        self.sidebar_frame = tk.Frame(self, width=200, bg=\'white\')\n        self.sidebar_frame.pack(side=tk.LEFT, fill=tk.Y)\n\n        # Search field in sidebar\n        self.lbl_search = tk.Label(self.sidebar_frame, text=\'Search\', bg=\'white\')\n        self.lbl_search.pack(padx=10, pady=(10,0))\n        self.ent_search = tk.Entry(self.sidebar_frame)\n        self.ent_search.pack(padx=10, pady=5, fill=tk.X)\n        self.btn_search = tk.Button(self.sidebar_frame, text=\'Search\', command=self.do_search)\n        self.btn_search.pack(padx=10, pady=5)\n        self.btn_clear_search = tk.Button(self.sidebar_frame, text=\'Clear\', command=self.load_notes)\n        self.btn_clear_search.pack(padx=10, pady=5)\n\n        # Main Frame for list view and detailed editor\n        self.main_frame = tk.Frame(self, bg=\'white\')\n        self.main_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n\n        # List of notes\n        self.list_frame = tk.Frame(self.main_frame, bg=\'white\')\n        self.list_frame.pack(side=tk.LEFT, fill=tk.Y, padx=5, pady=5)\n        self.note_list = tk.Listbox(self.list_frame, width=30)\n        self.note_list.pack(side=tk.TOP, fill=tk.Y, expand=True)\n        self.note_list.bind(\'<<ListboxSelect>>\', self.on_note_select)\n\n        # Editor Panel\n        self.editor_frame = tk.Frame(self.main_frame, bg=\'white\')\n        self.editor_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)\n\n        # Fields for Title, Categories and Tags\n        self.meta_frame = tk.Frame(self.editor_frame, bg=\'white\')\n        self.meta_frame.pack(side=tk.TOP, fill=tk.X, pady=(0,5))\n\n        tk.Label(self.meta_frame, text=\'Title:\').grid(row=0, column=0, padx=2, pady=2, sticky=\'e\')\n        self.ent_title = tk.Entry(self.meta_frame)\n        self.ent_title.grid(row=0, column=1, padx=2, pady=2, sticky=\'we\')\n\n        tk.Label(self.meta_frame, text=\'Categories (comma separated):\').grid(row=1, column=0, padx=2, pady=2, sticky=\'e\')\n        self.ent_categories = tk.Entry(self.meta_frame)\n        self.ent_categories.grid(row=1, column=1, padx=2, pady=2, sticky=\'we\')\n\n        tk.Label(self.meta_frame, text=\'Tags (comma separated):\').grid(row=2, column=0, padx=2, pady=2, sticky=\'e\')\n        self.ent_tags = tk.Entry(self.meta_frame)\n        self.ent_tags.grid(row=2, column=1, padx=2, pady=2, sticky=\'we\')\n\n        self.meta_frame.columnconfigure(1, weight=1)\n\n        # Formatting toolbar above the text editor\n        self.formatting_frame = tk.Frame(self.editor_frame, bg=\'lightblue\')\n        self.formatting_frame.pack(side=tk.TOP, fill=tk.X)\n        self.btn_bold = tk.Button(self.formatting_frame, text="Bold", command=lambda: self.apply_format("bold"))\n        self.btn_bold.pack(side=tk.LEFT, padx=2, pady=2)\n        self.btn_italic = tk.Button(self.formatting_frame, text="Italic", command=lambda: self.apply_format("italic"))\n        self.btn_italic.pack(side=tk.LEFT, padx=2, pady=2)\n        self.btn_underline = tk.Button(self.formatting_frame, text="Underline", command=lambda: self.apply_format("underline"))\n        self.btn_underline.pack(side=tk.LEFT, padx=2, pady=2)\n        self.btn_code = tk.Button(self.formatting_frame, text="Code", command=lambda: self.apply_format("code"))\n        self.btn_code.pack(side=tk.LEFT, padx=2, pady=2)\n        self.btn_toggle_mode = tk.Button(self.formatting_frame, text="Toggle to Markdown", command=self.toggle_format_mode)\n        self.btn_toggle_mode.pack(side=tk.LEFT, padx=2, pady=2)\n\n        # Text editor\n        self.txt_editor = tk.Text(self.editor_frame, wrap=tk.WORD)\n        self.txt_editor.pack(fill=tk.BOTH, expand=True)\n\n        # Setup text tags for WYSIWYG formatting\n        bold_font = font.Font(self.txt_editor, self.txt_editor.cget("font"))\n        bold_font.configure(weight="bold")\n        self.txt_editor.tag_configure("bold", font=bold_font)\n\n        italic_font = font.Font(self.txt_editor, self.txt_editor.cget("font"))\n        italic_font.configure(slant="italic")\n        self.txt_editor.tag_configure("italic", font=italic_font)\n\n        underline_font = font.Font(self.txt_editor, self.txt_editor.cget("font"))\n        underline_font.configure(underline=True)\n        self.txt_editor.tag_configure("underline", font=underline_font)\n\n        code_font = font.Font(family="Courier", size=10)\n        self.txt_editor.tag_configure("code", font=code_font, background="#f0f0f0")\n\n        # Save and Delete buttons\n        self.action_frame = tk.Frame(self.editor_frame, bg=\'white\')\n        self.action_frame.pack(side=tk.TOP, fill=tk.X, pady=5)\n        self.btn_save = tk.Button(self.action_frame, text=\'Save\', command=self.save_note)\n        self.btn_save.pack(side=tk.LEFT, padx=5, pady=5)\n        self.btn_delete = tk.Button(self.action_frame, text=\'Delete\', command=self.delete_note)\n        self.btn_delete.pack(side=tk.LEFT, padx=5, pady=5)\n\n    def apply_format(self, tag):\n        try:\n            # Get selection range\n            start = self.txt_editor.index("sel.first")\n            end = self.txt_editor.index("sel.last")\n        except tk.TclError:\n            messagebox.showwarning("Warning", "Please select text to format")\n            return\n\n        if self.current_format_mode == "WYSIWYG":\n            # Toggle the formatting tag on the selected text\n            if tag in self.txt_editor.tag_names("sel.first"):\n                self.txt_editor.tag_remove(tag, start, end)\n            else:\n                self.txt_editor.tag_add(tag, start, end)\n        else:\n            # In Markdown mode, wrap the selection with corresponding markdown symbols\n            content = self.txt_editor.get(start, end)\n            md_wrappers = {\n                "bold": "**",\n                "italic": "*",\n                "underline": "__",\n                "code": "`\n            }\n            wrapper = md_wrappers.get(tag, "")\n            new_content = wrapper + content + wrapper\n            self.txt_editor.delete(start, end)\n            self.txt_editor.insert(start, new_content)\n\n    def toggle_format_mode(self):\n        if self.current_format_mode == "WYSIWYG":\n            # Convert current text to markdown using formatting_controller (stub implementation)\n            content = self.txt_editor.get("1.0", tk.END)\n            new_content = self.formatting_controller.toggle_formatting(content, mode="markdown")\n            self.txt_editor.delete("1.0", tk.END)\n            self.txt_editor.insert("1.0", new_content)\n            self.current_format_mode = "Markdown"\n            self.btn_toggle_mode.config(text="Toggle to WYSIWYG")\n        else:\n            content = self.txt_editor.get("1.0", tk.END)\n            new_content = self.formatting_controller.toggle_formatting(content, mode="wysiwyg")\n            self.txt_editor.delete("1.0", tk.END)\n            self.txt_editor.insert("1.0", new_content)\n            self.current_format_mode = "WYSIWYG"\n            self.btn_toggle_mode.config(text="Toggle to Markdown")\n\n    def load_notes(self):\n        self.note_list.delete(0, tk.END)\n        self.notes = self.controller.get_all_notes()\n        for note in self.notes:\n            # Display id and title\n            self.note_list.insert(tk.END, f"{note[\'id\']}: {note[\'title\']}")\n        # Clear editor fields\n        self.clear_editor()\n\n    def clear_editor(self):\n        self.current_note_id = None\n        self.ent_title.delete(0, tk.END)\n        self.ent_categories.delete(0, tk.END)\n        self.ent_tags.delete(0, tk.END)\n        self.txt_editor.delete(\'1.0\', tk.END)\n\n    def on_note_select(self, event):\n        selection = self.note_list.curselection()\n        if selection:\n            index = selection[0]\n            note = self.notes[index]\n            self.current_note_id = note[\'id\']\n            self.ent_title.delete(0, tk.END)\n            self.ent_title.insert(0, note[\'title\'])\n            self.ent_categories.delete(0, tk.END)\n            self.ent_categories.insert(0, \', \'.join(note.get(\'categories\', [])))\n            self.ent_tags.delete(0, tk.END)\n            self.ent_tags.insert(0, \', \'.join(note.get(\'tags\', [])))\n            self.txt_editor.delete(\'1.0\', tk.END)\n            self.txt_editor.insert(tk.END, note[\'content\'])\n        else:\n            self.current_note_id = None\n\n    def create_note(self):\n        # Create a new note with default metadata\n        title = \'New Note\'\n        content = \'\'\n        note_id = self.controller.create_note(title, content, categories=[], tags=[])\n        self.load_notes()\n        messagebox.showinfo(\'Info\', \'Note created successfully\')\n\n    def save_note(self):\n        if self.current_note_id:\n            title = self.ent_title.get()\n            content = self.txt_editor.get(\'1.0\', tk.END)\n            # Get categories and tags as lists (split by comma and strip spaces)\n            categories = [c.strip() for c in self.ent_categories.get().split(",") if c.strip()]\n            tags = [t.strip() for t in self.ent_tags.get().split(",") if t.strip()]\n            self.controller.update_note(self.current_note_id, title=title, content=content, categories=categories, tags=tags)\n            self.load_notes()\n            messagebox.showinfo(\'Info\', \'Note updated successfully\')\n        else:\n            messagebox.showwarning(\'Warning\', \'No note selected\')\n\n    def delete_note(self):\n        if self.current_note_id:\n            if messagebox.askyesno(\'Confirm\', \'Are you sure you want to delete this note?\'):\n                self.controller.delete_note(self.current_note_id)\n                self.load_notes()\n                self.clear_editor()\n        else:\n            messagebox.showwarning(\'Warning\', \'No note selected\')\n\n    def export_notes(self):\n        filepath = filedialog.asksaveasfilename(defaultextension=\'.json\', filetypes=[(\'JSON Files\', \'*.json\')])\n        if filepath:\n            success = self.controller.export_notes(filepath)\n            if success:\n                messagebox.showinfo(\'Export\', \'Notes exported successfully\')\n            else:\n                messagebox.showerror(\'Export\', \'Failed to export notes\')\n\n    def import_notes(self):\n        filepath = filedialog.askopenfilename(filetypes=[(\'JSON Files\', \'*.json\')])\n        if filepath:\n            success = self.controller.import_notes(filepath)\n            if success:\n                self.load_notes()\n                messagebox.showinfo(\'Import\', \'Notes imported successfully\')\n            else:\n                messagebox.showerror(\'Import\', \'Failed to import notes\')\n\n    def do_search(self):\n        keyword = self.ent_search.get().strip()\n        if keyword:\n            self.notes = self.controller.search_notes(keyword)\n            self.note_list.delete(0, tk.END)\n            for note in self.notes:\n                self.note_list.insert(tk.END, f"{note[\'id\']}: {note[\'title\']}")\n        else:\n            self.load_notes()\nPK\x03\x04\x14\x00\x00\x00\x00\x00XaH[\xd8\x99\x05/d\x06\x00\x00d\x06\x00\x00\x12\x00\x00\x00note_controller.pyfrom note_dao import NoteDAO\nfrom data_io import import_notes_json, export_notes_json\n\n\nclass NoteController:\n    def __init__(self):\n        self.dao = NoteDAO()\n\n    def get_all_notes(self):\n        # Return a list of note dictionaries\n        return self.dao.get_all_notes()\n\n    def create_note(self, title, content, categories=None, tags=None):\n        note = {\n            \'title\': title,\n            \'content\': content,\n            \'categories\': categories or [],\n            \'tags\': tags or []\n        }\n        return self.dao.create_note(note)\n\n    def update_note(self, note_id, title=None, content=None, categories=None, tags=None):\n        note = self.dao.get_note(note_id)\n        if not note:\n            return None\n        if title is not None:\n            note[\'title\'] = title\n        if content is not None:\n            note[\'content\'] = content\n        if categories is not None:\n            note[\'categories\'] = categories\n        if tags is not None:\n            note[\'tags\'] = tags\n        self.dao.update_note(note_id, note)\n        return note\n\n    def delete_note(self, note_id):\n        self.dao.delete_note(note_id)\n\n    def export_notes(self, filepath):\n        notes = self.dao.get_all_notes()\n        return export_notes_json(notes, filepath)\n\n    def import_notes(self, filepath):\n        notes = import_notes_json(filepath)\n        if notes is None:\n            return False\n        for note in notes:\n            # When importing, we create new note entries\n            self.dao.create_note(note)\n        return True\n\n    def search_notes(self, keyword):\n        return self.dao.search_notes(keyword)\nPK\x03\x04\x14\x00\x00\x00\x00\x00XaH[J\xcc\xbc\xfc\x9a\x10\x00\x00\x9a\x10\x00\x00\x0b\x00\x00\x00note_dao.pyimport sqlite3\nimport os\nimport json\nfrom datetime import datetime\n\n# Define the database path\nDB_PATH = \'data/notes.db\'\n\n\nclass NoteDAO:\n    def __init__(self):\n        os.makedirs(os.path.dirname(DB_PATH), exist_ok=True)\n        self.conn = sqlite3.connect(DB_PATH)\n        self.conn.row_factory = sqlite3.Row\n        self.create_tables()\n\n    def create_tables(self):\n        cursor = self.conn.cursor()\n        # Create Notes table with additional columns for categories and tags\n        cursor.execute(\'\'\'\n            CREATE TABLE IF NOT EXISTS Notes (\n                id INTEGER PRIMARY KEY AUTOINCREMENT,\n                title TEXT NOT NULL,\n                content TEXT,\n                created_at TEXT,\n                updated_at TEXT,\n                categories TEXT,\n                tags TEXT\n            )\n        \'\'\')\n        self.conn.commit()\n\n    def get_all_notes(self):\n        cursor = self.conn.cursor()\n        cursor.execute(\'SELECT * FROM Notes ORDER BY created_at DESC\')\n        rows = cursor.fetchall()\n        notes = []\n        for row in rows:\n            notes.append({\n                \'id\': row[\'id\'],\n                \'title\': row[\'title\'],\n                \'content\': row[\'content\'],\n                \'created_at\': row[\'created_at\'],\n                \'updated_at\': row[\'updated_at\'],\n                \'categories\': json.loads(row[\'categories\']) if row[\'categories\'] else [],\n                \'tags\': json.loads(row[\'tags\']) if row[\'tags\'] else []\n            })\n        return notes\n\n    def get_note(self, note_id):\n        cursor = self.conn.cursor()\n        cursor.execute(\'SELECT * FROM Notes WHERE id=?\', (note_id,))\n        row = cursor.fetchone()\n        if row:\n            return {\n                \'id\': row[\'id\'],\n                \'title\': row[\'title\'],\n                \'content\': row[\'content\'],\n                \'created_at\': row[\'created_at\'],\n                \'updated_at\': row[\'updated_at\'],\n                \'categories\': json.loads(row[\'categories\']) if row[\'categories\'] else [],\n                \'tags\': json.loads(row[\'tags\']) if row[\'tags\'] else []\n            }\n        return None\n\n    def create_note(self, note):\n        cursor = self.conn.cursor()\n        now = datetime.now().isoformat()\n        categories_json = json.dumps(note.get(\'categories\', []))\n        tags_json = json.dumps(note.get(\'tags\', []))\n        cursor.execute(\'\'\'\n            INSERT INTO Notes (title, content, created_at, updated_at, categories, tags)\n            VALUES (?, ?, ?, ?, ?, ?)\n        \'\'\', (note[\'title\'], note[\'content\'], now, now, categories_json, tags_json))\n        self.conn.commit()\n        return cursor.lastrowid\n\n    def update_note(self, note_id, note):\n        cursor = self.conn.cursor()\n        now = datetime.now().isoformat()\n        categories_json = json.dumps(note.get(\'categories\', []))\n        tags_json = json.dumps(note.get(\'tags\', []))\n        cursor.execute(\'\'\'\n            UPDATE Notes\n            SET title=?, content=?, updated_at=?, categories=?, tags=?\n            WHERE id=?\n        \'\'\', (note[\'title\'], note[\'content\'], now, categories_json, tags_json, note_id))\n        self.conn.commit()\n\n    def delete_note(self, note_id):\n        cursor = self.conn.cursor()\n        cursor.execute(\'DELETE FROM Notes WHERE id=?\', (note_id,))\n        self.conn.commit()\n\n    def search_notes(self, keyword):\n        cursor = self.conn.cursor()\n        # Using wildcards for LIKE search on title, content, categories, tags\n        pattern = f\'%{keyword}%\'\n        cursor.execute(\'\'\'\n            SELECT * FROM Notes\n            WHERE title LIKE ? OR content LIKE ? OR categories LIKE ? OR tags LIKE ?\n            ORDER BY created_at DESC\n        \'\'\', (pattern, pattern, pattern, pattern))\n        rows = cursor.fetchall()\n        notes = []\n        for row in rows:\n            notes.append({\n                \'id\': row[\'id\'],\n                \'title\': row[\'title\'],\n                \'content\': row[\'content\'],\n                \'created_at\': row[\'created_at\'],\n                \'updated_at\': row[\'updated_at\'],\n                \'categories\': json.loads(row[\'categories\']) if row[\'categories\'] else [],\n                \'tags\': json.loads(row[\'tags\']) if row[\'tags\'] else []\n            })\n        return notes\nPK\x03\x04\x14\x00\x00\x00\x00\x00XaH[\'\x01\xbeL\x99\x04\x00\x00\x99\x04\x00\x00\x11\x00\x00\x00config_manager.pyimport json\nimport os\n\nCONFIG_PATH = \'config.json\'\n\n\nclass ConfigManager:\n    def __init__(self):\n        self.config = self.load_config()\n\n    def load_config(self):\n        if os.path.exists(CONFIG_PATH):\n            with open(CONFIG_PATH, \'r\') as f:\n                return json.load(f)\n        else:\n            default_config = {\n                \'DatabaseFilePath\': \'data/notes.db\',\n                \'Theme\': \'light\',\n                \'DefaultExportPath\': \'exports\',\n                \'Editor\': {\n                    \'font_size\': 12,\n                    \'font_family\': \'Arial\',\n                    \'syntax_highlighting\': True\n                },\n                \'SupportedFormats\': {\n                    \'RichText\': True,\n                    \'Markdown\': True\n                }\n            }\n            self.save_config(default_config)\n            return default_config\n\n    def save_config(self, config):\n        with open(CONFIG_PATH, \'w\') as f:\n            json.dump(config, f, indent=4)\n\n    def get(self, key, default=None):\n        return self.config.get(key, default)\n\n    def set(self, key, value):\n        self.config[key] = value\n        self.save_config(self.config)\nPK\x03\x04\x14\x00\x00\x00\x00\x00XaH[\xbe\x8fi\xad\xd4\x01\x00\x00\xd4\x01\x00\x00\n\x00\x00\x00data_io.pyimport json\n\n\ndef export_notes_json(notes, filepath):\n    try:\n        with open(filepath, \'w\') as f:\n            json.dump(notes, f, indent=4)\n        return True\n    except Exception as e:\n        print(f\'Export error: {e}\')\n        return False\n\n\ndef import_notes_json(filepath):\n    try:\n        with open(filepath, \'r\') as f:\n            notes = json.load(f)\n        return notes\n    except Exception as e:\n        print(f\'Import error: {e}\')\n        return None\nPK\x03\x04\x14\x00\x00\x00\x00\x00XaH[}x\xd2\xff\xdc\x01\x00\x00\xdc\x01\x00\x00\x18\x00\x00\x00formatting_controller.py# This controller handles formatting conversion between Markdown and WYSIWYG modes.\n# Currently, it implements a stub conversion method.\n\n\nclass FormattingController:\n    def __init__(self):\n        pass\n\n    def toggle_formatting(self, content, mode=\'markdown\'):\n        # In a real implementation, this function might parse Markdown or\n        # convert styled text back into Markdown. Here we simply return the\n        # content unchanged as a stub.\n        return content\nPK\x03\x04\x14\x00\x00\x00\x00\x00XaH[O5\xbf0J\x00\x00\x00J\x00\x00\x00\x10\x00\x00\x00requirements.txttkinter\n# sqlite3, json, datetime are part of the Python standard library\nPK\x03\x04\x14\x00\x00\x00\x00\x00XaH[\xf2\xe0\x10\xe4.\x01\x00\x00.\x01\x00\x00\x0b\x00\x00\x00config.json{\n    "DatabaseFilePath": "data/notes.db",\n    "Theme": "light",\n    "DefaultExportPath": "exports",\n    "Editor": {\n        "font_size": 12,\n        "font_family": "Arial",\n        "syntax_highlighting": true\n    },\n    "SupportedFormats": {\n        "RichText": true,\n        "Markdown": true\n    }\n}\nPK\x03\x04\x14\x00\x00\x00\x00\x00XaH[-\xf4N\xcb\x05\x03\x00\x00\x05\x03\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nAdd support for note categories and tags:\n- Implement a search function for notes\n- Store note metadata (timestamps, tags, categories)\n- Export and import notes as JSON files\nRich Text & Formatting:\n- Support for Markdown and Rich-Text (bold, italic, headings, lists)\n- Add highlighting and color options for notes\n- Support code snippets with syntax highlighting\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00XaH[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x03\x04\x14\x00\x00\x00\x00\x00XaH[%\xb5\xf9\'\xf8\x00\x00\x00\xf8\x00\x00\x00\x13\x00\x00\x00inputs/feedback.txtThe UI is Buggy (when you edit a note and then use one of the Buttons: Bold, Italic, Underline, Code, Toggle to Markdown, you are not able to save the edited note).\nAdditionally the search function and the tags and categories for notes are missing.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[`\xabe\xde\x12\x01\x00\x00\x12\x01\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[\xdc\xb9\x0cx\xfe/\x00\x00\xfe/\x00\x00\x0c\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x017\x01\x00\x00view_main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[\xd8\x99\x05/d\x06\x00\x00d\x06\x00\x00\x12\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01_1\x00\x00note_controller.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[J\xcc\xbc\xfc\x9a\x10\x00\x00\x9a\x10\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xf37\x00\x00note_dao.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[\'\x01\xbeL\x99\x04\x00\x00\x99\x04\x00\x00\x11\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xb6H\x00\x00config_manager.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[\xbe\x8fi\xad\xd4\x01\x00\x00\xd4\x01\x00\x00\n\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01~M\x00\x00data_io.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[}x\xd2\xff\xdc\x01\x00\x00\xdc\x01\x00\x00\x18\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01zO\x00\x00formatting_controller.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[O5\xbf0J\x00\x00\x00J\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x8cQ\x00\x00requirements.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[\xf2\xe0\x10\xe4.\x01\x00\x00.\x01\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x04R\x00\x00config.jsonPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[-\xf4N\xcb\x05\x03\x00\x00\x05\x03\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01[S\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x8eV\x00\x00inputs/environment.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00XaH[%\xb5\xf9\'\xf8\x00\x00\x00\xf8\x00\x00\x00\x13\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xebV\x00\x00inputs/feedback.txtPK\x05\x06\x00\x00\x00\x00\x0c\x00\x0c\x00\xdf\x02\x00\x00\x14X\x00\x00\x00\x00'