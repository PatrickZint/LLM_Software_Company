b'PK\x03\x04\x14\x00\x00\x00\x00\x00\xb5z7[\xa6\xa9\xb8\x85\x1d\x01\x00\x00\x1d\x01\x00\x00\t\x00\x00\x00config.pyimport os\n\n# Base directory of the application\nBASE_DIR = os.path.dirname(os.path.abspath(__file__))\n\n# Path to the SQLite database file\nDB_PATH = os.path.join(BASE_DIR, "notes.db")\n\n# Default export path for JSON backup files\nEXPORT_PATH = os.path.join(BASE_DIR, "notes_export.json")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb5z7[\xc9\xfb\xa8\xa0w\x19\x00\x00w\x19\x00\x00\x0b\x00\x00\x00database.pyimport sqlite3\nimport datetime\nfrom config import DB_PATH\n\n\nclass Database:\n    def __init__(self):\n        self.conn = sqlite3.connect(DB_PATH)\n        self.conn.row_factory = sqlite3.Row\n        self.initialize_database()\n        \n    def initialize_database(self):\n        cursor = self.conn.cursor()\n        # Create notes table\n        cursor.execute("""\n        CREATE TABLE IF NOT EXISTS notes (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            content TEXT NOT NULL,\n            created_at TEXT NOT NULL,\n            updated_at TEXT\n        );\n        """)\n        \n        # Create categories table\n        cursor.execute("""\n        CREATE TABLE IF NOT EXISTS categories (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT UNIQUE NOT NULL\n        );\n        """)\n        \n        # Create tags table\n        cursor.execute("""\n        CREATE TABLE IF NOT EXISTS tags (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            name TEXT UNIQUE NOT NULL\n        );\n        """)\n        \n        # Create note_categories table\n        cursor.execute("""\n        CREATE TABLE IF NOT EXISTS note_categories (\n            note_id INTEGER,\n            category_id INTEGER,\n            FOREIGN KEY(note_id) REFERENCES notes(id),\n            FOREIGN KEY(category_id) REFERENCES categories(id)\n        );\n        """)\n        \n        # Create note_tags table\n        cursor.execute("""\n        CREATE TABLE IF NOT EXISTS note_tags (\n            note_id INTEGER,\n            tag_id INTEGER,\n            FOREIGN KEY(note_id) REFERENCES notes(id),\n            FOREIGN KEY(tag_id) REFERENCES tags(id)\n        );\n        """)\n        \n        self.conn.commit()\n        \n    def create_note(self, title, content, categories=None, tags=None):\n        if categories is None:\n            categories = []\n        if tags is None:\n            tags = []\n        now = datetime.datetime.now().isoformat()\n        cursor = self.conn.cursor()\n        cursor.execute("""\n        INSERT INTO notes (title, content, created_at)\n        VALUES (?, ?, ?)\n        """, (title, content, now))\n        note_id = cursor.lastrowid\n        \n        self._update_note_metadata(note_id, categories, tags)\n        self.conn.commit()\n        return note_id\n    \n    def update_note(self, note_id, title, content, categories=None, tags=None):\n        if categories is None:\n            categories = []\n        if tags is None:\n            tags = []\n        now = datetime.datetime.now().isoformat()\n        cursor = self.conn.cursor()\n        cursor.execute("""\n        UPDATE notes\n        SET title = ?, content = ?, updated_at = ?\n        WHERE id = ?\n        """, (title, content, now, note_id))\n        \n        # Clear old metadata\n        cursor.execute("DELETE FROM note_categories WHERE note_id = ?", (note_id,))\n        cursor.execute("DELETE FROM note_tags WHERE note_id = ?", (note_id,))\n        \n        self._update_note_metadata(note_id, categories, tags)\n        self.conn.commit()\n        \n    def delete_note(self, note_id):\n        cursor = self.conn.cursor()\n        cursor.execute("DELETE FROM note_categories WHERE note_id = ?", (note_id,))\n        cursor.execute("DELETE FROM note_tags WHERE note_id = ?", (note_id,))\n        cursor.execute("DELETE FROM notes WHERE id = ?", (note_id,))\n        self.conn.commit()\n        \n    def get_all_notes(self):\n        cursor = self.conn.cursor()\n        cursor.execute("SELECT * FROM notes ORDER BY created_at DESC")\n        notes = []\n        for row in cursor.fetchall():\n            note = dict(row)\n            note[\'categories\'] = self.get_categories_for_note(row[\'id\'])\n            note[\'tags\'] = self.get_tags_for_note(row[\'id\'])\n            notes.append(note)\n        return notes\n    \n    def get_note(self, note_id):\n        cursor = self.conn.cursor()\n        cursor.execute("SELECT * FROM notes WHERE id = ?", (note_id,))\n        row = cursor.fetchone()\n        if row:\n            note = dict(row)\n            note[\'categories\'] = self.get_categories_for_note(note_id)\n            note[\'tags\'] = self.get_tags_for_note(note_id)\n            return note\n        return None\n    \n    def search_notes(self, keyword):\n        cursor = self.conn.cursor()\n        like_keyword = f"%{keyword}%"\n        cursor.execute("""\n        SELECT * FROM notes \n        WHERE title LIKE ? OR content LIKE ?\n        ORDER BY created_at DESC\n        """, (like_keyword, like_keyword))\n        notes = []\n        for row in cursor.fetchall():\n            note = dict(row)\n            note[\'categories\'] = self.get_categories_for_note(row[\'id\'])\n            note[\'tags\'] = self.get_tags_for_note(row[\'id\'])\n            notes.append(note)\n        return notes\n    \n    def _update_note_metadata(self, note_id, categories, tags):\n        cursor = self.conn.cursor()\n        for cat in categories:\n            cat = cat.strip()\n            if cat:\n                cursor.execute("INSERT OR IGNORE INTO categories (name) VALUES (?)", (cat,))\n                cursor.execute("SELECT id FROM categories WHERE name = ?", (cat,))\n                cat_row = cursor.fetchone()\n                if cat_row:\n                    cat_id = cat_row[\'id\']\n                    cursor.execute("INSERT INTO note_categories (note_id, category_id) VALUES (?, ?)", (note_id, cat_id))\n        \n        for tag in tags:\n            tag = tag.strip()\n            if tag:\n                cursor.execute("INSERT OR IGNORE INTO tags (name) VALUES (?)", (tag,))\n                cursor.execute("SELECT id FROM tags WHERE name = ?", (tag,))\n                tag_row = cursor.fetchone()\n                if tag_row:\n                    tag_id = tag_row[\'id\']\n                    cursor.execute("INSERT INTO note_tags (note_id, tag_id) VALUES (?, ?)", (note_id, tag_id))\n\n    def get_categories_for_note(self, note_id):\n        cursor = self.conn.cursor()\n        cursor.execute("""\n        SELECT c.name FROM categories c\n        INNER JOIN note_categories nc ON c.id = nc.category_id\n        WHERE nc.note_id = ?\n        """, (note_id,))\n        return [row[\'name\'] for row in cursor.fetchall()]\n    \n    def get_tags_for_note(self, note_id):\n        cursor = self.conn.cursor()\n        cursor.execute("""\n        SELECT t.name FROM tags t\n        INNER JOIN note_tags nt ON t.id = nt.tag_id\n        WHERE nt.note_id = ?\n        """, (note_id,))\n        return [row[\'name\'] for row in cursor.fetchall()]\n    \n    def close(self):\n        self.conn.close()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb5z7[\x95:\xa1>@\x03\x00\x00@\x03\x00\x00\x10\x00\x00\x00import_export.pyimport json\nfrom config import EXPORT_PATH\nfrom database import Database\n\n\ndef export_notes(db, file_path=EXPORT_PATH):\n    """\n    Export all notes (with metadata) to a JSON file.\n    """\n    notes = db.get_all_notes()\n    with open(file_path, \'w\', encoding=\'utf-8\') as f:\n        json.dump(notes, f, indent=4)\n    return file_path\n\n\ndef import_notes(db, file_path):\n    """\n    Import notes from a JSON file and add them to the database.\n    For simplicity, notes are always added new.\n    """\n    with open(file_path, \'r\', encoding=\'utf-8\') as f:\n        notes = json.load(f)\n    \n    for note in notes:\n        categories = note.get(\'categories\', [])\n        tags = note.get(\'tags\', [])\n        # Create note; duplicate handling can be improved if needed\n        db.create_note(note[\'title\'], note[\'content\'], categories, tags)\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb5z7[\xdcn\x1e\xd1O\x1b\x00\x00O\x1b\x00\x00\x05\x00\x00\x00ui.pyimport tkinter as tk\nfrom tkinter import ttk, messagebox, filedialog\nfrom database import Database\nfrom import_export import export_notes, import_notes\n\n\nclass NoteApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.title("Note Taking Application")\n        self.db = Database()\n        self.selected_note_id = None\n        \n        self.create_widgets()\n        self.load_notes()\n        \n    def create_widgets(self):\n        # Main frame\n        self.main_frame = ttk.Frame(self.root)\n        self.main_frame.pack(fill=tk.BOTH, expand=True)\n\n        # Left frame: Search and note list\n        self.left_frame = ttk.Frame(self.main_frame, width=200)\n        self.left_frame.pack(side=tk.LEFT, fill=tk.Y)\n        \n        self.search_var = tk.StringVar()\n        search_entry = ttk.Entry(self.left_frame, textvariable=self.search_var)\n        search_entry.pack(fill=tk.X, padx=5, pady=5)\n        search_entry.bind("<KeyRelease>", self.on_search)\n        \n        self.note_listbox = tk.Listbox(self.left_frame)\n        self.note_listbox.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        self.note_listbox.bind("<<ListboxSelect>>", self.on_note_select)\n        \n        # Buttons for New and Delete\n        btn_frame = ttk.Frame(self.left_frame)\n        btn_frame.pack(fill=tk.X, padx=5, pady=5)\n        self.new_btn = ttk.Button(btn_frame, text="New Note", command=self.new_note)\n        self.new_btn.pack(side=tk.LEFT, fill=tk.X, expand=True)\n        self.delete_btn = ttk.Button(btn_frame, text="Delete Note", command=self.delete_note)\n        self.delete_btn.pack(side=tk.LEFT, fill=tk.X, expand=True)\n\n        # Right frame: Note details\n        self.right_frame = ttk.Frame(self.main_frame)\n        self.right_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True)\n        \n        # Title\n        ttk.Label(self.right_frame, text="Title:").pack(anchor=tk.W, padx=5, pady=2)\n        self.title_var = tk.StringVar()\n        self.title_entry = ttk.Entry(self.right_frame, textvariable=self.title_var)\n        self.title_entry.pack(fill=tk.X, padx=5, pady=2)\n\n        # Categories\n        ttk.Label(self.right_frame, text="Categories (comma separated):").pack(anchor=tk.W, padx=5, pady=2)\n        self.categories_var = tk.StringVar()\n        self.categories_entry = ttk.Entry(self.right_frame, textvariable=self.categories_var)\n        self.categories_entry.pack(fill=tk.X, padx=5, pady=2)\n\n        # Tags\n        ttk.Label(self.right_frame, text="Tags (comma separated):").pack(anchor=tk.W, padx=5, pady=2)\n        self.tags_var = tk.StringVar()\n        self.tags_entry = ttk.Entry(self.right_frame, textvariable=self.tags_var)\n        self.tags_entry.pack(fill=tk.X, padx=5, pady=2)\n        \n        # Content (supports Markdown formatting)\n        ttk.Label(self.right_frame, text="Content (Markdown Supported):").pack(anchor=tk.W, padx=5, pady=2)\n        self.content_text = tk.Text(self.right_frame, wrap=tk.WORD)\n        self.content_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        \n        # Save button\n        self.save_btn = ttk.Button(self.right_frame, text="Save Note", command=self.save_note)\n        self.save_btn.pack(padx=5, pady=5)\n\n        # Menu for Export/Import\n        menubar = tk.Menu(self.root)\n        filemenu = tk.Menu(menubar, tearoff=0)\n        filemenu.add_command(label="Export Notes", command=self.export_notes)\n        filemenu.add_command(label="Import Notes", command=self.import_notes)\n        menubar.add_cascade(label="File", menu=filemenu)\n        self.root.config(menu=menubar)\n\n    def load_notes(self):\n        self.note_listbox.delete(0, tk.END)\n        self.notes = self.db.get_all_notes()\n        for note in self.notes:\n            display_text = f"{note[\'title\']} - {note[\'created_at\'][:10]}"\n            self.note_listbox.insert(tk.END, display_text)\n\n    def on_note_select(self, event):\n        selection = event.widget.curselection()\n        if selection:\n            index = selection[0]\n            note = self.notes[index]\n            self.selected_note_id = note[\'id\']\n            self.title_var.set(note[\'title\'])\n            self.categories_var.set(", ".join(note.get(\'categories\', [])))\n            self.tags_var.set(", ".join(note.get(\'tags\', [])))\n            self.content_text.delete("1.0", tk.END)\n            self.content_text.insert(tk.END, note[\'content\'])\n        else:\n            self.selected_note_id = None\n\n    def new_note(self):\n        self.selected_note_id = None\n        self.title_var.set("")\n        self.categories_var.set("")\n        self.tags_var.set("")\n        self.content_text.delete("1.0", tk.END)\n        self.note_listbox.selection_clear(0, tk.END)\n\n    def save_note(self):\n        title = self.title_var.get().strip()\n        content = self.content_text.get("1.0", tk.END).strip()\n        categories = [cat.strip() for cat in self.categories_var.get().split(",") if cat.strip()]\n        tags = [tag.strip() for tag in self.tags_var.get().split(",") if tag.strip()]\n\n        if not title or not content:\n            messagebox.showwarning("Incomplete Data", "Title and Content are required.")\n            return\n\n        if self.selected_note_id:\n            self.db.update_note(self.selected_note_id, title, content, categories, tags)\n            messagebox.showinfo("Note Updated", "The note has been updated successfully.")\n        else:\n            self.db.create_note(title, content, categories, tags)\n            messagebox.showinfo("Note Created", "The note has been created successfully.")\n        self.load_notes()\n\n    def delete_note(self):\n        if self.selected_note_id:\n            answer = messagebox.askyesno("Delete Note", "Are you sure you want to delete this note?")\n            if answer:\n                self.db.delete_note(self.selected_note_id)\n                self.new_note()\n                self.load_notes()\n        else:\n            messagebox.showwarning("No Selection", "No note selected to delete.")\n\n    def on_search(self, event):\n        keyword = self.search_var.get().strip()\n        if keyword:\n            self.notes = self.db.search_notes(keyword)\n        else:\n            self.notes = self.db.get_all_notes()\n        self.note_listbox.delete(0, tk.END)\n        for note in self.notes:\n            display_text = f"{note[\'title\']} - {note[\'created_at\'][:10]}"\n            self.note_listbox.insert(tk.END, display_text)\n\n    def export_notes(self):\n        file_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON files", "*.json")])\n        if file_path:\n            export_notes(self.db, file_path)\n            messagebox.showinfo("Export Successful", f"Notes exported to {file_path}")\n\n    def import_notes(self):\n        file_path = filedialog.askopenfilename(filetypes=[("JSON files", "*.json")])\n        if file_path:\n            import_notes(self.db, file_path)\n            self.load_notes()\n            messagebox.showinfo("Import Successful", f"Notes imported from {file_path}")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb5z7[ty\xc3\x0f\xbe\x00\x00\x00\xbe\x00\x00\x00\x07\x00\x00\x00main.pyimport tkinter as tk\nfrom ui import NoteApp\n\n\ndef main():\n    root = tk.Tk()\n    root.geometry("800x600")\n    app = NoteApp(root)\n    root.mainloop()\n\n\nif __name__ == "__main__":\n    main()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xb5z7[\x9d\xb9\xc2\xbd0\x03\x00\x000\x03\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\n- Store notes locally in a SQLite database\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nAdd support for note categories and tags:\n- Implement a search function for notes\n- Store note metadata (timestamps, tags, categories)\n- Export and import notes as JSON files\nRich Text & Formatting:\n- Support for Markdown and Rich-Text (bold, italic, headings, lists)\n- Add highlighting and color options for notes\n- Support code snippets with syntax highlighting\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00\xb5z7[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb5z7[\xa6\xa9\xb8\x85\x1d\x01\x00\x00\x1d\x01\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00config.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb5z7[\xc9\xfb\xa8\xa0w\x19\x00\x00w\x19\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01D\x01\x00\x00database.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb5z7[\x95:\xa1>@\x03\x00\x00@\x03\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xe4\x1a\x00\x00import_export.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb5z7[\xdcn\x1e\xd1O\x1b\x00\x00O\x1b\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01R\x1e\x00\x00ui.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb5z7[ty\xc3\x0f\xbe\x00\x00\x00\xbe\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xc49\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb5z7[\x9d\xb9\xc2\xbd0\x03\x00\x000\x03\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xa7:\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xb5z7[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x05>\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\x07\x00\x07\x00\x98\x01\x00\x00b>\x00\x00\x00\x00'