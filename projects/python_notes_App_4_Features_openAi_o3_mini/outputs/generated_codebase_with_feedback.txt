b'PK\x03\x04\x14\x00\x00\x00\x00\x00P\x7fG[\xd6b\xc2R\xb7\x02\x00\x00\xb7\x02\x00\x00\t\x00\x00\x00config.pyimport os\n\n# Application configuration\n# Adjust paths and settings as needed\n\nBASE_DIR = os.path.abspath(os.path.dirname(__file__))\nDATABASE_FILE = os.path.join(BASE_DIR, \'data\', \'notes.db\')\nDEFAULT_EXPORT_PATH = os.path.join(BASE_DIR, \'exports\')\nTHEME = \'light\'\n\n# Editor Settings\nEDITOR_SETTINGS = {\n    \'FontSize\': 14,\n    \'FontFamily\': \'Helvetica\',\n    \'SyntaxHighlighting\': True\n}\n\n# Supported Formats\nSUPPORTED_FORMATS = {\n    \'RichText\': True,\n    \'Markdown\': True\n}\n\n# Ensure required directories exist\nif not os.path.exists(os.path.join(BASE_DIR, \'data\')):\n    os.makedirs(os.path.join(BASE_DIR, \'data\'))\nif not os.path.exists(DEFAULT_EXPORT_PATH):\n    os.makedirs(DEFAULT_EXPORT_PATH)\nPK\x03\x04\x14\x00\x00\x00\x00\x00P\x7fG[\x83\xc9\xd7\xf2\xee\r\x00\x00\xee\r\x00\x00\x0b\x00\x00\x00database.pyimport sqlite3\nimport datetime\nimport json\nfrom config import DATABASE_FILE\n\nclass Database:\n    def __init__(self, db_path=DATABASE_FILE):\n        self.connection = sqlite3.connect(db_path)\n        self.connection.row_factory = sqlite3.Row\n        self.create_table()\n\n    def create_table(self):\n        query = \'\'\'\n        CREATE TABLE IF NOT EXISTS notes (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            content TEXT NOT NULL,\n            created TIMESTAMP NOT NULL,\n            updated TIMESTAMP NOT NULL,\n            categories TEXT,\n            tags TEXT\n        );\n        \'\'\'\n        self.connection.execute(query)\n        self.connection.commit()\n\n    def add_note(self, title, content, categories=\'\', tags=\'\'):\n        now = datetime.datetime.now()\n        query = \'\'\'INSERT INTO notes (title, content, created, updated, categories, tags) \n                   VALUES (?, ?, ?, ?, ?, ?)\'\'\'\n        cursor = self.connection.execute(query, (title, content, now, now, categories, tags))\n        self.connection.commit()\n        return cursor.lastrowid\n\n    def update_note(self, note_id, title, content, categories=\'\', tags=\'\'):\n        now = datetime.datetime.now()\n        query = \'\'\'UPDATE notes SET title = ?, content = ?, updated = ?, categories = ?, tags = ? WHERE id = ?\'\'\'\n        self.connection.execute(query, (title, content, now, categories, tags, note_id))\n        self.connection.commit()\n\n    def delete_note(self, note_id):\n        query = \'DELETE FROM notes WHERE id = ?\'\n        self.connection.execute(query, (note_id,))\n        self.connection.commit()\n\n    def get_notes(self):\n        query = \'SELECT * FROM notes ORDER BY updated DESC\'\n        cursor = self.connection.execute(query)\n        return cursor.fetchall()\n\n    def get_note_by_id(self, note_id):\n        query = \'SELECT * FROM notes WHERE id = ?\'\n        cursor = self.connection.execute(query, (note_id,))\n        return cursor.fetchone()\n\n    def search_notes(self, keyword):\n        like_keyword = f\'%{keyword}%\'\n        query = \'\'\'\n        SELECT * FROM notes WHERE title LIKE ? OR content LIKE ? OR categories LIKE ? OR tags LIKE ?\n        ORDER BY updated DESC\n        \'\'\'\n        cursor = self.connection.execute(query, (like_keyword, like_keyword, like_keyword, like_keyword))\n        return cursor.fetchall()\n\n    def export_notes(self, note_ids=None):\n        # If note_ids is provided, export only these; else export all notes\n        if note_ids:\n            placeholder = \',\'.join(\'?\' for _ in note_ids)\n            query = f\'SELECT * FROM notes WHERE id IN ({placeholder})\'\n            cursor = self.connection.execute(query, note_ids)\n        else:\n            query = \'SELECT * FROM notes\'\n            cursor = self.connection.execute(query)\n        notes = [dict(row) for row in cursor.fetchall()]\n        return json.dumps(notes, default=str, indent=2)\n\n    def import_notes(self, json_data):\n        try:\n            notes = json.loads(json_data)\n            for note in notes:\n                # Check if note exists based on title and created timestamp \n                # For simplicity, we insert all imported notes\n                self.add_note(\n                    title=note.get(\'title\', \'Untitled\'),\n                    content=note.get(\'content\', \'\'),\n                    categories=note.get(\'categories\', \'\'),\n                    tags=note.get(\'tags\', \'\')\n                )\n            return True\n        except Exception as e:\n            print(\'Error importing notes:\', e)\n            return False\nPK\x03\x04\x14\x00\x00\x00\x00\x00P\x7fG[\xee\xca%cz0\x00\x00z0\x00\x00\x07\x00\x00\x00main.pyimport tkinter as tk\nfrom tkinter import ttk, messagebox, filedialog\nimport re\nimport json\nfrom database import Database\nfrom config import DEFAULT_EXPORT_PATH\n\nclass NoteApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\'Note Taking Application\')\n        self.db = Database()\n        self.selected_note_id = None\n\n        # Layout frames\n        self.setup_ui()\n        self.load_notes()\n\n    def setup_ui(self):\n        # Create Menu\n        self.create_menu()\n\n        # Create main PanedWindow\n        self.paned = ttk.PanedWindow(self.root, orient=tk.HORIZONTAL)\n        self.paned.pack(fill=tk.BOTH, expand=True)\n\n        # Left frame: Note List and Search\n        self.left_frame = ttk.Frame(self.paned, width=200)\n        self.paned.add(self.left_frame, weight=1)\n\n        # Search entry\n        self.search_var = tk.StringVar()\n        search_frame = ttk.Frame(self.left_frame)\n        search_frame.pack(fill=tk.X, padx=5, pady=5)\n        ttk.Label(search_frame, text=\'Search:\').pack(side=tk.LEFT)\n        search_entry = ttk.Entry(search_frame, textvariable=self.search_var)\n        search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)\n        search_entry.bind(\'<KeyRelease>\', lambda e: self.search_notes())\n\n        # Note List\n        self.note_list = tk.Listbox(self.left_frame)\n        self.note_list.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n        self.note_list.bind(\'<<ListboxSelect>>\', lambda e: self.display_selected_note())\n\n        # Right frame: Note Editor and Preview\n        self.right_frame = ttk.Frame(self.paned)\n        self.paned.add(self.right_frame, weight=3)\n\n        # Note Title\n        title_frame = ttk.Frame(self.right_frame)\n        title_frame.pack(fill=tk.X, padx=5, pady=5)\n        ttk.Label(title_frame, text=\'Title:\').pack(side=tk.LEFT)\n        self.title_var = tk.StringVar()\n        self.title_entry = ttk.Entry(title_frame, textvariable=self.title_var)\n        self.title_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)\n\n        # Formatting toolbar\n        toolbar = ttk.Frame(self.right_frame)\n        toolbar.pack(fill=tk.X, padx=5, pady=2)\n        ttk.Button(toolbar, text=\'Bold\', command=self.apply_bold).pack(side=tk.LEFT, padx=2)\n        ttk.Button(toolbar, text=\'Italic\', command=self.apply_italic).pack(side=tk.LEFT, padx=2)\n        ttk.Button(toolbar, text=\'Code\', command=self.apply_code).pack(side=tk.LEFT, padx=2)\n        ttk.Button(toolbar, text=\'Preview\', command=self.update_preview).pack(side=tk.LEFT, padx=2)\n\n        # Notebook for Editor and Preview\n        self.notebook = ttk.Notebook(self.right_frame)\n        self.notebook.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n\n        # Editor tab\n        self.editor_frame = ttk.Frame(self.notebook)\n        self.notebook.add(self.editor_frame, text=\'Editor\')\n        self.editor_text = tk.Text(self.editor_frame, wrap=\'word\', font=(\'Helvetica\', 12))\n        self.editor_text.pack(fill=tk.BOTH, expand=True)\n\n        # Preview tab\n        self.preview_frame = ttk.Frame(self.notebook)\n        self.notebook.add(self.preview_frame, text=\'Preview\')\n        self.preview_text = tk.Text(self.preview_frame, wrap=\'word\', font=(\'Helvetica\', 12), state=\'disabled\')\n        self.preview_text.pack(fill=tk.BOTH, expand=True)\n        \n        # Tag configurations for preview\n        self.preview_text.tag_configure(\'bold\', font=(\'Helvetica\', 12, \'bold\'))\n        self.preview_text.tag_configure(\'italic\', font=(\'Helvetica\', 12, \'italic\'))\n        self.preview_text.tag_configure(\'code\', font=(\'Courier\', 12), background=\'#f0f0f0\')\n\n        # Bottom buttons\n        button_frame = ttk.Frame(self.right_frame)\n        button_frame.pack(fill=tk.X, padx=5, pady=5)\n        ttk.Button(button_frame, text=\'New Note\', command=self.new_note).pack(side=tk.LEFT, padx=2)\n        ttk.Button(button_frame, text=\'Save\', command=self.save_note).pack(side=tk.LEFT, padx=2)\n        ttk.Button(button_frame, text=\'Delete\', command=self.delete_note).pack(side=tk.LEFT, padx=2)\n\n    def create_menu(self):\n        menubar = tk.Menu(self.root)\n        self.root.config(menu=menubar)\n\n        file_menu = tk.Menu(menubar, tearoff=0)\n        menubar.add_cascade(label=\'File\', menu=file_menu)\n        file_menu.add_command(label=\'Import\', command=self.import_notes)\n        file_menu.add_command(label=\'Export\', command=self.export_notes)\n        file_menu.add_separator()\n        file_menu.add_command(label=\'Exit\', command=self.root.quit)\n\n    def load_notes(self):\n        self.note_list.delete(0, tk.END)\n        self.notes = self.db.get_notes()\n        for note in self.notes:\n            display_text = f"{note[\'title\']} ({note[\'updated\']})"\n            self.note_list.insert(tk.END, display_text)\n\n    def display_selected_note(self):\n        selected = self.note_list.curselection()\n        if not selected:\n            return\n        index = selected[0]\n        note = self.notes[index]\n        self.selected_note_id = note[\'id\']\n        self.title_var.set(note[\'title\'])\n        self.editor_text.delete(\'1.0\', tk.END)\n        self.editor_text.insert(tk.END, note[\'content\'])\n        self.update_preview()\n\n    def new_note(self):\n        self.selected_note_id = None\n        self.title_var.set(\'\')\n        self.editor_text.delete(\'1.0\', tk.END)\n        self.preview_text.config(state=\'normal\')\n        self.preview_text.delete(\'1.0\', tk.END)\n        self.preview_text.config(state=\'disabled\')\n        self.note_list.selection_clear(0, tk.END)\n\n    def save_note(self):\n        title = self.title_var.get().strip()\n        content = self.editor_text.get(\'1.0\', tk.END).strip()\n        if not title or not content:\n            messagebox.showwarning(\'Validation\', \'Title and Content cannot be empty.\')\n            return\n        if self.selected_note_id:\n            self.db.update_note(self.selected_note_id, title, content)\n        else:\n            self.selected_note_id = self.db.add_note(title, content)\n        self.load_notes()\n        messagebox.showinfo(\'Success\', \'Note saved successfully.\')\n\n    def delete_note(self):\n        if self.selected_note_id is None:\n            messagebox.showwarning(\'Selection\', \'No note selected to delete.\')\n            return\n        if messagebox.askyesno(\'Confirm Delete\', \'Are you sure you want to delete this note?\'):\n            self.db.delete_note(self.selected_note_id)\n            self.new_note()\n            self.load_notes()\n\n    def search_notes(self):\n        keyword = self.search_var.get().strip()\n        if keyword == \'\':\n            self.notes = self.db.get_notes()\n        else:\n            self.notes = self.db.search_notes(keyword)\n        self.note_list.delete(0, tk.END)\n        for note in self.notes:\n            display_text = f"{note[\'title\']} ({note[\'updated\']})"\n            self.note_list.insert(tk.END, display_text)\n\n    def import_notes(self):\n        file_path = filedialog.askopenfilename(title=\'Select JSON file to import\', filetypes=[(\'JSON Files\', \'*.json\')])\n        if file_path:\n            try:\n                with open(file_path, \'r\', encoding=\'utf-8\') as f:\n                    json_data = f.read()\n                if self.db.import_notes(json_data):\n                    messagebox.showinfo(\'Import\', \'Notes imported successfully.\')\n                    self.load_notes()\n                else:\n                    messagebox.showerror(\'Import\', \'Failed to import notes.\')\n            except Exception as e:\n                messagebox.showerror(\'Error\', f\'Error reading file: {e}\')\n\n    def export_notes(self):\n        file_path = filedialog.asksaveasfilename(title=\'Export Notes as JSON\', \n                                                 initialdir=DEFAULT_EXPORT_PATH, \n                                                 defaultextension=\'.json\', \n                                                 filetypes=[(\'JSON Files\', \'*.json\')])\n        if file_path:\n            try:\n                json_data = self.db.export_notes()\n                with open(file_path, \'w\', encoding=\'utf-8\') as f:\n                    f.write(json_data)\n                messagebox.showinfo(\'Export\', \'Notes exported successfully.\')\n            except Exception as e:\n                messagebox.showerror(\'Error\', f\'Error writing file: {e}\')\n\n    # Formatting button functions\n    def apply_bold(self):\n        self.wrap_selection(\'**\', \'**\')\n\n    def apply_italic(self):\n        self.wrap_selection(\'*\', \'*\')\n\n    def apply_code(self):\n        self.wrap_selection(\'`\', \'`\')\n\n    def wrap_selection(self, start_tag, end_tag):\n        try:\n            start = self.editor_text.index(\'sel.first\')\n            end = self.editor_text.index(\'sel.last\')\n            selected_text = self.editor_text.get(start, end)\n            new_text = f\'{start_tag}{selected_text}{end_tag}\'\n            self.editor_text.delete(start, end)\n            self.editor_text.insert(start, new_text)\n        except tk.TclError:\n            messagebox.showwarning(\'Selection\', \'Please select text to format.\')\n\n    # Update preview tab with basic markdown rendering\n    def update_preview(self):\n        content = self.editor_text.get(\'1.0\', tk.END)\n        parsed_text, spans = self.parse_markdown(content)\n        self.preview_text.config(state=\'normal\')\n        self.preview_text.delete(\'1.0\', tk.END)\n        self.preview_text.insert(\'1.0\', parsed_text)\n        # Apply formatting tags\n        for span in spans:\n            start_idx, end_idx, tag = span\n            # Convert indices to Tkinter text indices\n            start_index = self.get_text_index_from_pos(parsed_text, start_idx)\n            end_index = self.get_text_index_from_pos(parsed_text, end_idx)\n            self.preview_text.tag_add(tag, start_index, end_index)\n        self.preview_text.config(state=\'disabled\')\n\n    def get_text_index_from_pos(self, text, pos):\n        # Given a character position (pos) in text, convert to Tk text index\n        # Count number of newlines\n        lines = text.split(\'\\n\')\n        count = 0\n        for i, line in enumerate(lines):\n            if count + len(line) >= pos:\n                col = pos - count\n                return f"{i+1}.{col}"\n            count += len(line) + 1  # +1 for the newline char\n        return tk.END\n\n    def parse_markdown(self, content):\n        # A simple parser to remove markdown markers and record formatting spans\n        parsed_text = \'\'\n        spans = []  # list of tuples: (start_index, end_index, tag)\n        i = 0\n        while i < len(content):\n            if content[i:i+2] == \'**\':\n                i += 2\n                start_pos = len(parsed_text)\n                # find closing **\n                end_marker = content.find(\'**\', i)\n                if end_marker == -1:\n                    # no closing marker found, just add the rest\n                    parsed_text += \'**\'\n                    break\n                inner_text = content[i:end_marker]\n                parsed_text += inner_text\n                spans.append((start_pos, start_pos + len(inner_text), \'bold\'))\n                i = end_marker + 2\n            elif content[i] == \'*\' :\n                # Avoid matching if it might be part of bold\n                if i+1 < len(content) and content[i+1] == \'*\':\n                    # skip because it was handled above\n                    i += 1\n                    continue\n                i += 1\n                start_pos = len(parsed_text)\n                end_marker = content.find(\'*\', i)\n                if end_marker == -1:\n                    parsed_text += \'*\'\n                    break\n                inner_text = content[i:end_marker]\n                parsed_text += inner_text\n                spans.append((start_pos, start_pos + len(inner_text), \'italic\'))\n                i = end_marker + 1\n            elif content[i] == \'`\':\n                i += 1\n                start_pos = len(parsed_text)\n                end_marker = content.find(\'`\', i)\n                if end_marker == -1:\n                    parsed_text += \'`\'\n                    break\n                inner_text = content[i:end_marker]\n                parsed_text += inner_text\n                spans.append((start_pos, start_pos + len(inner_text), \'code\'))\n                i = end_marker + 1\n            else:\n                parsed_text += content[i]\n                i += 1\n        return parsed_text, spans\n\nif __name__ == \'__main__\':\n    root = tk.Tk()\n    app = NoteApp(root)\n    root.mainloop()\nPK\x03\x04\x14\x00\x00\x00\x00\x00P\x7fG[-\xf4N\xcb\x05\x03\x00\x00\x05\x03\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nAdd support for note categories and tags:\n- Implement a search function for notes\n- Store note metadata (timestamps, tags, categories)\n- Export and import notes as JSON files\nRich Text & Formatting:\n- Support for Markdown and Rich-Text (bold, italic, headings, lists)\n- Add highlighting and color options for notes\n- Support code snippets with syntax highlighting\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00P\x7fG[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00P\x7fG[\xd6b\xc2R\xb7\x02\x00\x00\xb7\x02\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00config.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00P\x7fG[\x83\xc9\xd7\xf2\xee\r\x00\x00\xee\r\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xde\x02\x00\x00database.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00P\x7fG[\xee\xca%cz0\x00\x00z0\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xf5\x10\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00P\x7fG[-\xf4N\xcb\x05\x03\x00\x00\x05\x03\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x94A\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00P\x7fG[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xc7D\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\x05\x00\x05\x00\'\x01\x00\x00$E\x00\x00\x00\x00'