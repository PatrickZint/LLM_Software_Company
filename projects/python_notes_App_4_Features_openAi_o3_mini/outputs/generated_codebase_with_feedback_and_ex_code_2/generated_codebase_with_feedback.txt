b'PK\x03\x04\x14\x00\x00\x00\x00\x00\xd7rH[\xd5\x81\xef\xd8(\x01\x00\x00(\x01\x00\x00\x0b\x00\x00\x00config.json{\n   "DatabaseFilePath": "notes.db",\n   "Theme": "light",\n   "DefaultExportPath": "exports/",\n   "SupportedFormats": {\n       "RichText": true,\n       "Markdown": true\n   },\n   "EditorSettings": {\n       "FontSize": 14,\n       "FontFamily": "Sans-Serif",\n       "SyntaxHighlighting": true\n   }\n}\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd7rH[\x19r]\xceh\x0e\x00\x00h\x0e\x00\x00\x0b\x00\x00\x00database.pyimport sqlite3\nimport datetime\nimport json\n\nclass NoteDatabase:\n    def __init__(self, db_path):\n        self.db_path = db_path\n        self.conn = sqlite3.connect(self.db_path)\n        self.conn.row_factory = sqlite3.Row\n        self.create_tables()\n\n    def create_tables(self):\n        query = \'\'\'\n        CREATE TABLE IF NOT EXISTS notes (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            content TEXT NOT NULL,\n            categories TEXT,\n            tags TEXT,\n            created_at TEXT NOT NULL,\n            updated_at TEXT NOT NULL\n        );\n        \'\'\'\n        self.conn.execute(query)\n        self.conn.commit()\n\n    def add_note(self, title, content, categories="", tags=""):\n        now = datetime.datetime.now().isoformat()\n        query = \'\'\'\n        INSERT INTO notes (title, content, categories, tags, created_at, updated_at)\n        VALUES (?, ?, ?, ?, ?, ?);\n        \'\'\'\n        cur = self.conn.cursor()\n        cur.execute(query, (title, content, categories, tags, now, now))\n        self.conn.commit()\n        return cur.lastrowid\n\n    def get_all_notes(self):\n        query = "SELECT * FROM notes ORDER BY created_at DESC;"\n        cur = self.conn.cursor()\n        cur.execute(query)\n        rows = cur.fetchall()\n        return [dict(row) for row in rows]\n\n    def get_note_by_id(self, note_id):\n        query = "SELECT * FROM notes WHERE id = ?;"\n        cur = self.conn.cursor()\n        cur.execute(query, (note_id,))\n        row = cur.fetchone()\n        return dict(row) if row else None\n\n    def update_note(self, note_id, title, content, categories="", tags=""):\n        now = datetime.datetime.now().isoformat()\n        query = \'\'\'\n        UPDATE notes\n        SET title = ?, content = ?, categories = ?, tags = ?, updated_at = ?\n        WHERE id = ?;\n        \'\'\'\n        self.conn.execute(query, (title, content, categories, tags, now, note_id))\n        self.conn.commit()\n\n    def delete_note(self, note_id):\n        query = "DELETE FROM notes WHERE id = ?;"\n        self.conn.execute(query, (note_id,))\n        self.conn.commit()\n\n    def search_notes(self, keyword, category=None, tag=None):\n        base_query = \'\'\'\n        SELECT * FROM notes\n        WHERE (title LIKE ? OR content LIKE ? OR categories LIKE ? OR tags LIKE ?)\n        \'\'\'\n        params = []\n        pattern = f\'%{keyword}%\' if keyword else \'%\'\n        params.extend([pattern, pattern, pattern, pattern])\n        if category:\n            base_query += " AND categories LIKE ?"\n            params.append(f\'%{category}%\')\n        if tag:\n            base_query += " AND tags LIKE ?"\n            params.append(f\'%{tag}%\')\n        base_query += " ORDER BY created_at DESC;"\n        cur = self.conn.cursor()\n        cur.execute(base_query, tuple(params))\n        rows = cur.fetchall()\n        return [dict(row) for row in rows]\n\n    def export_notes(self, export_path):\n        notes = self.get_all_notes()\n        with open(export_path, \'w\', encoding=\'utf-8\') as f:\n            json.dump(notes, f, indent=4)\n\n    def import_notes(self, import_path):\n        with open(import_path, \'r\', encoding=\'utf-8\') as f:\n            notes = json.load(f)\n        for note in notes:\n            # Simple merge strategy: if note with same title exists, update it\n            existing = self.conn.execute("SELECT id FROM notes WHERE title = ?", (note[\'title\'],)).fetchone()\n            if existing:\n                self.update_note(existing[0], note[\'title\'], note[\'content\'], note.get(\'categories\', \'\'), note.get(\'tags\', \'\'))\n            else:\n                self.add_note(note[\'title\'], note[\'content\'], note.get(\'categories\', \'\'), note.get(\'tags\', \'\'))\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd7rH[G\xbaB\xf4y*\x00\x00y*\x00\x00\x06\x00\x00\x00gui.pyimport tkinter as tk\nfrom tkinter import messagebox, filedialog\nfrom database import NoteDatabase\nimport os\nimport json\n\n# Import markdown utilities for preview\nimport markdown\ntry:\n    from tkhtmlview import HTMLLabel\nexcept ImportError:\n    HTMLLabel = None\n\nclass NotesApp(tk.Tk):\n    def __init__(self, db, config):\n        super().__init__()\n        self.title("Note-Taking Application")\n        self.geometry("800x600")\n        self.db = db\n        self.config_data = config\n\n        # Left frame: list of notes and search/filter options\n        self.left_frame = tk.Frame(self, width=250)\n        self.left_frame.pack(side=tk.LEFT, fill=tk.Y)\n\n        # Search field\n        self.search_var = tk.StringVar()\n        tk.Label(self.left_frame, text="Keyword:").pack(padx=5, pady=(5,0), anchor=\'w\')\n        self.search_entry = tk.Entry(self.left_frame, textvariable=self.search_var)\n        self.search_entry.pack(padx=5, pady=2, fill=tk.X)\n        self.search_entry.bind(\'<Return>\', lambda event: self.perform_search())\n\n        # Additional filter for categories\n        self.category_filter_var = tk.StringVar()\n        tk.Label(self.left_frame, text="Category Filter:").pack(padx=5, pady=(5,0), anchor=\'w\')\n        self.category_filter_entry = tk.Entry(self.left_frame, textvariable=self.category_filter_var)\n        self.category_filter_entry.pack(padx=5, pady=2, fill=tk.X)\n\n        # Additional filter for tags\n        self.tag_filter_var = tk.StringVar()\n        tk.Label(self.left_frame, text="Tag Filter:").pack(padx=5, pady=(5,0), anchor=\'w\')\n        self.tag_filter_entry = tk.Entry(self.left_frame, textvariable=self.tag_filter_var)\n        self.tag_filter_entry.pack(padx=5, pady=2, fill=tk.X)\n\n        # Listbox for notes\n        self.notes_listbox = tk.Listbox(self.left_frame)\n        self.notes_listbox.pack(padx=5, pady=5, fill=tk.BOTH, expand=True)\n        self.notes_listbox.bind(\'<<ListboxSelect>>\', lambda event: self.load_selected_note())\n\n        # Buttons on left frame\n        btn_frame = tk.Frame(self.left_frame)\n        btn_frame.pack(padx=5, pady=5, fill=tk.X)\n        tk.Button(btn_frame, text="New Note", command=self.new_note).pack(side=tk.LEFT, expand=True, fill=tk.X)\n        tk.Button(btn_frame, text="Delete", command=self.delete_note).pack(side=tk.LEFT, expand=True, fill=tk.X)\n\n        # Right frame: note details and editor\n        self.right_frame = tk.Frame(self)\n        self.right_frame.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)\n\n        # Title field\n        title_frame = tk.Frame(self.right_frame)\n        title_frame.pack(fill=tk.X, padx=5, pady=5)\n        tk.Label(title_frame, text="Title:").pack(side=tk.LEFT)\n        self.title_entry = tk.Entry(title_frame)\n        self.title_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)\n\n        # Categories and Tags\n        meta_frame = tk.Frame(self.right_frame)\n        meta_frame.pack(fill=tk.X, padx=5, pady=5)\n        tk.Label(meta_frame, text="Categories:").pack(side=tk.LEFT)\n        self.categories_entry = tk.Entry(meta_frame, width=20)\n        self.categories_entry.pack(side=tk.LEFT, padx=(0,10))\n        tk.Label(meta_frame, text="Tags:").pack(side=tk.LEFT)\n        self.tags_entry = tk.Entry(meta_frame, width=20)\n        self.tags_entry.pack(side=tk.LEFT)\n\n        # Toolbar for rich text formatting\n        toolbar = tk.Frame(self.right_frame)\n        toolbar.pack(fill=tk.X, padx=5, pady=5)\n        tk.Button(toolbar, text="Bold", command=self.make_bold).pack(side=tk.LEFT, padx=2)\n        tk.Button(toolbar, text="Italic", command=self.make_italic).pack(side=tk.LEFT, padx=2)\n        tk.Button(toolbar, text="Underline", command=self.make_underline).pack(side=tk.LEFT, padx=2)\n\n        # Text Editor (supports Markdown formatting via insertion of markdown symbols)\n        editor_settings = self.config_data.get("EditorSettings", {})\n        font_size = editor_settings.get("FontSize", 14)\n        font_family = editor_settings.get("FontFamily", "Helvetica")\n        self.text_editor = tk.Text(self.right_frame, wrap=tk.WORD, font=(font_family, font_size))\n        self.text_editor.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)\n\n        # Bottom Buttons\n        bottom_frame = tk.Frame(self.right_frame)\n        bottom_frame.pack(fill=tk.X, padx=5, pady=5)\n        tk.Button(bottom_frame, text="Save Note", command=self.save_note).pack(side=tk.LEFT, padx=2)\n        tk.Button(bottom_frame, text="Export Notes", command=self.export_notes).pack(side=tk.LEFT, padx=2)\n        tk.Button(bottom_frame, text="Import Notes", command=self.import_notes).pack(side=tk.LEFT, padx=2)\n        tk.Button(bottom_frame, text="Preview Markdown", command=self.preview_markdown).pack(side=tk.LEFT, padx=2)\n\n        self.current_note_id = None\n        self.refresh_notes_list()\n\n    def refresh_notes_list(self, notes=None):\n        self.notes_listbox.delete(0, tk.END)\n        if notes is None:\n            notes = self.db.get_all_notes()\n        self.notes = notes  # store current list\n        for note in notes:\n            display_text = f"{note[\'title\']} - {note[\'created_at\'][:19]}"\n            self.notes_listbox.insert(tk.END, display_text)\n\n    def load_selected_note(self):\n        try:\n            index = self.notes_listbox.curselection()[0]\n        except IndexError:\n            return\n        note = self.notes[index]\n        self.current_note_id = note[\'id\']\n        self.title_entry.delete(0, tk.END)\n        self.title_entry.insert(0, note[\'title\'])\n        self.categories_entry.delete(0, tk.END)\n        self.categories_entry.insert(0, note.get(\'categories\', \'\'))\n        self.tags_entry.delete(0, tk.END)\n        self.tags_entry.insert(0, note.get(\'tags\', \'\'))\n        self.text_editor.delete(\'1.0\', tk.END)\n        self.text_editor.insert(tk.END, note[\'content\'])\n\n    def new_note(self):\n        # Clear the editor fields for a new note\n        self.current_note_id = None\n        self.title_entry.delete(0, tk.END)\n        self.categories_entry.delete(0, tk.END)\n        self.tags_entry.delete(0, tk.END)\n        self.text_editor.delete(\'1.0\', tk.END)\n        self.notes_listbox.selection_clear(0, tk.END)\n\n    def save_note(self):\n        title = self.title_entry.get().strip()\n        content = self.text_editor.get(\'1.0\', tk.END).strip()\n        categories = self.categories_entry.get().strip()\n        tags = self.tags_entry.get().strip()\n        \n        if not title or not content:\n            messagebox.showwarning("Validation Error", "Title and content cannot be empty.")\n            return\n        \n        if self.current_note_id:\n            self.db.update_note(self.current_note_id, title, content, categories, tags)\n            messagebox.showinfo("Success", "Note updated successfully.")\n        else:\n            self.db.add_note(title, content, categories, tags)\n            messagebox.showinfo("Success", "Note created successfully.")\n        self.refresh_notes_list()\n\n    def delete_note(self):\n        if not self.current_note_id:\n            messagebox.showwarning("Delete Note", "No note selected.")\n            return\n        if messagebox.askyesno("Confirm Delete", "Are you sure you want to delete this note?"):\n            self.db.delete_note(self.current_note_id)\n            self.new_note()\n            self.refresh_notes_list()\n\n    def perform_search(self):\n        keyword = self.search_var.get().strip()\n        category = self.category_filter_var.get().strip()\n        tag = self.tag_filter_var.get().strip()\n        \n        # If keyword is empty, we default to \'%\' to match everything\n        # But if category or tag filters are provided, they will narrow the search\n        notes = self.db.search_notes(keyword, category if category else None, tag if tag else None)\n        self.refresh_notes_list(notes)\n\n    def export_notes(self):\n        export_path = filedialog.asksaveasfilename(defaultextension=".json", filetypes=[("JSON Files", "*.json")])\n        if export_path:\n            try:\n                self.db.export_notes(export_path)\n                messagebox.showinfo("Export", f"Notes exported to {export_path}")\n            except Exception as e:\n                messagebox.showerror("Export Error", str(e))\n\n    def import_notes(self):\n        import_path = filedialog.askopenfilename(filetypes=[("JSON Files", "*.json")])\n        if import_path:\n            try:\n                self.db.import_notes(import_path)\n                messagebox.showinfo("Import", f"Notes imported from {import_path}")\n                self.refresh_notes_list()\n            except Exception as e:\n                messagebox.showerror("Import Error", str(e))\n\n    def preview_markdown(self):\n        content = self.text_editor.get(\'1.0\', tk.END).strip()\n        if not content:\n            messagebox.showinfo("Preview", "There is no content to preview.")\n            return\n        # Convert Markdown to HTML\n        html_content = markdown.markdown(content)\n        \n        # Create a new window for preview\n        preview_window = tk.Toplevel(self)\n        preview_window.title("Markdown Preview")\n        preview_window.geometry("600x400")\n        \n        if HTMLLabel:\n            html_label = HTMLLabel(preview_window, html=html_content)\n            html_label.pack(fill=\'both\', expand=True)\n        else:\n            # Fallback: display raw HTML if tkhtmlview is not installed\n            text_widget = tk.Text(preview_window, wrap=tk.WORD)\n            text_widget.pack(fill=\'both\', expand=True)\n            text_widget.insert(tk.END, html_content)\n\n    # Rich Text Formatting Functions\n    def get_selected_text_range(self):\n        try:\n            start = self.text_editor.index("sel.first")\n            end = self.text_editor.index("sel.last")\n            return start, end\n        except tk.TclError:\n            return None, None\n\n    def wrap_selection(self, wrapper):\n        start, end = self.get_selected_text_range()\n        if start and end:\n            selected_text = self.text_editor.get(start, end)\n            new_text = f"{wrapper}{selected_text}{wrapper}"\n            self.text_editor.delete(start, end)\n            self.text_editor.insert(start, new_text)\n        else:\n            messagebox.showinfo("Selection Required", "Please select text to format.")\n\n    def make_bold(self):\n        self.wrap_selection("**")\n\n    def make_italic(self):\n        self.wrap_selection("*")\n\n    def make_underline(self):\n        # Markdown does not have a default underline, using HTML underline as a workaround\n        start, end = self.get_selected_text_range()\n        if start and end:\n            selected_text = self.text_editor.get(start, end)\n            new_text = f"<u>{selected_text}</u>"\n            self.text_editor.delete(start, end)\n            self.text_editor.insert(start, new_text)\n        else:\n            messagebox.showinfo("Selection Required", "Please select text to format.")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd7rH[h\xbaRvC\x03\x00\x00C\x03\x00\x00\x07\x00\x00\x00main.pyimport json\nimport os\nfrom database import NoteDatabase\nfrom gui import NotesApp\n\n\ndef load_config(config_file=\'config.json\'):\n    if os.path.exists(config_file):\n        with open(config_file, \'r\', encoding=\'utf-8\') as f:\n            return json.load(f)\n    else:\n        # Default configuration\n        return {\n            "DatabaseFilePath": "notes.db",\n            "Theme": "light",\n            "DefaultExportPath": "exports/",\n            "SupportedFormats": {"RichText": True, "Markdown": True},\n            "EditorSettings": {"FontSize": 14, "FontFamily": "Sans-Serif", "SyntaxHighlighting": True}\n        }\n\n\ndef main():\n    config = load_config()\n    db_path = config.get("DatabaseFilePath", "notes.db")\n    db = NoteDatabase(db_path)\n    app = NotesApp(db, config)\n    app.mainloop()\n\n\nif __name__ == \'__main__\':\n    main()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd7rH[\xc8\xfe\xcbZ\x15\x00\x00\x00\x15\x00\x00\x00\x10\x00\x00\x00requirements.txtmarkdown\n tkhtmlview\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd7rH[-\xf4N\xcb\x05\x03\x00\x00\x05\x03\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nAdd support for note categories and tags:\n- Implement a search function for notes\n- Store note metadata (timestamps, tags, categories)\n- Export and import notes as JSON files\nRich Text & Formatting:\n- Support for Markdown and Rich-Text (bold, italic, headings, lists)\n- Add highlighting and color options for notes\n- Support code snippets with syntax highlighting\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00\xd7rH[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x03\x04\x14\x00\x00\x00\x00\x00\xd7rH[\xe5\xeeM\x16\x8d\x00\x00\x00\x8d\x00\x00\x00\x13\x00\x00\x00inputs/feedback.txtAs of now there is no way of seeing the Markdown result.\nAnd the search function is not able to search through the notes categories and tags.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd7rH[\xd5\x81\xef\xd8(\x01\x00\x00(\x01\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00config.jsonPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd7rH[\x19r]\xceh\x0e\x00\x00h\x0e\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01Q\x01\x00\x00database.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd7rH[G\xbaB\xf4y*\x00\x00y*\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xe2\x0f\x00\x00gui.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd7rH[h\xbaRvC\x03\x00\x00C\x03\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x7f:\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd7rH[\xc8\xfe\xcbZ\x15\x00\x00\x00\x15\x00\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xe7=\x00\x00requirements.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd7rH[-\xf4N\xcb\x05\x03\x00\x00\x05\x03\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01*>\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd7rH[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01]A\x00\x00inputs/environment.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd7rH[\xe5\xeeM\x16\x8d\x00\x00\x00\x8d\x00\x00\x00\x13\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xbaA\x00\x00inputs/feedback.txtPK\x05\x06\x00\x00\x00\x00\x08\x00\x08\x00\xdc\x01\x00\x00xB\x00\x00\x00\x00'