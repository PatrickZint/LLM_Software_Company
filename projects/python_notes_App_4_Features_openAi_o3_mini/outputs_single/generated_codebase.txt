b'PK\x03\x04\x14\x00\x00\x00\x00\x00\x8eTH[\x99\'\x93E\xca\x00\x00\x00\xca\x00\x00\x00\x07\x00\x00\x00main.pyimport tkinter as tk\nfrom ui import NoteApp\n\n\ndef main():\n    root = tk.Tk()\n    root.title("Simple Note Taking App")\n    app = NoteApp(root)\n    root.mainloop()\n\n\nif __name__ == "__main__":\n    main()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x8eTH[-n\x1e\xd6H\n\x00\x00H\n\x00\x00\x0b\x00\x00\x00database.pyimport sqlite3\nfrom datetime import datetime\n\n\nclass Database:\n    def __init__(self, db_name="notes.db"):\n        self.conn = sqlite3.connect(db_name)\n        self.conn.row_factory = sqlite3.Row\n        self.create_table()\n\n    def create_table(self):\n        query = """\n        CREATE TABLE IF NOT EXISTS notes (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            content TEXT,\n            timestamp TEXT,\n            categories TEXT,\n            tags TEXT\n        )\n        """\n        self.conn.execute(query)\n        self.conn.commit()\n\n    def add_note(self, title, content, categories="", tags=""):\n        timestamp = datetime.now().isoformat()\n        query = "INSERT INTO notes (title, content, timestamp, categories, tags) VALUES (?, ?, ?, ?, ?)"\n        self.conn.execute(query, (title, content, timestamp, categories, tags))\n        self.conn.commit()\n\n    def update_note(self, note_id, title, content, categories="", tags=""):\n        timestamp = datetime.now().isoformat()\n        query = "UPDATE notes SET title=?, content=?, timestamp=?, categories=?, tags=? WHERE id=?"\n        self.conn.execute(query, (title, content, timestamp, categories, tags, note_id))\n        self.conn.commit()\n\n    def delete_note(self, note_id):\n        query = "DELETE FROM notes WHERE id=?"\n        self.conn.execute(query, (note_id,))\n        self.conn.commit()\n\n    def get_all_notes(self):\n        query = "SELECT * FROM notes ORDER BY timestamp DESC"\n        cursor = self.conn.execute(query)\n        return [dict(row) for row in cursor.fetchall()]\n\n    def search_notes(self, keyword):\n        query = """\n        SELECT * FROM notes \n        WHERE title LIKE ? OR content LIKE ? OR categories LIKE ? OR tags LIKE ?\n        ORDER BY timestamp DESC\n        """\n        param = f"%{keyword}%"\n        cursor = self.conn.execute(query, (param, param, param, param))\n        return [dict(row) for row in cursor.fetchall()]\n\n    def export_notes(self):\n        notes = self.get_all_notes()\n        return notes\n\n    def import_notes(self, notes):\n        for note in notes:\n            # Expecting note to be a dict with keys: title, content, timestamp, categories, tags\n            query = "INSERT INTO notes (title, content, timestamp, categories, tags) VALUES (?, ?, ?, ?, ?)"\n            self.conn.execute(query, (\n                note.get("title", ""),\n                note.get("content", ""),\n                note.get("timestamp", datetime.now().isoformat()),\n                note.get("categories", ""),\n                note.get("tags", "")\n            ))\n        self.conn.commit()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x8eTH[\x97<\x896\xf7!\x00\x00\xf7!\x00\x00\x05\x00\x00\x00ui.pyimport tkinter as tk\nfrom tkinter import messagebox, filedialog\nimport json\n\nfrom database import Database\n\n\nclass NoteApp:\n    def __init__(self, root):\n        self.root = root\n        self.db = Database()\n        self.selected_note_id = None\n        \n        self.build_ui()\n        self.load_notes()\n    \n    def build_ui(self):\n        # Search Bar\n        search_frame = tk.Frame(self.root)\n        search_frame.pack(fill=tk.X, pady=5)\n        self.search_var = tk.StringVar()\n        search_entry = tk.Entry(search_frame, textvariable=self.search_var)\n        search_entry.pack(side=tk.LEFT, padx=5, expand=True, fill=tk.X)\n        tk.Button(search_frame, text="Search", command=self.search_notes).pack(side=tk.LEFT, padx=5)\n        tk.Button(search_frame, text="Clear", command=self.load_notes).pack(side=tk.LEFT, padx=5)\n        \n        # Note List\n        list_frame = tk.Frame(self.root)\n        list_frame.pack(side=tk.LEFT, fill=tk.Y, padx=5, pady=5)\n        self.note_listbox = tk.Listbox(list_frame, width=30)\n        self.note_listbox.pack(side=tk.LEFT, fill=tk.Y)\n        self.note_listbox.bind("<<ListboxSelect>>", self.on_note_select)\n        scrollbar = tk.Scrollbar(list_frame, orient="vertical")\n        scrollbar.config(command=self.note_listbox.yview)\n        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)\n        self.note_listbox.config(yscrollcommand=scrollbar.set)\n        \n        # Note Details\n        detail_frame = tk.Frame(self.root)\n        detail_frame.pack(side=tk.RIGHT, fill=tk.BOTH, expand=True, padx=5, pady=5)\n        self.detail_text = tk.Text(detail_frame, wrap=tk.WORD)\n        self.detail_text.pack(fill=tk.BOTH, expand=True)\n        \n        # Action Buttons\n        btn_frame = tk.Frame(self.root)\n        btn_frame.pack(fill=tk.X, pady=5)\n        tk.Button(btn_frame, text="Add Note", command=self.add_note).pack(side=tk.LEFT, padx=5)\n        tk.Button(btn_frame, text="Edit Note", command=self.edit_note).pack(side=tk.LEFT, padx=5)\n        tk.Button(btn_frame, text="Delete Note", command=self.delete_note).pack(side=tk.LEFT, padx=5)\n        tk.Button(btn_frame, text="Export", command=self.export_notes).pack(side=tk.LEFT, padx=5)\n        tk.Button(btn_frame, text="Import", command=self.import_notes).pack(side=tk.LEFT, padx=5)\n    \n    def load_notes(self):\n        self.note_listbox.delete(0, tk.END)\n        self.notes = self.db.get_all_notes()\n        for note in self.notes:\n            display_text = f"{note[\'title\']} ({note[\'timestamp\']})"\n            self.note_listbox.insert(tk.END, display_text)\n        self.detail_text.delete(1.0, tk.END)\n        self.selected_note_id = None\n    \n    def on_note_select(self, event):\n        selection = event.widget.curselection()\n        if selection:\n            index = selection[0]\n            note = self.notes[index]\n            self.selected_note_id = note[\'id\']\n            display = (\n                f"Title: {note[\'title\']}\\n"\n                f"Timestamp: {note[\'timestamp\']}\\n"\n                f"Categories: {note.get(\'categories\', \'\')}\\n"\n                f"Tags: {note.get(\'tags\', \'\')}\\n\\n"\n                f"{note[\'content\']}"\n            )\n            self.detail_text.delete(1.0, tk.END)\n            self.detail_text.insert(tk.END, display)\n        else:\n            self.selected_note_id = None\n    \n    def add_note(self):\n        self.note_editor()\n    \n    def edit_note(self):\n        if self.selected_note_id is None:\n            messagebox.showwarning("Select Note", "Please select a note to edit.")\n            return\n        note = next((n for n in self.notes if n["id"] == self.selected_note_id), None)\n        if note:\n            self.note_editor(note)\n    \n    def note_editor(self, note=None):\n        editor = tk.Toplevel(self.root)\n        editor.title("Note Editor")\n        \n        tk.Label(editor, text="Title").grid(row=0, column=0, sticky=tk.W, padx=5, pady=5)\n        title_var = tk.StringVar(value=note["title"] if note else "")\n        title_entry = tk.Entry(editor, textvariable=title_var, width=50)\n        title_entry.grid(row=0, column=1, padx=5, pady=5)\n        \n        tk.Label(editor, text="Categories").grid(row=1, column=0, sticky=tk.W, padx=5, pady=5)\n        cat_var = tk.StringVar(value=note.get("categories", "") if note else "")\n        cat_entry = tk.Entry(editor, textvariable=cat_var, width=50)\n        cat_entry.grid(row=1, column=1, padx=5, pady=5)\n        \n        tk.Label(editor, text="Tags").grid(row=2, column=0, sticky=tk.W, padx=5, pady=5)\n        tag_var = tk.StringVar(value=note.get("tags", "") if note else "")\n        tag_entry = tk.Entry(editor, textvariable=tag_var, width=50)\n        tag_entry.grid(row=2, column=1, padx=5, pady=5)\n        \n        tk.Label(editor, text="Content (Markdown supported)").grid(row=3, column=0, sticky=tk.NW, padx=5, pady=5)\n        content_text = tk.Text(editor, width=60, height=20, wrap=tk.WORD)\n        content_text.grid(row=3, column=1, padx=5, pady=5)\n        if note:\n            content_text.insert(tk.END, note["content"])\n        \n        # Simple formatting toolbar\n        toolbar = tk.Frame(editor)\n        toolbar.grid(row=4, column=1, sticky=tk.W, padx=5, pady=5)\n        tk.Button(toolbar, text="Bold", command=lambda: self.add_formatting(content_text, "**")).pack(side=tk.LEFT, padx=2)\n        tk.Button(toolbar, text="Italic", command=lambda: self.add_formatting(content_text, "_")).pack(side=tk.LEFT, padx=2)\n        tk.Button(toolbar, text="Heading", command=lambda: self.add_formatting(content_text, "#")).pack(side=tk.LEFT, padx=2)\n        \n        def save_note():\n            title = title_var.get()\n            content = content_text.get(1.0, tk.END).strip()\n            categories = cat_var.get()\n            tags = tag_var.get()\n            if not title:\n                messagebox.showwarning("Missing Title", "Title cannot be empty.")\n                return\n            if note:\n                self.db.update_note(note["id"], title, content, categories, tags)\n            else:\n                self.db.add_note(title, content, categories, tags)\n            self.load_notes()\n            editor.destroy()\n        \n        tk.Button(editor, text="Save", command=save_note).grid(row=5, column=1, pady=10)\n    \n    def add_formatting(self, text_widget, markup):\n        try:\n            start = text_widget.index("sel.first")\n            end = text_widget.index("sel.last")\n            selected_text = text_widget.get(start, end)\n            formatted = f"{markup}{selected_text}{markup}"\n            text_widget.delete(start, end)\n            text_widget.insert(start, formatted)\n        except tk.TclError:\n            messagebox.showinfo("No Selection", "Select text to apply formatting.")\n    \n    def delete_note(self):\n        if self.selected_note_id is None:\n            messagebox.showwarning("Select Note", "No note selected.")\n            return\n        if messagebox.askyesno("Delete Note", "Are you sure you want to delete this note?"):\n            self.db.delete_note(self.selected_note_id)\n            self.load_notes()\n            self.detail_text.delete(1.0, tk.END)\n            self.selected_note_id = None\n    \n    def export_notes(self):\n        file_path = filedialog.asksaveasfilename(defaultextension=".json",\n                                                 filetypes=[("JSON Files", "*.json")])\n        if file_path:\n            notes = self.db.export_notes()\n            try:\n                with open(file_path, "w", encoding="utf-8") as f:\n                    json.dump(notes, f, indent=4)\n                messagebox.showinfo("Export", "Notes exported successfully.")\n            except Exception as e:\n                messagebox.showerror("Export Error", f"Failed to export notes: {e}")\n    \n    def import_notes(self):\n        file_path = filedialog.askopenfilename(filetypes=[("JSON Files", "*.json")])\n        if file_path:\n            try:\n                with open(file_path, "r", encoding="utf-8") as f:\n                    notes = json.load(f)\n                self.db.import_notes(notes)\n                self.load_notes()\n                messagebox.showinfo("Import", "Notes imported successfully.")\n            except Exception as e:\n                messagebox.showerror("Import Error", f"Failed to import notes: {e}")\n    \n    def search_notes(self):\n        keyword = self.search_var.get()\n        if keyword:\n            self.note_listbox.delete(0, tk.END)\n            self.notes = self.db.search_notes(keyword)\n            for note in self.notes:\n                display_text = f"{note[\'title\']} ({note[\'timestamp\']})"\n                self.note_listbox.insert(tk.END, display_text)\n        else:\n            self.load_notes()\nPK\x03\x04\x14\x00\x00\x00\x00\x00\x8eTH[-\xf4N\xcb\x05\x03\x00\x00\x05\x03\x00\x00\x10\x00\x00\x00inputs/goals.txtCreate a simple note-taking app allowing users to create, view, and delete personal notes.\nFeatures:\nBasic UI with a list of notes:\n- Add new notes using a simple form\n- Edit and delete existing notes\nData Storage:\n- Store notes locally in a SQLite database\n- Each note has a title, content, and timestamp\nAdd support for note categories and tags:\n- Implement a search function for notes\n- Store note metadata (timestamps, tags, categories)\n- Export and import notes as JSON files\nRich Text & Formatting:\n- Support for Markdown and Rich-Text (bold, italic, headings, lists)\n- Add highlighting and color options for notes\n- Support code snippets with syntax highlighting\nThe result should be a functional application with a UI, so if necessary, create required config files.PK\x03\x04\x14\x00\x00\x00\x00\x00\x8eTH[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtTechnology stack: Use Python and Tkinter.PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x8eTH[\x99\'\x93E\xca\x00\x00\x00\xca\x00\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x8eTH[-n\x1e\xd6H\n\x00\x00H\n\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xef\x00\x00\x00database.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x8eTH[\x97<\x896\xf7!\x00\x00\xf7!\x00\x00\x05\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01`\x0b\x00\x00ui.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x8eTH[-\xf4N\xcb\x05\x03\x00\x00\x05\x03\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01z-\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x8eTH[\x052\xac\xaa)\x00\x00\x00)\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xad0\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\x05\x00\x05\x00#\x01\x00\x00\n1\x00\x00\x00\x00'