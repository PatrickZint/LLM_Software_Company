b'PK\x03\x04\x14\x00\x00\x00\x00\x00\xd3]*[r\t\xce\x1c\x15\x04\x00\x00\x15\x04\x00\x00\x07\x00\x00\x00main.pyimport threading\nimport time\nimport tkinter as tk\nfrom tkinter import messagebox\n\nimport config\nimport gui\nimport file_monitor\nimport database\n\n\ndef start_file_monitor():\n    # Start the file monitoring in a separate thread\n    monitor = file_monitor.FileMonitor()\n    monitor_thread = threading.Thread(target=monitor.start, daemon=True)\n    monitor_thread.start()\n    return monitor\n\n\ndef initialize_database():\n    # Initialize the SQLite database for logging\n    database.initialize_db()\n\n\nif __name__ == \'__main__\':\n    # Ensure configuration file exists/loaded\n    config.load_config()\n    \n    # Initialize the logging database\n    initialize_database()\n\n    # Start file monitoring\n    file_monitor_instance = start_file_monitor()\n    \n    # Launch the GUI\n    root = tk.Tk()\n    app = gui.FileOrganizerApp(root)\n    try:\n        root.mainloop()\n    except KeyboardInterrupt:\n        print(\'Application interrupted by user.\')\n\n    # Cleanup if necessary\n    file_monitor_instance.stop()\n    time.sleep(1)\n    print(\'Application closed.\')\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd3]*[<\x92\x9e\xb3\xf7\x05\x00\x00\xf7\x05\x00\x00\t\x00\x00\x00config.pyimport json\nimport os\n\n# Configuration file path\nCONFIG_FILE = \'config.json\'\n\n# Default configuration\nDEFAULT_CONFIG = {\n    "monitored_directories": [ ],\n    "rules": {\n        "file_type": {\n            ".txt": "organized/text_files",\n            ".jpg": "organized/images",\n            ".png": "organized/images"\n        },\n        "creation_date": {\n            "enabled": true,\n            "path_template": "organized/{year}/{month}"\n        }\n    },\n    "database": {\n        "name": "file_organizer.db"\n    },\n    "report": {\n        "export_path": "reports/"\n    },\n    "monitoring": {\n        "polling_interval": 1\n    }\n}\n\n_config = None\n\n\ndef load_config():\n    global _config\n    if not os.path.exists(CONFIG_FILE):\n        save_config(DEFAULT_CONFIG)\n        _config = DEFAULT_CONFIG\n    else:\n        try:\n            with open(CONFIG_FILE, \'r\') as f:\n                _config = json.load(f)\n        except Exception as e:\n            print(f"Error loading config: {e}")\n            _config = DEFAULT_CONFIG\n    return _config\n\n\ndef get_config():\n    global _config\n    if _config is None:\n        return load_config()\n    return _config\n\n\ndef save_config(cfg):\n    global _config\n    try:\n        with open(CONFIG_FILE, \'w\') as f:\n            json.dump(cfg, f, indent=4)\n        _config = cfg\n    except Exception as e:\n        print(f"Error saving config: {e}")\n\n\nif __name__ == \'__main__\':\n    # For testing purposes, print the current configuration\n    cfg = load_config()\n    print(json.dumps(cfg, indent=4))\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd3]*[\xe7@\x7fe\xc9\x0e\x00\x00\xc9\x0e\x00\x00\x06\x00\x00\x00gui.pyimport tkinter as tk\nfrom tkinter import filedialog, messagebox, ttk\nimport os\n\nimport config\nimport database\nimport report\n\n\nclass FileOrganizerApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\'File Organizer\')\n        self.config = config.get_config()\n        \n        self.create_widgets()\n        self.refresh_logs()\n\n    def create_widgets(self):\n        # Directory selection frame\n        dir_frame = ttk.LabelFrame(self.root, text=\'Monitored Directories\')\n        dir_frame.pack(fill=\'x\', padx=10, pady=5)\n\n        self.dir_listbox = tk.Listbox(dir_frame, height=5)\n        self.dir_listbox.pack(side=\'left\', fill=\'both\', expand=True, padx=5, pady=5)\n        \n        btn_frame = tk.Frame(dir_frame)\n        btn_frame.pack(side=\'right\', padx=5)\n        add_btn = ttk.Button(btn_frame, text=\'Add\', command=self.add_directory)\n        add_btn.pack(fill=\'x\', pady=2)\n        remove_btn = ttk.Button(btn_frame, text=\'Remove\', command=self.remove_directory)\n        remove_btn.pack(fill=\'x\', pady=2)\n\n        # Logs frame\n        logs_frame = ttk.LabelFrame(self.root, text=\'Operation Logs\')\n        logs_frame.pack(fill=\'both\', expand=True, padx=10, pady=5)\n        \n        self.logs_text = tk.Text(logs_frame, wrap=\'none\', height=15)\n        self.logs_text.pack(fill=\'both\', expand=True, padx=5, pady=5)\n\n        # Buttons for refresh logs and export CSV\n        bottom_frame = tk.Frame(self.root)\n        bottom_frame.pack(fill=\'x\', padx=10, pady=5)\n        refresh_btn = ttk.Button(bottom_frame, text=\'Refresh Logs\', command=self.refresh_logs)\n        refresh_btn.pack(side=\'left\')\n        export_btn = ttk.Button(bottom_frame, text=\'Export CSV Report\', command=self.export_csv)\n        export_btn.pack(side=\'left\', padx=10)\n        \n        # Load directories from config\n        self.load_directories()\n\n    def add_directory(self):\n        directory = filedialog.askdirectory()\n        if directory and directory not in self.config[\'monitored_directories\']:\n            self.config[\'monitored_directories\'].append(directory)\n            config.save_config(self.config)\n            self.dir_listbox.insert(tk.END, directory)\n        elif directory in self.config[\'monitored_directories\']:\n            messagebox.showinfo(\'Info\', \'Directory already added.\')\n\n    def remove_directory(self):\n        selection = self.dir_listbox.curselection()\n        if selection:\n            index = selection[0]\n            directory = self.dir_listbox.get(index)\n            self.config[\'monitored_directories\'].remove(directory)\n            config.save_config(self.config)\n            self.dir_listbox.delete(index)\n        else:\n            messagebox.showwarning(\'Warning\', \'No directory selected.\')\n\n    def load_directories(self):\n        self.dir_listbox.delete(0, tk.END)\n        for d in self.config.get(\'monitored_directories\', []):\n            self.dir_listbox.insert(tk.END, d)\n\n    def refresh_logs(self):\n        # Fetch logs from the database and display\n        logs = database.get_all_logs()\n        self.logs_text.delete(\'1.0\', tk.END)\n        for log in logs:\n            # log is a tuple: (timestamp, src, dest, rule)\n            self.logs_text.insert(tk.END, f"{log[0]} | From: {log[1]} | To: {log[2]} | Rule: {log[3]}\\n")\n\n    def export_csv(self):\n        # Ask user where to save CSV report\n        file_path = filedialog.asksaveasfilename(defaultextension=\'.csv\', filetypes=[(\'CSV Files\', \'*.csv\')])\n        if file_path:\n            logs = database.get_all_logs()\n            try:\n                report.export_csv(logs, file_path)\n                messagebox.showinfo(\'Success\', f\'CSV report exported to {file_path}\')\n            except Exception as e:\n                messagebox.showerror(\'Error\', f\'Failed to export CSV: {e}\')\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd3]*[\\\x91\xa8}\xd7\x05\x00\x00\xd7\x05\x00\x00\x0f\x00\x00\x00file_monitor.pyimport time\nimport threading\nimport os\n\nfrom watchdog.observers import Observer\nfrom watchdog.events import FileSystemEventHandler\n\nimport config\nimport rule_engine\n\nclass FileEventHandler(FileSystemEventHandler):\n    def on_modified(self, event):\n        if not event.is_directory:\n            self.process(event.src_path)\n\n    def on_created(self, event):\n        if not event.is_directory:\n            self.process(event.src_path)\n\n    def process(self, file_path):\n        # Apply rules to the detected file.\n        cfg = config.get_config()\n        rule_engine.apply_rules(file_path, cfg)\n\nclass FileMonitor:\n    def __init__(self):\n        self.observer = Observer()\n        self.running = False\n\n    def start(self):\n        self.running = True\n        cfg = config.get_config()\n        directories = cfg.get(\'monitored_directories\', [])\n        event_handler = FileEventHandler()\n\n        for directory in directories:\n            if os.path.isdir(directory):\n                self.observer.schedule(event_handler, directory, recursive=False)\n            else:\n                print(f"Directory does not exist: {directory}")\n\n        self.observer.start()\n        try:\n            while self.running:\n                time.sleep(cfg.get(\'monitoring\', {}).get(\'polling_interval\', 1))\n        except Exception as e:\n            print(f"Monitor error: {e}")\n        finally:\n            self.observer.stop()\n            self.observer.join()\n\n    def stop(self):\n        self.running = False\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd3]*[KrO\x966\t\x00\x006\t\x00\x00\x0e\x00\x00\x00rule_engine.pyimport os\nimport shutil\nimport time\nimport datetime\n\nimport database\n\n# This function applies the file organization rules to a given file\n\ndef apply_rules(file_path, cfg, dry_run=False):\n    if not os.path.isfile(file_path):\n        return\n    \n    file_moved = False\n    applied_rule = None\n    dest_path = None\n    \n    try:\n        # Rule 1: Organize by File Type\n        ext = os.path.splitext(file_path)[1].lower()\n        file_type_rules = cfg.get(\'rules\', {}).get(\'file_type\', {})\n        if ext in file_type_rules:\n            dest_dir = file_type_rules[ext]\n            os.makedirs(dest_dir, exist_ok=True)\n            dest_path = os.path.join(dest_dir, os.path.basename(file_path))\n            applied_rule = f"FileType: {ext}"\n            file_moved = True\n        else:\n            # Rule 2: Organize by Creation Date (if enabled)\n            date_rule_cfg = cfg.get(\'rules\', {}).get(\'creation_date\', {})\n            if date_rule_cfg.get(\'enabled\', False):\n                # Use creation time; on some systems, this may be modified time\n                ctime = os.path.getctime(file_path)\n                dt = datetime.datetime.fromtimestamp(ctime)\n                dest_dir = date_rule_cfg.get(\'path_template\', \'organized/{year}/{month}\').format(year=dt.year, month=dt.month)\n                os.makedirs(dest_dir, exist_ok=True)\n                dest_path = os.path.join(dest_dir, os.path.basename(file_path))\n                applied_rule = f"CreationDate: {dt.year}-{dt.month}"\n                file_moved = True\n\n        if file_moved and dest_path is not None:\n            if dry_run:\n                print(f"Dry run: Would move {file_path} to {dest_path}")\n            else:\n                # Check for potential conflict: if file exists at destination, append timestamp\n                if os.path.exists(dest_path):\n                    base, extension = os.path.splitext(dest_path)\n                    dest_path = base + \'_\' + str(int(time.time())) + extension\n                shutil.move(file_path, dest_path)\n                # Log the operation in the database\n                database.log_operation(time.strftime(\'%Y-%m-%d %H:%M:%S\'), file_path, dest_path, applied_rule)\n                print(f"Moved {file_path} to {dest_path} using rule {applied_rule}")\n    except Exception as e:\n        print(f"Error processing file {file_path}: {e}")\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd3]*[\xad\xc6p\xa9\x1a\x06\x00\x00\x1a\x06\x00\x00\x0b\x00\x00\x00database.pyimport sqlite3\nimport os\n\nimport config\n\n_DB_CONN = None\n\n\ndef initialize_db():\n    cfg = config.get_config()\n    db_name = cfg.get(\'database\', {}).get(\'name\', \'file_organizer.db\')\n    conn = sqlite3.connect(db_name, check_same_thread=False)\n    cursor = conn.cursor()\n    cursor.execute(\'\'\'\n        CREATE TABLE IF NOT EXISTS file_logs (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            timestamp TEXT NOT NULL,\n            source_path TEXT NOT NULL,\n            destination_path TEXT NOT NULL,\n            rule_applied TEXT\n        )\n    \'\'\')\n    conn.commit()\n    global _DB_CONN\n    _DB_CONN = conn\n\n\ndef get_db_connection():\n    global _DB_CONN\n    if _DB_CONN is None:\n        initialize_db()\n    return _DB_CONN\n\n\ndef log_operation(timestamp, source_path, destination_path, rule_applied):\n    try:\n        conn = get_db_connection()\n        cursor = conn.cursor()\n        cursor.execute(\'\'\'\n            INSERT INTO file_logs (timestamp, source_path, destination_path, rule_applied) \n            VALUES (?, ?, ?, ?)\n        \'\'\', (timestamp, source_path, destination_path, rule_applied))\n        conn.commit()\n    except Exception as e:\n        print(f"Failed to log operation: {e}")\n\n\ndef get_all_logs():\n    try:\n        conn = get_db_connection()\n        cursor = conn.cursor()\n        cursor.execute("SELECT timestamp, source_path, destination_path, rule_applied FROM file_logs ORDER BY id DESC")\n        rows = cursor.fetchall()\n        return rows\n    except Exception as e:\n        print(f"Error retrieving logs: {e}")\n        return []\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd3]*[\xe1\x88\x05\xb7\xd0\x01\x00\x00\xd0\x01\x00\x00\t\x00\x00\x00report.pyimport csv\n\n\ndef export_csv(logs, output_file):\n    # logs is expected to be a list of tuples: (timestamp, source_path, destination_path, rule_applied)\n    with open(output_file, mode=\'w\', newline=\'\', encoding=\'utf-8\') as csvfile:\n        writer = csv.writer(csvfile)\n        # Write header\n        writer.writerow(["Timestamp", "Source Path", "Destination Path", "Rule Applied"])\n        # Write log rows\n        for log in logs:\n            writer.writerow(log)\nPK\x03\x04\x14\x00\x00\x00\x00\x00\xd3]*[\\\xa0\xcf\x08\x8b\x01\x00\x00\x8b\x01\x00\x00\x10\x00\x00\x00inputs/goals.txtDevelop an automated file organizer that sorts files into folders based on type or creation date.\nThe result should be a functional application with a UI, so if necessary, create required config files.\nFeatures:\n- Monitor a specified directory for new files\n- Move files into organized folders based on rules\n- Store logs of file movements in a database\n- Export file organization reports as CSVPK\x03\x04\x14\x00\x00\x00\x00\x00\xd3]*[1OT\xd1\x7f\x00\x00\x00\x7f\x00\x00\x00\x16\x00\x00\x00inputs/environment.txtThe system must provide a reasonable performance.\nTechnology stack: Use Python, SQLite3, and the standard library (os, shutil).PK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd3]*[r\t\xce\x1c\x15\x04\x00\x00\x15\x04\x00\x00\x07\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x00\x00\x00\x00main.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd3]*[<\x92\x9e\xb3\xf7\x05\x00\x00\xf7\x05\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01:\x04\x00\x00config.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd3]*[\xe7@\x7fe\xc9\x0e\x00\x00\xc9\x0e\x00\x00\x06\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01X\n\x00\x00gui.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd3]*[\\\x91\xa8}\xd7\x05\x00\x00\xd7\x05\x00\x00\x0f\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01E\x19\x00\x00file_monitor.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd3]*[KrO\x966\t\x00\x006\t\x00\x00\x0e\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01I\x1f\x00\x00rule_engine.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd3]*[\xad\xc6p\xa9\x1a\x06\x00\x00\x1a\x06\x00\x00\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xab(\x00\x00database.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd3]*[\xe1\x88\x05\xb7\xd0\x01\x00\x00\xd0\x01\x00\x00\t\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xee.\x00\x00report.pyPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd3]*[\\\xa0\xcf\x08\x8b\x01\x00\x00\x8b\x01\x00\x00\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\xe50\x00\x00inputs/goals.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\xd3]*[1OT\xd1\x7f\x00\x00\x00\x7f\x00\x00\x00\x16\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x80\x01\x9e2\x00\x00inputs/environment.txtPK\x05\x06\x00\x00\x00\x00\t\x00\t\x00\x0b\x02\x00\x00Q3\x00\x00\x00\x00'